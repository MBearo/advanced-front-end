
## 如何突破前端开发技术瓶颈

日本后现代主义作家村上春树写过一本富有哲理的书——《当我谈跑步时我谈些什么》。

书中，他谈到，跑步跟写作一样：都需要坚毅隐忍，追逐超越；都需要心无杂念，持之以恒。全书落笔之处，没有浮华旖旎，而是娓娓道来迷惘、失败和挣扎。

这本书名义上是在谈跑步，却是在个人创作低潮时期对突破的不断思考。仔细想来，这样的思考对于一位工程师也至关重要。

前端领域，入门相对简单，可是想要“更上一层楼”却难上加难，也就是我们常说的“职业天花板较低”，君不见——市场上高级/资深前端工程师凤毛麟角。这当然未必完全是坏事，一旦突破瓶颈，在技能上脱颖而出，便是更广阔的空间。那么，如何从夯实基础到突破瓶颈？

接下来就让我们一起来讨论下：当前端工程师需要进阶时，我们学些什么。

### 直面自我——前端工程师的焦虑和迷茫

说到进阶，我想先谈谈我们每个人内心的焦虑和迷茫，正视这种情绪是学习的第一步。对于每一个追求进步的人来说，瓶颈期总会在各个阶段“如约而至”。早在公元前某年，庄子就说过：

> 吾生也有涯，而知也无涯。以有涯随无涯，殆已！已而为知者，殆而已矣！

而现如今，信息爆炸时代，信息量呈几何级数增长，知识似乎唾手可得。那么“该学什么？”，“到底该怎么学？”，“学完之后又该做什么？”，大部分人都会在知识面前焦虑、迷茫。

同样地，对于有一定工作经验的工程师来说：

  * 我该如何避免相似的工作做三年，而不是具备了三年的工作经验？
  * 我该如何从繁杂而千篇一律的业务需求中提炼技术点并总结提高？
  * 我该如何为团队带来更大的价值，体现经验能力？

这些困扰对 **前端工程师**
来说貌似来得更加猛烈：前端技术发展备受瞩目，前端工程师变得越发重要的背后是相关技术的不断扩张和更新换代。因此，我们比以往任何时候都更需要主动学习。但据我观察，目前网络上的学习资料往往存在以下两个问题：

  * 过于碎片化，这类知识某种程度上只能成为缓解焦虑的精神鸦片
  * 追求短平快，大牛经验、快速搞定“面经题目”，渐渐演变成为跳槽加薪的兴奋剂

前端学习，尤其是进阶阶段的学习是一个 **系统曲折**
的过程。每个学习者所接触的知识内容和其背后的原理构建成了他的思维方式。短期速成的内容或者大量碎片化的知识很难帮助我们深度思考。坦白来说，我也是这些“学习资料”的搜集者，如果没有系统针对性地学习和反复的刻意练习，那么结果就是
**以为收藏的是知识，其实收藏的是“知道”。以为掌握了知识，其实只是囤积了一堆“知道”。**

当 GitChat 联系我想要打造一门系统而全面的前端进阶课程时，我欣然接受。不光是因为想把自己在海外和 BAT
服务多年积累的经验分享给大家，也是想把长时间以来收藏的“干货”梳理一遍，系统性整理输出，和大家一起总结提高。最终，就是呈现在大家面前的这门《前端开发核心知识进阶》课程。

爱因斯坦说过：

> 只是学习他人的智慧并不足够，你需要自己想明白才行。花时间记录、通盘考虑和深入思考你学到的东西。

海伦·凯勒说过：

> 知识使人进步，而智慧使人得道。

希望这门课程不仅详述“知识”，更能体现编程“智慧”，能让所有订阅的朋友们一起思考，一起进步。

![](https://images.gitbook.cn/6b7210a0-5103-11e9-94b7-c74b6c916ba4)

配图来自：电影《银河系漫游指南》海报

### 课程特色——基础和进阶，理论和实践

说到课程特色，我想一边聊聊前端开发的发展，一边说说我们课程的聚焦点。

#### **前端的大航海时代，有旧工具淘汰，更有新力量崛起**

记得我刚接触前端编程时，jQuery 风靡一时，其清新优雅的 DOM 操作、稳如磐石的兼容性处理、灵活高效的封装和链式调用，让人如沐春风。

彼时，我幼稚地以为“这就是颠覆”，事实却是“这只是开始”——随着三大框架的崛起，技术更迭就像“暴风雨前的宁静”，jQuery
突然就被其他“先进的生产力”抛在背后了。于是我们看见：2018 年 9 月，[Removing jQuery from GitHub.com
frontend](https://github.blog/2018-09-06-removing-jquery-from-github-
frontend/)，各大平台技术进行“改朝换代”，引领开发潮流。

这还只是一个类库在前端浪潮中的兴衰。再想想 ES 语言规范的演进速度，HTML5 的扩张幅度，跨端从 Ionic 到 React Native 再到
Flutter，CSS 从基本布局模型到弹性盒模型再到原生 Grid 方案，构建工具从 Grunt 到 Gulp 再到
webpack/Rollup......

这门课程，我们在重视“亘古不变”的语言基础上，力求为大家介绍更先进的开发技术。比如服务端渲染，比如 HTTP 3.0，比如使用 Lerna、yarn
workspaces 构建 monorepo 项目，比如框架演进和虚拟 DOM，等等。

>
[点击了解更多《前端开发核心知识进阶》](http://gitbook.cn/m/mazi/comp/column?columnId=5c91c813968b1d64b1e08fde&utm_source=hcsd001)

![](https://images.gitbook.cn/18aca040-510a-11e9-adfc-e397a85e435c)

配图来自：《海贼王》

#### **前端开发有着与生俱来的混乱，需要我们披荆斩棘，在实践中勇往直前**

前端三大方向 JavaScript、CSS、 HTML
的背后是无尽的碎片化场景。前端是最贴近用户的“战线”，它基因里就需要处理“大象万千”。同时，不管是跨平台还是语言特性，它都会让开发者感到迷茫：

  * “我们该使用哪些 HTML 标签以达到最佳的语义化？”
  * “我们该如何面对不同终端的诡异问题，并保证体验一致性？”
  * “我们如何写 JavaScript 做到 bug free？”
  * “this 乱七八糟，它到底指向谁？”
  * ……

这门课程，我们除了剖析理论，更加注重经验指导和最佳实践。

比如：

  * 《性能监控和错误收集与上报》是分析多种场景和业界解决方案的产出；
  * 《深入浅出模块化（含 tree shaking）》中，实战观摩 webpack 打包结果，对比 Rollup 解决方案，同时分析 tree shaking 的实施细节；
  * 《前端工程化背后的项目组织设计》探索究竟该如何组织架构代码，解放开发效率；
  * 《不可忽视的网络安全：单页应用鉴权设计》不去讲解 CSRF、XSS 等“死概念”，而是从鉴权角度出发，让读者对安全有一个立体认知。

![](https://images.gitbook.cn/891513d0-510f-11e9-adfc-e397a85e435c)

配图来自：《七龙珠》

#### **前端开发工程师有广阔的未来，但“打铁还需自身硬”**

目前我们正在经历所谓的“资本寒冬”，不管是大厂、二线公司还是创业团队，“优化人员结构（裁员）”的新闻层出不穷。但是据我观察，“高级前端工程师”的招聘需求却“逆流而上”，具备高水平和经验的开发者无论在任何时候都备受追捧。因此，磨练技能、积累项目经验将是所有前端工程师的核心诉求。

作为内容贡献者，我也在思考如何让这门课程更有价值，真正帮助大家突破瓶颈，让读者感到“物有所值”，进而实现进阶。

这门课程中，我将穿插大量经典面试例题，其中既包括我作为 BAT
面试官的“私房题”，又涵盖我作为面试者遇见的“经典题”，以及和业界前辈讨论过的“开放题”。在平时开发和学习中，我也收藏积累了大量精品文章，会一并分享给大家。

从开发菜鸟到资深工程师，除了主观能动性以外，我个人认为成长过程中的一大瓶颈在于“不是每个人都能有机会接触到好项目”。这里的“好项目”是指类似“项目重构”、“类库迁移”、“复杂应用设计”、“疑难
bug 定位”等对开发者基础和设计能力有高要求的项目。

在这门课程中，我会插入大量代码设计模式、函数式、源码分析、组件设计和封装、开源库解读、项目代码组织等内容，也会手把手带领大家查阅
issue、changelog，从社区中汲取精华。构建更为真实的开发场景，直击实践中的高频痛点。

最后，也希望和每一位读者保持长线联系，一起讨论问题，共同进步。

![](https://images.gitbook.cn/e0049a50-5112-11e9-94b7-c74b6c916ba4)

配图来自：《蜘蛛侠：平行宇宙》

### 课程简介——8 部分 36 个主题 50 课

  * **第一部分：JavaScript 基础强化（第 1-1~1-6 课）**

**第二部分 JavaScript 语言进阶（第 2-1~2-6 课）**

**第三部分 不可忽视的 HTML 和 CSS（第 3-1~3-3 课）**

其中前三部分介绍 JavaScript、 HTML、CSS ，对于一些热点、重点话题，比如“this
指向”、“闭包、作用域、执行上下文”，以及一些高频考察点进行了深入分析；对面向对象、原型与原型链、异步这些内容进行强化，从实现的角度，结合具体实例分析
Promise；结合 ES Next，从 ES 的发展来看语言的演进。

  * **第四部分 前端框架（第 4-1~4-7 课）**

接下来进入了 **前端框架** 部分，我们以 React 为主，分析框架对前端到底意味着什么，以及我们应该如何学习 React。事实上，对 React
的学习，不能只停留在“会用”的层面，其设计原理和思想演进，对于培养编程思维非常有益，也有利于学习者能从更高的角度看待问题。

  * **第五部分 前端工程化（第 5-1~5-8 课）**

资深程序员永远逃不开的工作之一就是“基础构建”、“项目架构”。前端工程化部分我们从代码组织谈起，从规范实施谈起，结合 webpack、Lerna
等工具，为大家还原一个真实的“基建”场景，共同探索学习。

  * **第六部分 性能优化（第 6-1~6-6 课）**

性能优化是理论和实践相结合的重要话题。

我们需要大量理论知识：明白缓存策略，了解浏览器渲染特点，清楚 JavaScript
异步单线程对性能意味着什么，还要了解网络传输知识，等等。我们也需要大量实践经验：用得了 Chrome Devtool 分析火焰图，跑得出准确的
benchmark，知道防抖和节流的区别，懂得资源合并、拆分的利弊，了解业界最新性能优化方案，等等。

这一部分，我们除了介绍重要大量知识点外，也会结合代码/项目实例来展开。

  * **第七部分 编程思维和算法（第 7-1~7-8 课）**

前端开发离不开编程基础，培养良好的编程思维，了解基本的算法知识，是每一个工程师所必须具备的。在这一部分，我们用 JavaScript
来描述多种设计模式，设计模式并不是纸上谈兵，实实在在地存在于我们的业务代码当中；手把手带大家用 JavaScript
处理各种数据，说到底前端还是处理数据，展示 UI；当然更少不了对一些常见算法的强化。

  * **第八部分 网络知识（第 8-1~8-5 课）**

作为一名前端开发者，不了解互联网传输的奥秘，不清楚网络细节是难以进阶的。网络知识关联着性能优化、前后端协作等核心环节，因此这一部分我们将重点强化网络基础。

  * **结束语：软技巧**

学习进步离不开社区的力量，“授人予鱼不如授人予渔”。在课程的最后，我会讲述我的学习方法：如何投身到社区当中，与广大开发者一起讨论；如何阅读前人的经典思想，站在巨人的肩上看得更远；如何解读开源库，从中汲取养分；如何在面试和述职当中，正确地表达汇报……

![avatar](https://images.gitbook.cn/FgIBo4ircxuXMlHQDLi_zsoN8HwW)

>
[点击了解更多《前端开发核心知识进阶》](http://gitbook.cn/m/mazi/comp/column?columnId=5c91c813968b1d64b1e08fde&utm_source=hcsd001)

### 学习建议

建议大家在阅读课程过程中，手动执行文内代码，同时养成打断点或 console.log
调试的好习惯。此课程对应的代码仓库：<https://github.com/HOUCe/lucas-gitchat-courses>

### 分享交流

我们为本课程 **付费读者** 创建了《前端开发核心知识进阶》微信交流群，以方便更有针对性地讨论课程相关问题。（入群请到第1-2课末尾添加 GitChat
小助手伽利略的微信，注明「前端核心」。）

> 温馨提示：需购买才可入群哦，加小助手后需要截已购买的图来验证~



## 一网打尽 this，对执行上下文说 Yes

JavaScript 中的
`this`，因其灵活的指向、复杂的使用场景一直是面试中的热点，不论是初级还是中高级开发者，这都是一道必考题。这个概念虽然基础，但是非常重要，是否能深刻理解
`this`，是前端 JavaScript 中进阶的重要一环。`this` 指向多变，很多隐蔽的 bug 都缘于它。与此同时，`this`
强大灵活，如果能熟练驾驭，就会写出更简洁、优雅的代码。

社区上对于 `this` 的讲解虽然不少，但缺乏统一梳理。本节课，让我们直面 `this` 的方方面面，并通过例题真正领会与掌握 `this`。

`this` 相关知识点如下：

![](https://images.gitbook.cn/be333ca0-4eca-11e9-b0b8-a9c8a3696845)

### this 到底指向谁

曾经在面试阿里某重点部门时，面试官从多个角度考察过我对 `this` 的理解：全局环境下的`this`、箭头函数的 `this`、构造函数的
`this`、`this` 的显隐性和优先级，等等。尽管我能一一作答，可是最后的问题： **请用一句话总结`this` 的指向，注意只用一句话。**
我却犯难了。

有一种广泛流传的说法是：

> 谁调用它，`this` 就指向谁。

也就是说，`this` 的指向是在调用时确定的。这么说没有太大的问题，可是并不全面。面试官要求我用更加规范的语言进行总结，那么他到底在等什么样的回答呢？

我们还要回到 JavaScript 中一个最基本的概念分析—— **执行上下文** ，这个概念，我们会在下一讲《老司机也会在闭包相关知识点翻车》中进行扩展。

事实上，调用函数会创建新的属于函数自身的执行上下文。执行上下文的调用创建阶段会决定 `this` 的指向。到此，我们可以得出的一个结论：

`this` 的指向，是在调用函数时根据执行上下文所动态确定的。

具体环节和规则，可以先“死记硬背”以下几条规律，后面再慢慢一一分析：

  * 在函数体中，简单调用该函数时（非显式/隐式绑定下），严格模式下 `this` 绑定到 `undefined`，否则绑定到全局对象 `window`／`global`；
  * 一般构造函数 `new` 调用，绑定到新创建的对象上；
  * 一般由 `call`/`apply`/`bind` 方法显式调用，绑定到指定参数的对象上；
  * 一般由上下文对象调用，绑定在该对象上；
  * 箭头函数中，根据外层上下文绑定的 `this` 决定 `this` 指向。

当然，真实环境多样，我们来逐一梳理。

>
[点击了解更多《前端开发核心知识进阶》](http://gitbook.cn/m/mazi/comp/column?columnId=5c91c813968b1d64b1e08fde&utm_source=hcsd001)

### 实战例题分析

#### 例题组合 1：全局环境下的 this

这种情况相对简单直接，函数在浏览器全局环境中被简单调用，非严格模式下 `this` 指向 `window`；在 `use strict`
指明严格模式的情况下就是 `undefined`。我们来看例题，请描述打印结果：

    
    
    function f1 () {
        console.log(this)
    }
    function f2 () {
        'use strict'
        console.log(this)
    }
    f1() // window
    f2() // undefined
    

这样的题目比较基础，但是需要候选人格外注意其变种，请再看一道题目：

    
    
    const foo = {
        bar: 10,
        fn: function() {
           console.log(this)
           console.log(this.bar)
        }
    }
    var fn1 = foo.fn
    fn1()
    

这里 `this` 仍然指向的是 `window`。虽然 `fn` 函数在 `foo` 对象中作为方法被引用，但是在赋值给 `fn1` 之后，`fn1`
的执行仍然是在 `window` 的全局环境中。因此输出 `window` 和 `undefined`，它们相当于：

    
    
    console.log(window)
    console.log(window.bar)
    

还是上面这道题目，如果调用改变为：

    
    
    const foo = {
        bar: 10,
        fn: function() {
           console.log(this)
           console.log(this.bar)
        }
    }
    foo.fn()
    

将会输出：

    
    
    {bar: 10, fn: ƒ}
    10
    

因为这个时候 `this` 指向的是最后调用它的对象，在 `foo.fn()` 语句中 `this` 指向 `foo` 对象。请记住：

在执行函数时，如果函数中的 `this` 是被上一级的对象所调用，那么 `this` 指向的就是上一级的对象；否则指向全局环境。

#### 例题组合 2：上下文对象调用中的 this

如上结论，面对下题时我们便不再困惑：

    
    
    const student = {
        name: 'Lucas',
        fn: function() {
            return this
        }
    }
    console.log(student.fn() === student)
    

最终结果将会返回 `true`。

当存在更复杂的调用关系时，请看例题：

    
    
    const person = {
        name: 'Lucas',
        brother: {
            name: 'Mike',
            fn: function() {
                return this.name
            }
        }
    }
    console.log(person.brother.fn())
    

在这种嵌套的关系中，`this` 指向 **最后** 调用它的对象，因此输出将会是：`Mike`。

到此，`this` 的上下文对象调用已经理解得比较清楚了。我们再看一道更高阶的题目：

    
    
    const o1 = {
        text: 'o1',
        fn: function() {
            return this.text
        }
    }
    const o2 = {
        text: 'o2',
        fn: function() {
            return o1.fn()
        }
    }
    const o3 = {
        text: 'o3',
        fn: function() {
            var fn = o1.fn
            return fn()
        }
    }
    
    console.log(o1.fn())
    console.log(o2.fn())
    console.log(o3.fn())
    

答案是：`o1`、`o1`、`undefined`，你答对了吗？

我们来一一分析。

  * 第一个 `console` 最简单，`o1` 没有问题。难点在第二个和第三个上面，关键还是看调用 `this` 的那个函数。
  * 第二个 `console` 的 `o2.fn()`，最终还是调用 `o1.fn()`，因此答案仍然是 `o1`。
  * 最后一个，在进行 `var fn = o1.fn` 赋值之后，是“裸奔”调用，因此这里的 `this` 指向 `window`，答案当然是 `undefined`。

如果面试者回答顺利，可以紧接着追问，如果我们需要让：

    
    
    console.log(o2.fn())
    

输出 `o2`，该怎么做？

一般开发者可能会想到使用 `bind/call/apply` 来对 `this` 的指向进行干预，这确实是一种思路。但是我接着问，
**如果不能使用`bind/call/apply`，有别的方法吗？**

这样可以考察候选人基础掌握的深度以及随机应变的思维能力。答案为：

    
    
    const o1 = {
        text: 'o1',
        fn: function() {
            return this.text
        }
    }
    const o2 = {
        text: 'o2',
        fn: o1.fn
    }
    
    console.log(o2.fn())
    

还是应用那个重要的结论：`this` 指向 **最后** 调用它的对象，在 `fn` 执行时，挂到 `o2` 对象上即可，我们提前进行了赋值操作。

#### 例题组合 3：bind/call/apply 改变 this 指向

上文提到 bind/call/apply，在这个概念上，比较常见的基础考察点是： **bind/call/apply 三个方法的区别。**

这样的问题相对基础，我们直接上答案：一句话总结，他们都是用来改变相关函数 `this` 指向的，但是 `call/apply`
是直接进行相关函数调用；`bind` 不会执行相关函数，而是返回一个新的函数，这个新的函数已经自动绑定了新的 `this`
指向，开发者需要手动调用即可。再具体的 `call/apply` 之间的区别主要体现在参数设定上，这里不再展开。

用代码来总结：

    
    
    const target = {}
    fn.call(target, 'arg1', 'arg2')
    

相当于：

    
    
    const target = {}
    fn.apply(target, ['arg1', 'arg2'])
    

相当于：

    
    
    const target = {}
    fn.bind(target, 'arg1', 'arg2')()
    

具体基础用法这里不再科普，如果读者尚不清楚，需要自己补充一下知识点。

我们来看一道例题分析：

    
    
    const foo = {
        name: 'lucas',
        logName: function() {
            console.log(this.name)
        }
    }
    const bar = {
        name: 'mike'
    }
    console.log(foo.logName.call(bar))
    

将会输出 `mike`，这不难理解。 **但是对 call/apply/bind
的高级考察往往会结合构造函数以及组合式实现继承。实现继承的话题，我们会单独讲到。构造函数的使用案例，我们结合接下来的例题组合进行分析。**

#### 例题组合 4：构造函数和 this

这方面最直接的例题为：

    
    
    function Foo() {
        this.bar = "Lucas"
    }
    const instance = new Foo()
    console.log(instance.bar)
    

答案将会输出 `Lucas`。但是这样的场景往往伴随着下一个问题： **`new` 操作符调用构造函数，具体做了什么？** 以下供参考：

  * 创建一个新的对象；
  * 将构造函数的 `this` 指向这个新对象；
  * 为这个对象添加属性、方法等；
  * 最终返回新对象。

以上过程，也可以用代码表述：

    
    
    var obj  = {}
    obj.__proto__ = Foo.prototype
    Foo.call(obj)
    

当然，这里对 `new` 的模拟是一个简单基本版的，更复杂的情况我们会在原型、原型链相关的第2-5课《面向对象和原型——永不过时的话题》中讲述。

需要指出的是，如果在构造函数中出现了显式 `return` 的情况，那么需要注意分为两种场景：

    
    
    function Foo(){
        this.user = "Lucas"
        const o = {}
        return o
    }
    const instance = new Foo()
    console.log(instance.user)
    

将会输出 `undefined`，此时 `instance` 是返回的空对象 `o`。

    
    
    function Foo(){
        this.user = "Lucas"
        return 1
    }
    const instance = new Foo()
    console.log(instance.user)
    

将会输出 `Lucas`，也就是说此时 `instance` 是返回的目标对象实例 `this`。

**结论：** 如果构造函数中显式返回一个值，且返回的是一个对象，那么 `this` 就指向这个返回的对象；如果返回的不是一个对象，那么 `this`
仍然指向实例。

#### 例题组合 5：箭头函数中的 this 指向

首先我们再来温习一下相关结论。

**结论：** 箭头函数使用 `this` 不适用以上标准规则，而是根据外层（函数或者全局）上下文来决定。

来看题目：

    
    
    const foo = {  
        fn: function () {  
            setTimeout(function() {  
                console.log(this)
            })
        }  
    }  
    console.log(foo.fn())
    

这道题中，`this` 出现在 `setTimeout()` 中的匿名函数里，因此 `this` 指向 `window` 对象。如果需要 `this` 指向
`foo` 这个 object 对象，可以巧用箭头函数解决：

    
    
    const foo = {  
        fn: function () {  
            setTimeout(() => {  
                console.log(this)
            })
        }  
    } 
    console.log(foo.fn())
    
    // {fn: ƒ}
    

单纯箭头函数中的 `this` 非常简单， **但是综合所有情况，结合`this` 的优先级考察，这时候 `this` 指向并不好确定。请继续阅读。**

#### 例题组合 6：this 优先级相关

我们常常把通过 `call`、`apply`、`bind`、`new` 对 `this` 绑定的情况称为显式绑定；根据调用关系确定的 `this`
指向称为隐式绑定。

**那么显式绑定和隐式绑定谁的优先级更高呢？**

请看例题：

    
    
    function foo (a) {
        console.log(this.a)
    }
    
    const obj1 = {
        a: 1,
        foo: foo
    }
    
    const obj2 = {
        a: 2,
        foo: foo
    }
    
    obj1.foo.call(obj2)
    obj2.foo.call(obj1)
    

输出分别为 2、1，也就是说 `call`、`apply` 的显式绑定一般来说优先级更高。

    
    
    function foo (a) {
        this.a = a
    }
    
    const obj1 = {}
    
    var bar = foo.bind(obj1)
    bar(2)
    console.log(obj1.a)
    

上述代码通过 `bind`，将 `bar` 函数中的 `this` 绑定为 `obj1` 对象。执行 `bar(2)` 后，`obj1.a` 值为
2。即经过 `bar(2)` 执行后，`obj1` 对象为：`{a: 2}`。

当再使用 `bar` 作为构造函数时：

    
    
    var baz = new bar(3)
    console.log(baz.a)
    

将会输出 3。我们看 `bar` 函数本身是通过 `bind` 方法构造的函数，其内部已经对将 `this` 绑定为 `obj1`，它再作为构造函数，通过
`new` 调用时，返回的实例已经与 `obj1` 解绑。 也就是说：

**`new` 绑定修改了 `bind` 绑定中的 `this`，因此 `new` 绑定的优先级比显式 `bind` 绑定更高。**

我们再看：

    
    
    function foo() {
        return a => {
            console.log(this.a)
        };
    }
    
    const obj1 = {
        a: 2
    }
    
    const obj2 = {
        a: 3
    }
    
    const bar = foo.call(obj1)
    console.log(bar.call(obj2))
    

将会输出 2。由于 `foo()` 的 `this` 绑定到 `obj1`，`bar`（引用箭头函数）的 `this` 也会绑定到
`obj1`，箭头函数的绑定无法被修改。

如果将 `foo` 完全写成箭头函数的形式：

    
    
    var a = 123
    const foo = () => a => {
        console.log(this.a)
    }
    
    const obj1 = {
        a: 2
    }
    
    const obj2 = {
        a: 3
    }
    
    var bar = foo.call(obj1)
    console.log(bar.call(obj2))
    

将会输出 `123`。

这里我再“抖个机灵”，仅仅将上述代码的第一处变量 `a` 的赋值改为：

    
    
    const a = 123
    const foo = () => a => {
        console.log(this.a)
    }
    
    const obj1 = {
        a: 2
    }
    
    const obj2 = {
        a: 3
    }
    
    var bar = foo.call(obj1)
    console.log(bar.call(obj2))
    

答案将会输出为 `undefined`，原因是因为使用 `const` 声明的变量不会挂载到 `window` 全局对象当中。因此 `this` 指向
`window` 时，自然也找不到 `a` 变量了。关于 `const` 或者 `let` 等声明变量的方式不再本课的主题当中，我们后续也将专门进行介绍。

到这里，读者是否有“融会贯通”的感觉了呢？如果还有困惑，也不要灰心。进阶的关键就是基础，基础需要反复学习，“死记硬背”后才能慢慢体会。

### 开放例题分析

不知道实战例题分析是否已经把你绕晕了。事实上，`this` 的指向涉及的规范繁多，优先级也较为混乱。
**刻意刁难并不是很好的面试做法，一些细节候选人如果没有记住也不是太大的问题。作为面试官，我往往会另辟蹊径，出一些开放性题目。**

其中，最典型的一道题目为： **实现一个`bind` 函数。**

作为面试者，我也曾经在头条的面试流程中被问到模拟 `bind`。这道题并不新鲜，部分读者也会有自己的解答思路，而且社区上关于原生 `bind`
的研究也很多。但是，我们这里想强调的是，可能有一些细节被大家忽略了。在回答时，我往往先实现一个初级版本，然后根据 ES5-shim 源码进一步说明。

    
    
    Function.prototype.bind = Function.prototype.bind || function (context) {
        var me = this;
        var args = Array.prototype.slice.call(arguments, 1);
        return function bound () {
            var innerArgs = Array.prototype.slice.call(arguments);
            var finalArgs = args.concat(innerArgs);
            return me.apply(context, finalArgs);
        }
    }
    

这样的实现已经非常不错了。但是，就如同之前 `this` 优先级分析所示： **`bind` 返回的函数如果作为构造函数，搭配 `new`
关键字出现的话，我们的绑定 `this` 就需要“被忽略”。**

为了实现这样的规则，开发者就应该需要考虑如何区分这两种调用方式。 **具体来讲`bound` 函数中就要进行 `this instanceof`
的判断。**

另外一个细节是，函数具有 `length` 属性，表示形参的个数。上述实现方式形参的个数显然会失真。我们的实现就需要对 `length` 属性进行还原。可是
**难点在于：函数的`length` 属性值是不可重写的。**

这样的内容一般属于“超纲”范畴，但在面试中能够很好地体现面试者平时的积累，以及对源码的阅读和思考，显然是加分项。对此进一步的理解，读者可参考我的原创文章：[从一道面试题，到“我可能看了假源码”](https://www.jianshu.com/p/6958f99db769)。这篇文章发表于
2017 年年初，可以说是现在很多研究 `bind` 相关文章的启蒙。

### 总结

通过本课的学习，我们看到 `this` 纷繁多象，确实不容易彻底掌握。本节尽可能系统地进行讲解、说明，例题尽可能地覆盖更多
case。与此同时，需要读者在阅读之外继续进行消化与吸收。只有“记死”，才能“用活”。请读者随时关注课程，接下来会更新更多大家感兴趣的话题，让我们一起进步。

>
[点击了解更多《前端开发核心知识进阶》](http://gitbook.cn/m/mazi/comp/column?columnId=5c91c813968b1d64b1e08fde&utm_source=hcsd001)

### 分享交流

请大家留言分享开发实践中遇到的 `this` 相关的难忘 bug。阅读文章过程中有任何疑问随时可以跟其他小伙伴讨论，或者直接向作者 LucasHC 提问。
**你的分享不仅帮助他人，更会提升自己。**

你也可以说说自己最想了解的主题，课程内容会根据部分读者的意见和建议迭代和完善。

此外，我们为本课程 **付费读者** 创建了《前端开发核心知识进阶》微信交流群，以方便更有针对性地讨论课程相关问题。（入群请到第1-2课末尾添加
GitChat 小助手伽利略的微信，注明「前端核心」。）

> 温馨提示：需购买才可入群哦，加小助手后需要截已购买的图来验证~



## 老司机也会在闭包相关知识点翻车（上）

闭包是 JavaScript 中最基本也是最重要的概念之一，很多开发者都对它“了如指掌”。可是闭包又绝对不是一个单一的概念：
**它涉及作用域、作用域链、执行上下文、内存管理等多重知识点。**
不管是新手还是“老司机”，经常会出现“我觉得我弄懂了闭包，但是还会在一些场景翻车”的情况。这一课我们就对这个话题进行梳理，并最后以“应试题”来强化理解闭包。

先看一下跟闭包相关的知识点：

![](https://images.gitbook.cn/9a14e8e0-4ecb-11e9-8044-3de24c2bc492)

接下来将通过两课的内容来学习这个主题。

### 基本知识

#### 作用域

作用域其实就是一套规则：这个规则 **用于确定在特定场景下如何查找变量**
。任何语言都有作用域的概念，同一种语言在演进过程中也会不断完善其作用域规则。比如，在 JavaScript 中，ES6
出现之前只有函数作用域和全局作用域之分。

##### 函数作用域和全局作用域

大家应该非常熟悉 **函数作用域** 了：

    
    
    function foo() {
        var a = 'bar'
        console.log(a)
    }
    foo()
    

执行 `foo` 函数时，变量 `a` 在函数 `foo` 作用域内，函数体内可以正常访问，并输出 `bar`。

而当：

    
    
    var b = 'bar'
    function foo() {
        console.log(b)
    }
    foo()
    

执行这段代码时，`foo` 函数在自身函数作用域内并未查找到 `b` 变量，但是它会继续向外扩大查找范围，因此可以在 **全局作用域** 中找到变量
`b`，输出 `bar`。

如果我们稍加改动：

    
    
    function bar() {
        var b = 'bar'
    }
    function foo() {
        console.log(b)
    }
    foo()
    

执行这段代码时，`foo` 和 `bar` **分属于两个彼此独立的函数作用域** ，`foo` 函数无法访问 `bar` 函数中定义的变量
`b`，且其作用域链内（上层全局作用域中）也不存在相应的变量，因此报错：Uncaught ReferenceError: b is not defined。

* * *

**总结一下** ：在 JavaScript
执行一段函数时，遇见变量读取其值，这时候会“就近”先在函数内部找该变量的声明或者赋值情况。这里涉及“变量声明方式”以及“变量提升”的知识点，我们后面会涉及到。如果在函数内无法找到该变量，就要跳出函数作用域，到更上层作用域中查找。这里的“更上层作用域”可能也是一个函数作用域，例如：

    
    
    function bar() {
        var b = 'bar'
        function foo() {
            console.log(b)
        }
        foo()
    }
    
    bar()
    

在 `foo` 函数执行时，对于变量 `b` 的声明或读值情况是在其上层函数 `bar` 作用域中获取的。

同时“更上层作用域”也可以顺着作用域范围向外扩散，一直找到全局作用域：

    
    
    var b = 'bar'
    function bar() {
        function foo() {
            console.log(b)
        }
        foo()
    }
    
    bar()
    

我们看到，变量作用域的查找是一个扩散过程，就像各个环节相扣的链条，逐次递进，这就是 **作用域链** 说法的由来。

* * *

##### **块级作用域和暂时性死区**

作用域概念不断演进，ES6 增加了 `let` 和 `const` 声明变量的块级作用域，使得 JavaScript
中作用域范围更加丰富。块级作用域，顾名思义，作用域范围限制在代码块中，这个概念在其他语言里也普遍存在。当然这些新特性的添加，也增加了一定的复杂度，带来了新的概念，比如
**暂时性死区** 。这里有必要稍作展开：说到暂时性死区，还需要从“变量提升”说起，参看以下代码：

    
    
    function foo() {
        console.log(bar)
        var bar = 3
    }
    foo()
    

会输出：`undefined`，原因是变量 `bar` 在函数内进行了提升。相当于：

    
    
    function foo() {
        var bar 
        console.log(bar)
        bar = 3
    }
    foo()
    

但在使用 `let` 声明时：

    
    
    function foo() {
        console.log(bar)
        let bar = 3
    }
    foo()
    

会报错：Uncaught ReferenceError: bar is not defined。

我们知道使用 `let` 或 `const` 声明变量，会针对这个变量形成一个封闭的块级作用域，
**在这个块级作用域当中，如果在声明变量前访问该变量，就会报`referenceError` 错误** ；如果在声明变量后访问，则可以正常获取变量值：

    
    
    function foo() {
        let bar = 3
        console.log(bar)
    }
    foo()
    

正常输出 3。因此在相应花括号形成的作用域中，存在一个“死区”，起始于函数开头，终止于相关变量声明的一行。在这个范围内无法访问 `let` 或
`const` 声明的变量。这个“死区”的专业名称为： TDZ（Temporal Dead Zone），相关语言规范的介绍读者可参考
[ECMAScript® 2015 Language Specification](http://www.ecma-
international.org/ecma-262/6.0/#sec-let-and-const-declarations)
，喜欢刨根问底看规范的读者可以了解一下。

参考下面图示，我们加深理解：

![](https://images.gitbook.cn/617c4d80-7058-11e9-b226-3db9572e587e)

除了自身作用域内的 `foo3` 以外，`bar2` 函数可以访问 `foo2`、 `foo1`；但是 `bar1` 函数却无法访问 `bar2`
函数内定义的 `foo3`。

![](https://images.gitbook.cn/7de2a870-7058-11e9-aa97-037c54aa61de)

再啰嗦一遍，`bar1` 函数 `let foo3 = 'foo3'` 代码执行前，为“死区”，访问变量 `foo3` 会报错；该行后即可正常访问。

注意我在上图中勾出的暂时性死区区域，这里介绍一个比较“极端”的情况：函数的参数默认值设置也会受到 TDZ 的影响：

    
    
    function foo(arg1 = arg2, arg2) {
        console.log(`${arg1} ${arg2}`)
    }
    

在上面 `foo` 函数中，如果第一个参数没有传，将会使用第二个参数作为第一个实参值。调用：

    
    
    function foo(arg1 = arg2, arg2) {
        console.log(`${arg1} ${arg2}`)
    }
    
    foo('arg1', 'arg2')
    // 返回：arg1 arg2
    

返回内容正常，但是当第一个参数缺省时，执行 `arg1 = arg2` 会当作暂时性死区处理：

    
    
    function foo(arg1 = arg2, arg2) {
        console.log(`${arg1} ${arg2}`)
    }
    
    foo(undefined, 'arg2')
    
    // Uncaught ReferenceError: arg2 is not defined
    

因为除了块级作用域以外，函数参数默认值也会受到 TDZ 影响。

这里我再“抖个机灵”，看看下面的代码会输出什么？

    
    
    function foo(arg1 = arg2, arg2) {
        console.log(`${arg1} ${arg2}`)
    }
    
    foo(null, 'arg2')
    

输出：`null arg2`，这就涉及到 `undefined` 和 `null` 的区别了。在执行 `foo(null, 'arg2')`
时，不会认为“函数第一个参数缺省”，而会直接接受 `null` 作为第一个参数值。

这个知识点已经不是本课的主题了，具体 `undefined` 和 `null` 的区别我们会在后续课程中提到。

既然“已经偏题”，那我索性再分析一个场景，顺便引出下面的知识点：

    
    
    function foo(arg1) {
        let arg1
    }
    
    foo('arg1')
    

猜猜将会输出什么？

实际上会报错：Uncaught SyntaxError: Identifier 'arg1' has already been declared。这同样跟
TDZ 没有关系，而是因为函数参数名会出现在其“执行上下文/作用域”当中。

在函数的第一行，便已经声明了 `arg1` 这个变量，函数体再用 `let` 声明，会报错（这是 `let` 声明变量的特点，ES6
基础内容，不再展开），类似：

    
    
    function foo(arg1) {
        var arg1
        let arg1
    }
    

请看示意图：

![](https://images.gitbook.cn/99914c20-7058-11e9-aa97-037c54aa61de)

上面我提到了“执行上下文”，我们再看看它究竟是什么。

#### 执行上下文和调用栈

很多读者可能无法准确定义执行上下文和调用栈，其实，从我们接触 JavaScript
开始，这两个概念便常伴左右。我们写出的每一行代码，每一个函数都和它们息息相关，但它们却是“隐形”的，藏在代码背后，出现在 JavaScript
引擎里。这一小节，我们来剖析一下这两个熟悉但又经常被忽视的概念。

**执行上下文**
就是当前代码的执行环境/作用域，和前文介绍的作用域链相辅相成，但又是完全不同的两个概念。直观上看，执行上下文包含了作用域链，同时它们又像是一条河的上下游：有了作用域链，才有了执行上下文的一部分。

##### **代码执行的两个阶段**

理解这两个概念，要从 JavaScript 代码的执行过程说起，这在平时开发中并不会涉及，但对于我们理解 JavaScript
语言和运行机制非常重要，请各位细心阅读。 **JavaScript 执行主要分为两个阶段：**

  * 代码预编译阶段
  * 代码执行阶段

**预编译阶段是前置阶段，这个时候由编译器将 JavaScript 代码编译成可执行的代码。**
注意，这里的预编译和传统的编译并不一样，传统的编译非常复杂，涉及分词、解析、代码生成等过程 。这里的预编译是 JavaScript 中独特的概念，虽然
JavaScript 是解释型语言，编译一行，执行一行。但是在代码执行前，JavaScript 引擎确实会做一些“预先准备工作”。

**执行阶段主要任务是执行代码，执行上下文在这个阶段全部创建完成。**

在通过语法分析，确认语法无误之后，JavaScript 代码在预编译阶段对变量的内存空间进行分配，我们熟悉的变量提升过程便是在此阶段完成的。如下代码：

经过预编译过程，我们应该注意三点：

  * 预编译阶段进行变量声明；
  * 预编译阶段变量声明进行提升，但是值为 undefined；
  * 预编译阶段所有非表达式的函数声明进行提升。

请看下面这道题目：

    
    
    function bar() {
        console.log('bar1')
    }
    
    var bar = function () {
        console.log('bar2')
    }
    
    bar()
    

输出：bar2，我们调换顺序：

    
    
    var bar = function () {
        console.log('bar2')
    }
    
    function bar() {
        console.log('bar1')
    }
    
    bar()
    

仍然输出：`bar2`，因为在预编译阶段变量 `bar` 进行声明，但是不会赋值；函数 `bar` 则进行创建并提升。在代码执行时，变量 `bar`
才进行（表达式）赋值，值内容是函数体为 `console.log('bar2')` 的函数，输出结果 `bar2`。

请再思考这道题：

    
    
    foo(10)
    function foo (num) {
        console.log(foo)
        foo = num;       
        console.log(foo)
        var foo
    } 
    console.log(foo)
    foo = 1
    console.log(foo)
    

输出：

    
    
    undefined
    10
    ƒ foo (num) {
        console.log(foo)
        foo = num     
        console.log(foo)
        var foo
    }
    1
    

在 `foo(10)` 执行时，函数体内进行变量提升后，函数体内第一行输出 `undefined`，函数体内第三行输出 `foo`。接着运行代码，到了整体第
8 行，`console.log(foo)` 输出 foo 函数内容（因为 foo 函数内的 `foo = num`，将 num 赋值给的是函数作用域内的
foo 变量。）

**结论**
作用域在预编译阶段确定，但是作用域链是在执行上下文的创建阶段完全生成的。因为函数在调用时，才会开始创建对应的执行上下文。执行上下文包括了：变量对象、作用域链以及
`this` 的指向

如图所示：

![](https://images.gitbook.cn/d60a9530-4eac-11e9-b1fa-0757868d211c)

代码执行的整个过程说起来就像 **一条生产流水线** 。第一道工序是在预编译阶段创建 **变量对象** （Variable
Object），此时只是创建，而未赋值。到了下一道工序代码执行阶段，变量对象转为 **激活对象** （Active Object），即完成 VO →
AO。此时，作用域链也将被确定，它由当前执行环境的变量对象和所有外层已经完成的激活对象组成。这道工序保证了变量和函数的有序访问，即如果当前作用域中未找到变量，则继续向上查找直到全局作用域。

这样的工序在流水线上串成一个整体，这便是 JavaScript 引擎执行机制的最基本道理。

##### 调用栈

了解了上面的内容，函数调用栈便很好理解了。我们在执行一个函数时，如果这个函数又调用了另外一个函数，而这个“另外一个函数”也调用了“另外一个函数”，便形成了一系列的调用栈。如下代码：

    
    
    function foo1() {
      foo2()
    }
    function foo2() {
      foo3()
    }
    function foo3() {
      foo4()
    }
    function foo4() {
      console.log('foo4')
    }
    foo1()
    

调用关系：`foo1` → `foo2` → `foo3` → `foo4`。这个过程是 `foo1` 先入栈，紧接着 `foo1` 调用
`foo2`，`foo2`入栈，以此类推，`foo3`、`foo4`，直到 `foo4` 执行完 —— `foo4` 先出栈，`foo3` 再出栈，接着是
`foo2` 出栈，最后是 `foo1` 出栈。这个过程“先进后出”（“后进先出”），因此称为 **调用栈** 。

我们故意将 `foo4` 中的代码写错：

    
    
    function foo1() {
      foo2()
    }
    function foo2() {
      foo3()
    }
    function foo3() {
      foo4()
    }
    function foo4() {
      console.lg('foo4')
    }
    foo1()
    

得到错误提示如图：

![](https://images.gitbook.cn/bad699d0-7058-11e9-a7a7-7bb84010ce2f)

或者在 Chrome 中执行代码，打断点得到：

![](https://images.gitbook.cn/d7aa0e70-7058-11e9-b07f-d933a796cd29)

不管哪种方式，我们从中都可以借助 JavaScript 引擎，清晰地看到错误堆栈信息，也就是函数调用栈关系。

**注意**
正常来讲，在函数执行完毕并出栈时，函数内局部变量在下一个垃圾回收节点会被回收，该函数对应的执行上下文将会被销毁，这也正是我们在外界无法访问函数内定义的变量的原因。也就是说，只有在函数执行时，相关函数可以访问该变量，该变量在预编译阶段进行创建，在执行阶段进行激活，在函数执行完毕后，相关上下文被销毁。

#### 闭包

介绍了这么多前置概念，终于到了闭包环节。

闭包并不是 JavaScript
特有的概念，社区上对于闭包的定义也并不完全相同。虽然本质上表达的意思相似，但是晦涩且多样的定义仍然给初学者带来了困惑。我自己认为比较容易理解的闭包定义为：

> 函数嵌套函数时，内层函数引用了外层函数作用域下的变量，并且内层函数在全局环境下可访问，就形成了闭包。

我们看一个简单的代码示例：

    
    
    function numGenerator() {
        let num = 1
        num++
        return () => {
            console.log(num)
        } 
    }
    
    var getNum = numGenerator()
    getNum()
    

这个简单的闭包例子中，`numGenerator` 创建了一个变量 `num`，返回打印 `num` 值的匿名函数，这个函数引用了变量
`num`，使得外部可以通过调用 `getNum` 方法访问到变量 `num`，因此在 `numGenerator` 执行完毕后，即相关调用栈出栈后，变量
`num` 不会消失，仍然有机会被外界访问。

执行代码，能清晰地看到 JavaScript 引擎的分析：

![](https://images.gitbook.cn/f1381c10-7058-11e9-aa97-037c54aa61de)

`num` 值被标记为 Closure，即闭包变量。

对比前述内容，我们知道正常情况下外界是无法访问函数内部变量的，函数执行完之后，上下文即被销毁。但是在（外层）函数中，如果我们返回了另一个函数，且这个返回的函数使用了（外层）函数内的变量，外界因而便能够通过这个返回的函数获取原（外层）函数内部的变量值。这就是闭包的
**基本原理** 。

因此，直观上来看，闭包这个概念为 JavaScript 中访问函数内变量提供了途径和便利。这样做的好处很多，比如我们可以利用闭包实现“模块化”；再比如，翻看
Redux
源码的中间件实现机制，也会发现（函数式理念）大量运用了闭包。这些更加深入的内容我们后续课程都将会涉及。闭包是前端进阶必备基础。后面我们还会通过做题的方式，帮助读者深化理解闭包。

#### 内存管理

内存管理是计算机科学中的概念。不论是什么程序语言，内存管理都是指对内存生命周期的管理，而内存的生命周期无外乎：

  * 分配内存空间
  * 读写内存
  * 释放内存空间

我们用代码来举例：

    
    
    var foo = 'bar' // 在堆内存中给变量分配空间
    alert(foo)  // 使用内存
    foo = null // 释放内存空间
    

##### **内存管理基本概念**

我们知道内存空间可以分为栈空间和堆空间，其中

  * 栈空间：由操作系统自动分配释放，存放函数的参数值，局部变量的值等，其操作方式类似于数据结构中的栈。
  * 堆空间：一般由开发者分配释放，这部分空间就要考虑垃圾回收的问题。

在 JavaScript 中，数据类型包括（未包含 ES Next 新数据类型）：

  * 基本数据类型，如 Undefined、Null、Number、Boolean、String 等
  * 引用类型，如 Object、Array、Function 等

一般情况下，基本数据类型保存在栈内存当中，引用类型保存在堆内存当中。如下代码：

    
    
    var a = 11
    var b = 10
    var c = [1, 2, 3]
    var d = { e: 20 }
    

对应内存分配图示：

![](https://images.gitbook.cn/f1e2f0e0-4ec0-11e9-97d1-9b2c5e38f63d)

**对于分配内存和读写内存的行为所有语言都较为一致，但释放内存空间在不同语言之间有差异。** 例如，JavaScript
依赖宿主浏览器的垃圾回收机制，一般情况下不用程序员操心。但这并不表示万事大吉，某些情况下依然会出现内存泄漏现象。

**内存泄漏**
是指内存空间明明已经不再被使用，但由于某种原因并没有被释放的现象。这是一个非常“玄学”的概念，因为内存空间是否还在使用，某种程度上是不可判定问题，或者判定成本很高。内存泄漏危害却非常直观：它会直接导致程序运行缓慢，甚至崩溃。

##### **内存泄漏场景举例**

我们来看几个典型引起内存泄漏的例子：

    
    
    var element = document.getElementById("element")
    element.mark = "marked"
    
    // 移除 element 节点
    function remove() {
        element.parentNode.removeChild(element)
    }
    

上面的代码，我们只是把 `id` 为 `element` 的节点移除，但是变量 `element` 依然存在，该节点占有的内存无法被释放。

请仔细参考下图：

![](https://images.gitbook.cn/12161c70-7059-11e9-aa97-037c54aa61de)

我们需要在 `remove` 方法中添加：`element = null`，这样更为稳妥。

再来看个示例：

    
    
    var element = document.getElementById('element')
    element.innerHTML = '<button id="button">点击</button>'
    
    var button = document.getElementById('button')
    button.addEventListener('click', function() {
        // ...
    })
    
    element.innerHTML = ''
    

这段代码执行后，因为 element.innerHTML = ''，`button` 元素已经从 DOM
中移除了，但是由于其事件处理句柄还在，所以依然无法被垃圾回收。我们还需要增加 removeEventListener，防止内存泄漏。

另一个示例：

    
    
    function foo() {
      var name  = 'lucas'
      window.setInterval(function() {
        console.log(name)
      }, 1000)
    }
    
    foo()
    

这段代码由于 window.setInterval 的存在，导致 `name` 内存空间始终无法被释放，如果不是业务要求的话，一定要记得在合适的时机使用
`clearInterval` 进行清理。

##### **浏览器垃圾回收**

当然，除了开发者主动保证以外，大部分的场景浏览器都会依靠：

  * 标记清除
  * 引用计数

两种算法来进行主动垃圾回收。内容社区上有很多好文章介绍这方面的内容，我把自己收藏的几篇不错的跟大家分享一下，这些内容偏浏览器引擎实现，这里不再过多介绍，感兴趣的读者可以参考下面内容：

  * [通过垃圾回收机制理解 JavaScript 内存管理](https://juejin.im/post/5c4409fbf265da616f703d5a)
  * [如何处理 JavaScript 内存泄漏](https://mp.weixin.qq.com/s?__biz=MzA5NzkwNDk3MQ==&mid=2650585408&idx=1&sn=4de7b5bbfa969d9587c163e98bc90684&source=41#wechat_redirect)
  * [垃圾回收](https://segmentfault.com/a/1190000003641343)
  * [编写内存友好的代码](https://segmentfault.com/a/1190000007887891)
  * [JavaScript 中 4 种常见的内存泄漏陷阱](https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&mid=2651551451&idx=1&sn=b8447a12eceb467992d432b014d9c026&chksm=8025a11ab752280c7915db4ef726611f645d2fee590d6f0f3f9aeedd55c956454f66f786873a&scene=0#wechat_redirect)
  * [记一次网页内存溢出分析及解决实践](https://juejin.im/post/5c3dce07e51d4551e960d840)

##### **内存泄漏和垃圾回收注意事项**

**关于内存泄漏和垃圾回收，要在实战中分析，不能完全停留在理论层面，毕竟如今浏览器千变万化且一直在演进当中。**
从以上示例我们可以看出，借助闭包来绑定数据变量，可以保护这些数据变量的内存块在闭包存活时，始终不被垃圾回收机制回收。因此，闭包使用不当，极可能引发内存泄漏，需要格外注意。以下代码：

    
    
    function foo() {
        let value = 123
    
        function bar() { alert(value) }
    
        return bar
    }
    
    let bar = foo()
    

这种情况下，变量 value 将会保存在内存中，如果加上：

    
    
    bar = null
    

这样的话，随着 bar 不再被引用，value 也会被清除。

结合浏览器引擎的优化情况，我们对上述代码进行改动：

    
    
    function foo() {
        let value = Math.random()
    
        function bar() {
            debugger
        }
    
        return bar
    }
    
    let bar = foo()
    bar()
    

在 Chrome 浏览器 V8 最新引擎中，执行上述代码。我们在函数 `bar` 中打断点，会发现 `value` 没有被引用，如下图：

![](https://images.gitbook.cn/2f8fe330-7059-11e9-aa97-037c54aa61de)

而我们在 `bar` 函数中加入对 `value` 的引用：

    
    
    function foo() {
        let value = Math.random()
    
        function bar() {
            console.log(value)
            debugger
        }
    
        return bar
    }
    
    let bar = foo()
    bar()
    

会发现此时引擎中存在闭包变量 value 值。如下图：

![](https://images.gitbook.cn/49413040-7059-11e9-b07f-d933a796cd29)

下面我们来看一个实战，借助 Chrome devtool，排查发现内存泄漏的场景。

代码：

    
    
    var array = []
    function createNodes() {
        let div
        let i = 100
        let frag = document.createDocumentFragment()
        for (; i > 0; i--) {
            div = document.createElement("div")
            div.appendChild(document.createTextNode(i))
            frag.appendChild(div)
        }
        document.body.appendChild(frag)
    }
    function badCode() { 
        array.push([...Array(100000).keys()])
        createNodes()
        setTimeout(badCode, 1000)
    }
    
    badCode()
    

我们递归调用 `badCode`，这个函数每次向 `array` 数组中写入新的由 100000 项从 0 到 1 组成的新数组，在 `badCode`
函数使用完全局变量 `array` 之后，并没有手动释放内存，垃圾回收不会处理 `array`，导致内存泄漏；同时，`badCode` 函数调用
`createNodes` 函数，每 1s 创建 100 个 div 节点。

这时候，打开 Chrome devtool，我们选中 performance 标签，拍下快照得到：

![](https://images.gitbook.cn/5f72f380-7059-11e9-a7a7-7bb84010ce2f)

由此可以发现，JS heap（蓝线）和
Nodes（绿线）线，随着时间线一直在上升，并没有被垃圾回收。因此，可以判定存在较大的内存泄漏风险。如果我们不知道有问题的代码位置，具体如何找出风险点，那需要在
Chrome memory 标签中，对 JS heap 中每一项，尤其是 size 较大的前几项展开调查。如图：

![](https://images.gitbook.cn/7d4dc600-7059-11e9-aa97-037c54aa61de)

![](https://images.gitbook.cn/93dceb80-7059-11e9-aa97-037c54aa61de)

明显就是我们定义的 `array` 不对劲了。

这一节我们分析了涉及闭包知识的基础概念，介绍了内存管理和垃圾回收相关机制。下一节我们将集中学习代码示例，加强理解。

### 分享交流

请大家留言分享自己开发实践中遇到的 「闭包」相关 bug，也可以先学完下一课的示例再来分享。阅读文章过程中有任何疑问随时可以跟其他小伙伴讨论，或者直接向作者
LucasHC 提问。 **你的分享不仅帮助他人，更会提升自己。**

> 由于作者是兼职写作，平时也要上班，向作者问问题时，回复不及时，请谅解。建议大家在群里互相沟通、讨论~

也欢迎大家说说自己最想了解的主题，课程内容会根据部分读者的意见和建议迭代和完善。

> **为了方便与作者交流与学习，GitChat
编辑团队组织了一个《前端开发核心知识进阶》读者交流群，添加编辑小姐姐微信：「GitChatty5」，回复关键字「105」给编辑小姐姐获取入群资格。**



## 老司机也会在闭包相关知识点翻车（下）

有了上一课的理论知识，这一课我们来分析例题。

我们再次列出「闭包」主题的知识点：

![](https://images.gitbook.cn/9a14e8e0-4ecb-11e9-8044-3de24c2bc492)

### 例题分析

接下来，我们通过几道题目来加深理解闭包。

#### 实战例题 1：求下面代码的输出

    
    
    const foo = (function() {
        var v = 0
        return () => {
            return v++
        }
    }())
    
    for (let i = 0; i < 10; i++) {
        foo()
    }
    
    console.log(foo())
    

答案：10

##### **例题 1 分析**

`foo` 是一个立即执行函数，我们尝试打印 `foo`：

    
    
    const foo = (function() {
        var v = 0
        return () => {
            return v++
        }
    }())
    
    console.log(foo)
    

输出：

    
    
    () => {
        return v++
    }
    

在循环执行时，执行 `foo()`，这样引用自由变量 10 次，`v` 自增 10 次，最后执行 `foo` 时，得到
10。（自由变量是指没有在相关函数作用域中声明，但是使用了的变量。）

#### 实战例题 2：求下面代码的输出

    
    
    const foo = () => {
        var arr = []
        var i
    
        for (i = 0; i < 10; i++) {
            arr[i] = function () {
                console.log(i)
            }
        }
    
        return arr[0]
    }
    
    foo()()
    

答案：10，这时自由变量为 `i`，分析类似例题 1：`foo()` 执行返回的是 `arr[0]`, `arr[0]` 此时是函数：

    
    
    function () {
        console.log(i)
    }
    

变量 `i` 值为 10。

#### 实战例题 3：求下面代码的输出

    
    
    var fn = null
    const foo = () => {
        var a = 2
        function innerFoo() { 
            console.log(a)
        }
        fn = innerFoo    
    }
    
    const bar = () => {
        fn()
    }
    
    foo()
    bar()
    

答案：2

##### **例题 3 分析**

正常来讲，根据调用栈的知识，`foo` 函数执行完毕之后，其执行环境生命周期会结束，所占内存被垃圾收集器释放，上下文消失。但是通过 `innerFoo`
函数赋值给 `fn`，`fn` 是全局变量，这就导致了 `foo` 的变量对象 `a` 也被保留了下来。所以函数 `fn` 在函数 `bar`
内部执行时，依然可以访问这个被保留下来的变量对象，输出结果为 `2`。

#### 实战例题 4：求下面代码的输出

我们将上面的例子稍作修改：

    
    
    var fn = null
    const foo = () => {
        var a = 2
        function innerFoo() { 
            console.log(c)            
            console.log(a)
        }
        fn = innerFoo
    }
    
    const bar = () => {
        var c = 100
        fn()    
    }
    
    foo()
    bar()
    

执行结果：报错。

##### **例题 4 分析**

在 `bar` 中执行 `fn()` 时，`fn()` 已经被复制为 `innerFoo`，变量 `c` 并不在其作用域链上，`c` 只是 `bar`
函数的内部变量。因此报错 ReferenceError: c is not defined。

图示分析：

![](https://images.gitbook.cn/ec72e540-713c-11e9-8a6f-8918e834f023)

#### 思考例题 5：如何利用闭包实现单例模式

单例模式，是一种常用的软件设计模式。GoF 在《设计模式：可复用面向对象软件的基础》一书中给出了如下定义：

> Ensure a class only has one instance, and provide a global point of access
to it.

>

> 保证一个类只有一个实例，并提供一个访问它的全局访问点。

使用闭包我们可以保持对实例的引用，不被垃圾回收机制回收，因此：

    
    
    function Person() {
        this.name = 'lucas'
    }
    
    const getSingleInstance = (function(){
         var singleInstance
        return function() {
             if (singleInstance) {
                return singleInstance
             } 
            return singleInstance = new Person()
        }
    })()
    
    const instance1 = new getSingleInstance()
    const instance2 = new getSingleInstance()
    

事实上，我们有 instance1 === instance2。因为借助闭包变量 singleInstance，instance1 和 instance2
是同一引用的（singleInstance），这正是单例模式的体现。

### 总结

本课我们通过介绍理论知识加例题实战的方式梳理了 JavaScript 中闭包、内存、执行上下文、作用域、作用域链等概念。

这些内容说基础，确实不算很难；说复杂，它绝对又能衍生出很多知识点。这些知识点不是 JavaScript
所特有的，但是在前端开发中又极具自身语言风格。它绝不只是纯理论概念，只有解决真实的开发问题才有实际意义。

一个合格的高级前端工程师需要做的并不是如数家珍地背诵“闭包和 GC
原理”，而是根据面临的场景，凭借扎实的基础，能够通过查阅资料，提升应用性能，分析内存事故和突破瓶颈。

### 分享交流

请大家留言分享自己开发实践中遇到的 「闭包」相关的难忘 bug。阅读文章过程中有任何疑问随时可以跟其他小伙伴讨论，或者直接向作者 LucasHC 提问。
**你的分享不仅帮助他人，更会提升自己。**

> 由于作者是兼职写作，平时也要上班，向作者问问题时，回复不及时，请谅解。建议大家在群里互相沟通、讨论~

你也可以说说自己最想了解的主题，课程内容会根据部分读者的意见和建议迭代和完善。

此外，我们为本课程付费读者创建了《前端开发核心知识进阶》微信交流群，以方便更有针对性地讨论课程相关问题。（入群请到第1-2课末尾添加 GitChat
小助手伽利略的微信，并注明「前端核心」。）

> 温馨提示：需购买才可入群哦，加小助手后需要截已购买的图来验证~



## 我们不背诵 API，只实现 API

有不少刚入行的同学跟我说：“JavaScript 很多 API 记不清楚怎么办？数组的这方法、那方法总是傻傻分不清楚，该如何是好？操作 DOM
的方式今天记、明天忘，真让人奔溃！”甚至有的开发者在讨论面试时，总向我抱怨：“面试官总爱纠结 API 的使用，甚至 jQuery
某些方法的参数顺序都需要让我说清楚！”

我认为，对于反复使用的方法，所有人都要做到“机械记忆”，能够反手写出。一些貌似永远记不清的 API 只是因为用得不够多而已。

在做面试官时，我从来不强求开发者准确无误地“背诵” API。相反，我喜欢从另外一个角度来考察面试者：“
**既然记不清使用方法，那么我告诉你它的使用方法，你来实现一个吧！** ”实现一个 API，除了可以考察面试者对这个 API
的理解，更能体现开发者的编程思维和代码能力。对于积极上进的前端工程师，模仿并实现一些经典方法，应该是“家常便饭”，这是比较基本的要求。

**本小节，我根据了解的面试题目和作为面试官的经历，挑了几个典型的 API，通过对其不同程度，不同方式的实现，来覆盖 JavaScript
中的部分知识点和编程要领** 。通过学习本节内容，期待你不仅能领会代码奥义，更应该学习举一反三的方法。

API 主题的相关知识点如下：

![](https://images.gitbook.cn/331cceb0-4ed4-11e9-8044-3de24c2bc492)

### jQuery offset 实现

> 这个话题演变自今日头条某部门面试题。当时面试官提问：“如何获取文档中任意一个元素距离文档 `document` 顶部的距离？”

熟悉 jQuery 的读者应该对 `offset`
方法并不陌生，它返回或设置匹配元素相对于文档的偏移（位置）。这个方法返回的对象包含两个整型属性：`top` 和 `left`，以像素计。如果可以使用
jQuery， 我们可以直接调取该 API 获得结果。但是， **如果用原生 JavaScript 实现，也就是说手动实现 jQuery`offset`
方法，该如何着手呢？**

主要有两种思路：

  * 通过递归实现
  * 通过 `getBoundingClientRect` API 实现

#### 递归实现方案

我们通过遍历目标元素、目标元素的父节点、父节点的父节点......依次溯源，并累加这些遍历过的节点相对于其最近祖先节点（且 `position` 属性非
`static`）的偏移量，向上直到 `document`，累加即可得到结果。

其中，我们需要使用 JavaScript 的 `offsetTop` 来访问一个 DOM 节点上边框相对离其本身最近、且 `position` 值为非
`static` 的祖先元素的垂直偏移量。具体实现为：

    
    
    const offset = ele => {
        let result = {
            top: 0,
            left: 0
        }
    
    const getOffset = (node, init) => {
            if (node.nodeType !== 1) {
                return
            }
    
            position = window.getComputedStyle(node)['position']
    
            if (typeof(init) === 'undefined' && position === 'static') {
                getOffset(node.parentNode)
                return
            }
    
            result.top = node.offsetTop + result.top - node.scrollTop
            result.left = node.offsetLeft + result.left - node.scrollLeft
    
            if (position === 'fixed') {
                return
            }
    
            getOffset(node.parentNode)
        }
    
        // 当前 DOM 节点的 display === 'none' 时, 直接返回 {top: 0, left: 0}
        if (window.getComputedStyle(ele)['display'] === 'none') {
            return result
        }
    
        let position
    
        getOffset(ele, true)
    
        return result
    
    }
    

上述代码并不难理解，使用递归实现。如果节点 `node.nodeType` 类型不是 `Element(1)`，则跳出；如果相关节点的 `position`
属性为 `static`，则不计入计算，进入下一个节点（其父节点）的递归。如果相关属性的 `display` 属性为 `none`，则应该直接返回 0
作为结果。

这个实现很好地考察了开发者对于递归的初级应用、以及对 JavaScript 方法的掌握程度。

接下来，我们换一种思路，用一个相对较新的 API： `getBoundingClientRect` 来实现 jQuery `offset` 方法。

#### getBoundingClientRect 方法

`getBoundingClientRect`
方法用来描述一个元素的具体位置，该位置的下面四个属性都是相对于视口左上角的位置而言的。对某一节点执行该方法，它的返回值是一个
[DOMRect](https://developer.mozilla.org/zh-
CN/docs/Mozilla/Tech/XPCOM/Reference/Interface/nsIDOMClientRect)
类型的对象。这个对象表示一个矩形盒子，它含有：`left`、`top`、`right` 和 `bottom` 等只读属性。

![](https://images.gitbook.cn/db68ca10-4eac-11e9-b1fa-0757868d211c)

请参考实现代码：

    
    
    const offset = ele => {
        let result = {
            top: 0,
            left: 0
        }
        // 当前为 IE11 以下，直接返回 {top: 0, left: 0}
        if (!ele.getClientRects().length) {
            return result
        }
    
        // 当前 DOM 节点的 display === 'none' 时，直接返回 {top: 0, left: 0}
        if (window.getComputedStyle(ele)['display'] === 'none') {
            return result
        }
    
        result = ele.getBoundingClientRect()
        var docElement = ele.ownerDocument.documentElement
    
        return {
            top: result.top + window.pageYOffset - docElement.clientTop,
            left: result.left + window.pageXOffset - docElement.clientLeft
        }
    }
    

**需要注意的细节有：**

  * `node.ownerDocument.documentElement` 的用法可能大家比较陌生，`ownerDocument` 是 DOM 节点的一个属性，它返回当前节点的顶层的 `document` 对象。`ownerDocument` 是文档，`documentElement` 是根节点。事实上，`ownerDocument` 下含 2 个节点：

  * `<!DocType>`

  * `documentElement`

`docElement.clientTop`，`clientTop` 是一个元素顶部边框的宽度，不包括顶部外边距或内边距。

  * 除此之外，该方法实现就是简单的几何运算，边界 case 和兼容性处理，也并不难理解。

从这道题目看出，相比考察“死记硬背”
API，这样的实现更有意义。站在面试官的角度，我往往会给面试者（开发者）提供相关的方法提示，以引导其给出最后的方案实现。

### 数组 reduce 方法的相关实现

数组方法非常重要： **因为数组就是数据，数据就是状态，状态反应着视图** 。对数组的操作我们不能陌生，其中 `reduce`
方法更要做到驾轻就熟。我认为这个方法很好地体现了“函数式”理念，也是当前非常热门的考察点之一。

我们知道 `reduce` 方法是 ES5 引入的，reduce 英文解释翻译过来为“减少，缩小，使还原，使变弱”，MDN 对该方法直述为：

> The reduce method applies a function against an accumulator and each value
of the array (from left-to-right) to reduce it to a single value.

它的使用语法：

    
    
    arr.reduce(callback[, initialValue])
    

这里我们简要介绍一下。

  * `reduce` 第一个参数 `callback` 是核心，它对数组的每一项进行“叠加加工”，其最后一次返回值将作为 `reduce` 方法的最终返回值。 它包含 4 个参数：
  * `previousValue` 表示“上一次” `callback` 函数的返回值
  * `currentValue` 数组遍历中正在处理的元素
  * `currentIndex` 可选，表示 `currentValue` 在数组中对应的索引。如果提供了 `initialValue`，则起始索引号为 0，否则为 1
  * `array` 可选，调用 `reduce()` 的数组
  * `initialValue` 可选，作为第一次调用 `callback` 时的第一个参数。如果没有提供 `initialValue`，那么数组中的第一个元素将作为 `callback` 的第一个参数。

#### reduce 实现 runPromiseInSequence

我们看它的 **一个典型应用** ，按顺序运行 Promise：

    
    
    const runPromiseInSequence = (array, value) => array.reduce(
        (promiseChain, currentFunction) => promiseChain.then(currentFunction),
        Promise.resolve(value)
    )
    

`runPromiseInSequence` 方法将会被一个每一项都返回一个 Promise 的数组调用，并且依次执行数组中的每一个
Promise，请读者仔细体会。如果觉得晦涩，可以参考示例：

    
    
    const f1 = () => new Promise((resolve, reject) => {
        setTimeout(() => {
            console.log('p1 running')
            resolve(1)
        }, 1000)
    })
    
    const f2 = () => new Promise((resolve, reject) => {
        setTimeout(() => {
            console.log('p2 running')
            resolve(2)
        }, 1000)
    })
    
    const array = [f1, f2]
    
    const runPromiseInSequence = (array, value) => array.reduce(
        (promiseChain, currentFunction) => promiseChain.then(currentFunction),
        Promise.resolve(value)
    )
    
    runPromiseInSequence(array, 'init')
    

执行结果如下图：

![](https://images.gitbook.cn/d3e0d510-74c4-11e9-9e0d-e1101fcb8c7e)

#### reduce 实现 pipe

`reduce` 的另外一个 **典型应用** 可以参考函数式方法 `pipe` 的实现：`pipe(f, g, h)` 是一个 curry
化函数，它返回一个新的函数，这个新的函数将会完成 `(...args) => h(g(f(...args)))` 的调用。即 `pipe`
方法返回的函数会接收一个参数，这个参数传递给 `pipe` 方法第一个参数，以供其调用。

    
    
    const pipe = (...functions) => input => functions.reduce(
        (acc, fn) => fn(acc),
        input
    )
    

仔细体会 `runPromiseInSequence` 和 `pipe` 这两个方法，它们都是 `reduce` 应用的典型场景。

#### 实现一个 reduce

那么我们该如何实现一个 `reduce` 呢？参考来自 MDN 的 polyfill：

    
    
    if (!Array.prototype.reduce) {
      Object.defineProperty(Array.prototype, 'reduce', {
        value: function(callback /*, initialValue*/) {
          if (this === null) {
            throw new TypeError( 'Array.prototype.reduce ' + 
              'called on null or undefined' )
          }
          if (typeof callback !== 'function') {
            throw new TypeError( callback +
              ' is not a function')
          }
    
          var o = Object(this)
    
          var len = o.length >>> 0
    
          var k = 0
          var value
    
          if (arguments.length >= 2) {
            value = arguments[1]
          } else {
            while (k < len && !(k in o)) {
              k++
            }
    
            if (k >= len) {
              throw new TypeError( 'Reduce of empty array ' +
                'with no initial value' )
            }
            value = o[k++]
          }
    
          while (k < len) {
            if (k in o) {
              value = callback(value, o[k], k, o)
            }
    
            k++
          }
    
          return value
        }
      })
    }
    

上述代码中使用了 `value` 作为初始值，并通过 `while` 循环，依次累加计算出 `value` 结果并输出。但是相比 MDN
上述实现，我个人更喜欢的实现方案是：

    
    
    Array.prototype.reduce = Array.prototype.reduce || function(func, initialValue) {
        var arr = this
        var base = typeof initialValue === 'undefined' ? arr[0] : initialValue
        var startPoint = typeof initialValue === 'undefined' ? 1 : 0
        arr.slice(startPoint)
            .forEach(function(val, index) {
                base = func(base, val, index + startPoint, arr)
            })
        return base
    }
    

核心原理就是使用 `forEach` 来代替 `while` 实现结果的累加，它们本质上是相同的。

我也同样看了下 ES5-shim 里的 pollyfill，跟上述思路完全一致。唯一的区别在于：我用了 `forEach` 迭代而 ES5-shim
使用的是简单的 `for` 循环。实际上，如果“杠精”一些，我们会指出数组的 `forEach` 方法也是 ES5 新增的。因此，用 ES5 的一个
API（`forEach`），去实现另外一个 ES5 的 API（`reduce`），这并没什么实际意义——这里的 pollyfill 就是在不兼容 ES5
的情况下，模拟的降级方案。此处不多做追究，因为根本目的还是希望读者对 `reduce` 有一个全面透彻的了解。

#### 通过 Koa only 模块源码认识 reduce

通过了解并实现 `reduce` 方法，我们对它已经有了比较深入的认识。最后，再来看一个 `reduce` 使用示例——通过 Koa 源码的
[only](https://www.npmjs.com/package/only) 模块，加深印象：

    
    
    var o = {
        a: 'a',
        b: 'b',
        c: 'c'
    }
    only(o, ['a','b'])   // {a: 'a',  b: 'b'}
    

该方法返回一个经过指定筛选属性的新对象。 ​  
only 模块实现：

    
    
    var only = function(obj, keys){
        obj = obj || {}
        if ('string' == typeof keys) keys = keys.split(/ +/)
        return keys.reduce(function(ret, key) {
            if (null == obj[key]) return ret
            ret[key] = obj[key]
            return ret
        }, {})
    }
    

小小的 `reduce` 及其衍生场景有很多值得我们玩味、探究的地方。举一反三，活学活用是技术进阶的关键。

### compose 实现的几种方案

函数式理念——这一古老的概念如今在前端领域“遍地开花”。函数式很多思想都值得借鉴，其中一个细节：compose
因为其巧妙的设计而被广泛运用。对于它的实现，从面向过程式到函数式实现，风格迥异，值得我们探究。在面试当中，也经常有面试官要求实现 `compose`
方法，我们先看什么是 `compose`。

`compose` 其实和前面提到的 `pipe` 一样，就是执行一连串不定长度的任务（方法），比如：

    
    
    let funcs = [fn1, fn2, fn3, fn4]
    let composeFunc = compose(...funcs)
    

执行：

    
    
    composeFunc(args)
    

就相当于：

    
    
    fn1(fn2(fn3(fn4(args))))
    

总结一下 `compose` 方法的关键点：

  * `compose` 的参数是函数数组，返回的也是一个函数
  * `compose` 的参数是任意长度的，所有的参数都是函数，执行方向是自右向左的，因此初始函数一定放到参数的最右面
  * `compose` 执行后返回的函数可以接收参数，这个参数将作为初始函数的参数，所以初始函数的参数是多元的，初始函数的返回结果将作为下一个函数的参数，以此类推。因此除了初始函数之外，其他函数的接收值是一元的

我们发现，实际上，`compose` 和 `pipe` 的差别只在于调用顺序的不同：

    
    
    // compose
    fn1(fn2(fn3(fn4(args))))
    
    // pipe
    fn4(fn3(fn2(fn1(args))))
    

即然跟我们先前实现的 `pipe` 方法如出一辙，那么还有什么好深入分析的呢？请继续阅读，看看还能玩出什么花儿来。

`compose` 最简单的实现是面向过程的：

    
    
    const compose = function(...args) {
        let length = args.length
        let count = length - 1
        let result
        return function f1 (...arg1) {
            result = args[count].apply(this, arg1)
            if (count <= 0) {
                count = length - 1
                return result
            }
            count--
            return f1.call(null, result)
        }
    }
    

这里的关键是用到了 **闭包** ，使用闭包变量储存结果 `result`
和函数数组长度以及遍历索引，并利用递归思想，进行结果的累加计算。整体实现符合正常的面向过程思维，不难理解。

聪明的读者可能也会意识到，利用上文所讲的 `reduce` 方法，应该能更 **函数式** 地解决问题：

    
    
    const reduceFunc = (f, g) => (...arg) => g.call(this, f.apply(this, arg))
    const compose = (...args) => args.reverse().reduce(reduceFunc, args.shift())
    

通过前面的学习，结合 `call`、`apply` 方法，这样的实现并不难理解。

**我们继续开拓思路，“既然涉及串联和流程控制”，那么还可以使用 Promise 实现：**

    
    
    const compose = (...args) => {
        let init = args.pop()
        return (...arg) => 
        args.reverse().reduce((sequence, func) => 
          sequence.then(result => func.call(null, result))
        , Promise.resolve(init.apply(null, arg)))
    }
    

这种实现利用了 Promise 特性：首先通过 `Promise.resolve(init.apply(null, arg))` 启动逻辑，启动一个
`resolve` 值为最后一个函数接收参数后的返回值，依次执行函数。因为 `promise.then()` 仍然返回一个 Promise 类型值，所以
`reduce` 完全可以按照 Promise 实例执行下去。

既然能够使用 Promise 实现，那么 **generator**
当然应该也可以实现。这里给大家留一个思考题，感兴趣的读者可以尝试，欢迎在评论区或读者群讨论。

最后，我们再看下社区上著名的 lodash 和 Redux 的实现。

**lodash 版本**

    
    
    // lodash 版本
    var compose = function(funcs) {
        var length = funcs.length
        var index = length
        while (index--) {
            if (typeof funcs[index] !== 'function') {
                throw new TypeError('Expected a function');
            }
        }
        return function(...args) {
            var index = 0
            var result = length ? funcs.reverse()[index].apply(this, args) : args[0]
            while (++index < length) {
                result = funcs[index].call(this, result)
            }
            return result
        }
    }
    

lodash 版本更像我们的第一种实现方式，理解起来也更容易。

**Redux 版本**

    
    
    // Redux 版本
    function compose(...funcs) {
        if (funcs.length === 0) {
            return arg => arg
        }
    
        if (funcs.length === 1) {
            return funcs[0]
        }
    
        return funcs.reduce((a, b) => (...args) => a(b(...args)))
    }
    

总之，还是充分利用了数组的 `reduce` 方法。

函数式概念确实有些抽象，需要开发者仔细琢磨，并动手调试。一旦顿悟，必然会感受到其中的优雅和简洁。

### apply、bind 进阶实现

面试中关于 `this` 绑定的相关话题如今已经“泛滥”，同时对 `bind`
方法的实现，社区上也有相关讨论。但是很多内容尚不系统，且存在一些瑕疵。这里简单摘录我 2017 年年初写的文章
[从一道面试题，到“我可能看了假源码”](https://www.jianshu.com/p/6958f99db769) 来递进讨论。在《一网打尽
this》一课中，我们介绍过对 `bind` 的实现，这里进一步展开讲解。

此处不再赘述 `bind` 函数的使用，尚不清楚的读者可以自行补充一下基础知识。我们先来看一个初级实现版本：

    
    
    Function.prototype.bind = Function.prototype.bind || function (context) {
        var me = this;
        var argsArray = Array.prototype.slice.call(arguments);
        return function () {
            return me.apply(context, argsArray.slice(1))
        }
    }
    

这是一般合格开发者提供的答案，如果面试者能写到这里，给他 60 分。

**先简要解读一下：**

基本原理是使用 `apply` 进行模拟 `bind`。函数体内的 `this` 就是需要绑定 `this` 的函数，或者说是原函数。最后使用
`apply` 来进行参数（`context`）绑定，并返回。

与此同时，将第一个参数（`context`）以外的其他参数，作为提供给原函数的预设参数，这也是基本的“ curry 化”基础。

上述实现方式，我们返回的参数列表里包含：`argsArray.slice(1)`， **它的问题在于存在预置参数功能丢失的现象。**

想象我们返回的绑定函数中，如果想实现预设传参（就像 `bind` 所实现的那样），就面临尴尬的局面。真正实现“ curry 化”的“完美方式”是：

    
    
    Function.prototype.bind = Function.prototype.bind || function (context) {
        var me = this;
        var args = Array.prototype.slice.call(arguments, 1);
        return function () {
            var innerArgs = Array.prototype.slice.call(arguments);
            var finalArgs = args.concat(innerArgs);
            return me.apply(context, finalArgs);
        }
    }
    

但继续探究，我们注意 `bind` 方法中：`bind` 返回的函数如果作为构造函数，搭配 `new` 关键字出现的话，我们的绑定 `this`
就需要“被忽略”，`this` 要绑定在实例上。也就是说，`new` 的操作符要高于 `bind` 绑定，兼容这种情况的实现：

    
    
    Function.prototype.bind = Function.prototype.bind || function (context) {
        var me = this;
        var args = Array.prototype.slice.call(arguments, 1);
        var F = function () {};
        F.prototype = this.prototype;
        var bound = function () {
            var innerArgs = Array.prototype.slice.call(arguments);
            var finalArgs = args.concat(innerArgs);
            return me.apply(this instanceof F ? this : context || this, finalArgs);
        }
        bound.prototype = new F();
        return bound;
    }
    

如果你认为这样就完了，其实我会告诉你说，高潮才刚要上演。曾经的我也认为上述方法已经比较完美了，直到我看了 es5-shim 源码（已适当删减）：

    
    
    function bind(that) {
        var target = this;
        if (!isCallable(target)) {
            throw new TypeError('Function.prototype.bind called on incompatible ' + target);
        }
        var args = array_slice.call(arguments, 1);
        var bound;
        var binder = function () {
            if (this instanceof bound) {
                var result = target.apply(
                    this,
                    array_concat.call(args, array_slice.call(arguments))
                );
                if ($Object(result) === result) {
                    return result;
                }
                return this;
            } else {
                return target.apply(
                    that,
                    array_concat.call(args, array_slice.call(arguments))
                );
            }
        };
        var boundLength = max(0, target.length - args.length);
        var boundArgs = [];
        for (var i = 0; i < boundLength; i++) {
            array_push.call(boundArgs, '$' + i);
        }
        bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this, arguments); }')(binder);
    
        if (target.prototype) {
            Empty.prototype = target.prototype;
            bound.prototype = new Empty();
            Empty.prototype = null;
        }
        return bound;
    }
    

es5-shim 的实现到底在“搞什么鬼”呢？你可能不知道，其实每个函数都有 `length` 属性。对，就像数组和字符串那样。函数的 `length`
属性，用于表示函数的形参个数。更重要的是函数的 `length` 属性值是不可重写的。我写了个测试代码来证明：

    
    
    function test (){}
    test.length  // 输出 0
    test.hasOwnProperty('length')  // 输出 true
    Object.getOwnPropertyDescriptor('test', 'length') 
    // 输出：
    // configurable: false, 
    // enumerable: false,
    // value: 4, 
    // writable: false 
    

说到这里，那就好解释了： **es5-shim 是为了最大限度地进行兼容，包括对返回函数`length` 属性的还原**
。而如果按照我们之前实现的那种方式，`length` 值始终为零。因此，既然不能修改 `length` 的属性值，那么在初始化时赋值总可以吧！于是我们可通过
`eval` 和 `new Function` 的方式动态定义函数。但是出于安全考虑，在某些浏览器中使用 `eval` 或者 `Function()`
构造函数都会抛出异常。然而巧合的是，这些无法兼容的浏览器基本上都实现了 `bind` 函数，这些异常又不会被触发。在上述代码里，重设绑定函数的
`length` 属性：

    
    
    var boundLength = max(0, target.length - args.length)
    

构造函数调用情况，在 `binder` 中也有效兼容：

    
    
    if (this instanceof bound) { 
        ... // 构造函数调用情况
    } else {
        ... // 正常方式调用
    }
    
    if (target.prototype) {
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        // 进行垃圾回收清理
        Empty.prototype = null;
    }
    

对比过几版的 polyfill 实现，对于 `bind` 应该有了比较深刻的认识。这一系列实现有效地考察了很重要的知识点：比如 `this`
的指向、JavaScript 闭包、原型与原型链，设计程序上的边界 case 和兼容性考虑经验等硬素质。

#### 一道更好的面试题

最后，现如今在很多面试中，面试官都会以“实现 `bind`”作为题目。 **如果是我，现在可能会规避这个很容易“应试”的题目，而是别出心裁，让面试者实现一个
“call/apply”** 。我们往往用 `call`/`apply` 模拟实现 `bind`，而直接实现 `call`/`apply` 也算简单：

    
    
    Function.prototype.applyFn = function (targetObject, argsArray) {
        if(typeof argsArray === 'undefined' || argsArray === null) {
            argsArray = []
        }
    
        if(typeof targetObject === 'undefined' || targetObject === null){
            targetObject = window
        }
    
        targetObject = new Object(targetObject)
    
        const targetFnKey = 'targetFnKey'
        targetObject[targetFnKey] = this
    
        const result = targetObject[targetFnKey](...argsArray)
        delete targetObject[targetFnKey]
        return result
    }
    

这样的代码不难理解，函数体内的 `this` 指向了调用 `applyFn` 的函数。为了将该函数体内的 `this` 绑定在 `targetObject`
上，我们采用了隐式绑定的方法：`targetObject[targetFnKey](...argsArray)`。

细心的读者会发现，这里存在一个问题：如果 `targetObject` 对象本身就存在 `targetFnKey` 这样的属性，那么在使用
`applyFn` 函数时，原有的 `targetFnKey` 属性值就会被覆盖，之后被删除。解决方案可以使用 ES6 `Sybmol()`
来保证键的唯一性；另一种解决方案是用 `Math.random()` 实现独一无二的 key，这里我们不再赘述。

### 实现这些 API 带来的启示

这些 API 的实现并不算复杂，却能恰如其分地考验开发者的 JavaScript
基础。基础是地基，是探究更深入内容的钥匙，是进阶之路上最重要的一环，需要每个开发者重视。在前端技术快速发展迭代的今天，在“前端市场是否饱和”，“前端求职火爆异常”，“前端入门简单，钱多人傻”等众说纷纭的浮躁环境下，对基础内功的修炼就显得尤为重要。这也是你在前端路上能走多远、走多久的关键。

从面试的角度看，面试题归根结底是对基础的考察，只有对基础烂熟于胸，才能具备突破面试的基本条件。

[课程代码仓库请单击这里查看](https://github.com/HOUCe/lucas-gitchat-courses)。

### 分享交流

请大家留言分享自己开发实践中遇到的「API」相关的难忘经历。阅读文章过程中有任何疑问随时可以跟其他小伙伴讨论，或者直接向作者 LucasHC
提问（作者看到后抽空解答）。 **你的分享不仅帮助他人，更会提升自己。**

你也可以说说自己最想了解的主题，课程内容会根据部分读者的意见和建议迭代和完善。

此外，我们为本课程付费读者创建了《前端开发核心知识进阶》微信交流群，以方便更有针对性地讨论课程相关问题。（入群请到第1-2课末尾添加 GitChat
小助手伽利略的微信，并注明「前端核心」，谢谢）



## JavaScript 知识图谱和高频考点梳理

今天这一课，让我们来放松一下：不再去解剖概念、分析题目，而是了解一下 JavaScript
知识点和高频考点，在更高的层面上对我们所学、以及将要学到的内容有一个更加清晰的认识。

为什么不在一开始介绍这个主题呢？相信读者经过几章节的学习，已经对本课程有了一个初步印象。在这个基础上，此时进行知识图谱和高频考点梳理，我认为能让大家能好的进入接下来章节，进行更加深入的内容。

### 知识图谱和重要考点

![enter image description
here](https://images.gitbook.cn/b3bec6f0-770f-11e9-83dc-19aaf4aa0006)

本课程中的 JavaScrip 部分，会面向进阶，一些基础的概念点，如流程控制语句、运算操作符、基本方法等不会再过多介绍，相反在 ES
语言演进、具体方案解决、编程思维、算法、工程化和框架等方面展开。

其中，编程思维、JavaScript 框架、工程化三个主题分别属于课程中的三大部分，系统地进行介绍；this 相关话题、ES
语言演进、异步、原型原型链、面向对象、数据类型、闭包、作用域、执行上下文、内存管理分别在独立的章节中展开；函数相关、重要 APIs
等内容，会融入到具体文章内容中进行渗透。

另外，图中虽然一些有强关联的知识模块已经用虚线画出，但是整个内容都是融会贯通的。在本课程中的一些章节会进行梳理，比如：性能优化话题就涉及到
JavaScript 引擎执行、浏览器渲染、网络知识等诸多内容。

最后，提一下面试考点，一般对于初中级职位，对于基础内容，例如：this
指向、数据类型转换考察非常频繁。这些内容能够很好体现开发者对于基础的理解，也是通往高级所必备的知识点。对于原型、原型链这方面的内容考察逐渐降温，转而对于
ES6 中 class 等面向对象内容考察越来越频繁。笔者认为，原型、原型链及其相关面向对象知识仍然非常重要，这对于理解 JavaScript
语言具有重要意义。对于高级职位的考察，异步是个不得不说的话题，同时工程化方面以及基础构建方面的经验也至关重要。

### 分享交流

请大家留言分享自己开发实践中遇到的「API」相关的难忘经历。阅读文章过程中有任何疑问随时可以跟其他小伙伴讨论，或者直接向作者 LucasHC
提问（作者看到后抽空解答）。 **你的分享不仅帮助他人，更会提升自己。**

你也可以说说自己最想了解的主题，课程内容会根据部分读者的意见和建议迭代和完善。

此外，我们为本课程付费读者创建了《前端开发核心知识进阶》微信交流群，以方便更有针对性地讨论课程相关问题。（入群请到第1-2课末尾添加 GitChat
小助手伽利略的微信，并注明「前端核心」，谢谢）



## 其他基础题库

此节课程前，我们已经梳理了 JavaScript 当中 this、执行上下文、作用域、闭包、几个 APIs
实现等基础内容。在下一部分中，我们也将认识到原型、原型链、异步等知识。除了以上罗列的概念外，在 JavaScript
中还存在一些较为“细小”，却至关重要的概念和细节。这些内容看似零碎，但它们是 JavaScript
基础拼图的重要环节，是代码的基本单元，甚至在面试中也是单独的考察点。这一节，我们将对这些“其他”内容进行梳理。

主要关键字包括：类型（类型判断，类型转换，源码分析等），函数参数引用，相关面试题目分析等。

如图：

![enter image description
here](https://images.gitbook.cn/4a254ee0-7a42-11e9-8dec-3dba4995d575)

### JavaScript 类型及其判断

JavaScript 具有七种内置数据类型，它们分别是：

  * null
  * undefined
  * boolean
  * number
  * string
  * object
  * symbol

其中，前面五种为基本类型。第六种 object 类型又具体包含了 function、array、date 等。

对于这些类型的判断，我们常用的方法有：

  * typeof
  * instanceof
  * Object.prototype.toString
  * constructor

#### 使用 typeof 判断类型

基本类型可以使用 `typeof` 来判断：

    
    
    typeof 5 // "number"
    typeof 'lucas' // "string"
    typeof undefined // "undefined"
    typeof true // "boolean"
    

但是也存在着一些特例，比如用 typeof 判断 null 时：

    
    
    typeof null // "object"
    

我们再看使用 typeof 判断复杂类型时的表现：

    
    
    const foo = () => 1
    typeof foo // "function"
    
    const foo = {}
    typeof foo // "object"
    
    const foo = []
    typeof foo // "object"
    
    const foo = new Date()
    typeof foo // "object"
    
    const foo = Symbol("foo") 
    typeof foo // "symbol"
    

因此，我们可以总结出：

**结论** 使用 typeof 可以准确判断出除 null 以外的基本类型，以及 function 类型、symbol 类型；null 会被 typeof
判断为 object。

#### 使用 instanceof 判断类型

再来看看 instanceof：

**使用 a instanceof B 判断的是：a 是否为 B 的实例，即 a 的原型链上是否存在 B 构造函数** 。因此如果我们使用：

    
    
    function Person(name) {
        this.name = name
    }
    const p = new Person('lucas')
    
    p instanceof Person
    // true
    

这里 p 是 Person 构造出来的实例。同时，顺着 p 的原型链，也能找到 Object 构造函数：

    
    
    p.__proto__.__proto__ === Object.prototype
    

因此：

    
    
    p instanceof Object
    
    // true
    

原型原型链的知识我们会在后续章节中介绍，这里只需要理解 instanceof 的判断原理即可。另外，一个细节需要注意：

    
    
    5 instanceof Number // false
    

返回 false，是因为 5 是基本类型，它并不是 Number 构造函数构造出来的实例对象，如果：

    
    
    new Number(5) instanceof Number 
    
    // true
    

结果返回 true。

我们使用以下代码来模拟 instanceof 原理：

    
    
    // L 表示左表达式，R 表示右表达式
    const instanceofMock = (L, R) => {
        if (typeof L !== 'object') {
            return false
        }
        while (true) { 
            if (L === null) {
                // 已经遍历到了最顶端
                return false
            }
            if (R.prototype === L.__proto__) {
                return true
            }
            L = L.__proto__
        } 
    }
    

L 表示左表达式，R 表示右表达式，我们可以如此使用：

    
    
    instanceofMock('', String)
    
    // false
    
    function Person(name) {
        this.name = name
    }
    const p = new Person('lucas')
    
    instanceofMock(p, Person)
    
    // true
    

#### 使用 constructor 和 Object.prototype.toString 判断类型

使用 Object.prototype.toString 判断类型，我们称之为“万能方法”，“终极方法”：

    
    
    console.log(Object.prototype.toString.call(1)) 
    // [object Number]
    
    console.log(Object.prototype.toString.call('lucas')) 
    // [object String]
    
    console.log(Object.prototype.toString.call(undefined)) 
    // [object Undefined]
    
    console.log(Object.prototype.toString.call(true)) 
    // [object Boolean]
    
    console.log(Object.prototype.toString.call({})) 
    // [object Object]
    
    console.log(Object.prototype.toString.call([])) 
    // [object Array]
    
    console.log(Object.prototype.toString.call(function(){})) 
    // [object Function]
    
    console.log(Object.prototype.toString.call(null)) 
    // [object Null]
    
    console.log(Object.prototype.toString.call(Symbol('lucas'))) 
    // [object Symbol]
    

具体将会在本课程最后部分的 type.js 源码分析中重点使用。

使用 constructor 可以查看目标的构造函数，这也可以进行类型判断，但也存在着问题，具体请看：

    
    
    var foo = 5
    foo.constructor
    // ƒ Number() { [native code] }
    
    var foo = 'Lucas'
    foo.constructor
    // ƒ String() { [native code] }
    
    var foo = true
    foo.constructor
    // ƒ Boolean() { [native code] }
    
    var foo = []
    foo.constructor
    // ƒ Array() { [native code] }
    
    var foo = {}
    foo.constructor
    // ƒ Object() { [native code] }
    
    var foo = () => 1
    foo.constructor
    // ƒ Function() { [native code] }
    
    var foo = new Date()
    foo.constructor
    // ƒ Date() { [native code] }
    
    var foo = Symbol("foo") 
    foo.constructor
    // ƒ Symbol() { [native code] }
    
    var foo = undefined
    foo.constructor
    // VM257:1 Uncaught TypeError: Cannot read property 'constructor' of undefined
        at <anonymous>:1:5
    
    var foo = null
    foo.constructor
    // VM334:1 Uncaught TypeError: Cannot read property 'constructor' of null
        at <anonymous>:1:5
    

我们发现对于 undefined 和 null，如果尝试读取其 constructor 属性，将会进行报错。并且 constructor
返回的是构造函数本身，一般使用它来判断类型的情况并不多见。

### JavaScript 类型及其转换

JavaScript
的一个显著特点就是“灵活”。“灵活”的反面就是猝不及防的“坑”多，其中一个典型的例子就是被诟病的类型“隐式转换”。先来看一个极端的例子：

    
    
    (!(~+[])+{})[--[~+""][+[]]*[~+[]]+~~!+[]]+({}+[])[[~!+[]*~+[]]] 
    // "sb"
    

这就是“隐式转换”的“成果”。为什么会有这样的输出，这里不过多研究，先从基础入手来进行分析。

MDN 这样介绍过 JavaScript 的特点：

> JavaScript 是一种弱类型或者说动态语言。这意味着你不用提前声明变量的类型，在程序运行过程中，类型会被自动确定。

我们再来看一些基本例子，在使用加号进行运算时：

    
    
    console.log(1 + '1')
    // 11
    
    console.log(1 + true)
    // 2
    
    console.log(1 + false)
    // 1
    
    console.log(1 + undefined)
    // NaN
    
    console.log('lucas' + true)
    // lucastrue
    

我们发现：

**结论** 当使用 + 运算符计算 string 和其他类型相加时，都会转换为 string 类型；其他情况，都会转换为 number 类型，但是
undefined 会转换为 NaN，相加结果也是 NaN

比如布尔值转换为 number 类型：true 为 1，false 为 0，因此：

    
    
    console.log(1 + true)
    // 2
    
    console.log(1 + false)
    // 1
    

再看代码：

    
    
    console.log({} + true)
    // [object Object]true
    

在 + 号两侧，如果存在复杂类型，比如对象，那么这到底是怎样的一套转换规则呢？

**结论** 当使用 + 运算符计算时，如果存在复杂类型，那么复杂类型将会转换为基本类型，再进行运算

这就涉及到“对象类型转基本类型”这个过程。具体规则：

**结论** 对象在转换基本类型时，会调用该对象上 valueOf 或 toString 这两个方法，该方法的返回值是转换为基本类型的结果

那具体调用 valueOf 还是 toString 呢？这是 ES 规范所决定的，实际上这取决于内置的 toPrimitive
调用结果。主观上说，这个对象倾向于转换成什么，就会优先调用哪个方法。如果倾向于转换为 Number 类型，就优先调用 valueOf；如果倾向于转换为
String 类型，就只调用 toString。这里我建议大家了解一些常用的转换结果，对于其他特例情况会查找规范即可。

很多经典“教科书”中，比如《JavaScript 高级程序设计》以及《你不知道的 JavaScript》介绍到对象转为基本类型时，会先调用
valueof，再调用
toString，这里引入了“这个对象倾向于转换成什么，就会优先调用哪个方法”其实取自规范当中的“PreferredType”概念，这个概念在这些书目中并没有提到。事实上，浏览器对
PreferredType 的理解比较一致，按照“对象转为基本类型时，会先调用 valueof，再调用
toString”也没有问题。感兴趣或者更加严谨的读者可以翻阅相关规范相关内容。

valueOf 以及 toString 是可以被开发者重写的。比如：

    
    
    const foo = {
      toString () {
        return 'lucas'
      },
      valueOf () {
        return 1
      }
    }
    

我们对 foo 对象的 valueOf 以及 toString 进行了重写，这时候调用：

    
    
    alert(foo)
    

输出：lucas。这里就涉及到“隐式转换”，在调用 alert 打印输出时，“倾向于使用 foo 对象的 toString 方法，将 foo
转为基本类型”，得以打印出结果。

然而：

    
    
    console.log(1 + foo)
    

输出：2，这时候的隐式转换“倾向于使用 foo 对象的 valueOf 方法，将 foo 转为基本类型”，得以进行相加。

我们再全面总结一下，对于加法操作，如果加号两边都是 Number 类型，其规则为：

  * 如果 + 号两边存在 NaN，则结果为 NaN（typeof NaN 是 'number'）
  * 如果是 Infinity + Infinity，结果是 Infinity
  * 如果是 -Infinity + (-Infinity)，结果是 -Infinity
  * 如果是 Infinity + (-Infinity)，结果是 NaN

如果加号两边有至少一个是字符串，其规则为：

  * 如果 + 号两边都是字符串，则执行字符串拼接
  * 如果 + 号两边只有一个值是字符串，则将另外的值转换为字符串，再执行字符串拼接
  * 如果 + 号两边有一个是对象，则调用 valueof() 或者 toStrinig() 方法取得值，转换为基本类型再进行字符串拼接。

对于其他操作符也是类似的。

当然也可以进行显式转换，我们往往使用类似 Number、Boolean、String、parseInt 等方法，进行显式类型转换，这里不再展开。

### JavaScript 函数参数传递

我们知道 JavaScript 当中有“引用赋值”和“基本类型赋值”以及相关概念：“深拷贝”、“浅拷贝”区分。那么函数的参数传递有什么讲究呢？请看例题：

    
    
    let foo = 1
    const bar = value => {
        value = 2
        console.log(value)
    }
    bar(foo)
    console.log(foo) 
    

两处输出分别为 2、1；也就是说在 bar 函数中，参数为基本类型时，函数体内复制了一份参数值，而不会影响参数实际值。

    
    
    let foo = {bar: 1}
    const func = obj => {
        obj.bar = 2
        console.log(obj.bar)
    }
    func(foo)
    console.log(foo)
    

两处输出分别为 2、{bar:
2}；也就是说如果函数参数是一个引用类型，当在函数体内修改这个引用类型参数的某个属性值时，将会对参数进行修改。因为这时候函数体内的引用地址指向了原来的参数。

但是如果在函数体内，直接修改了对参数的引用，则情况又不一样：

    
    
    let foo = {bar: 1}
    const func = obj => {
        obj = 2
        console.log(obj)
    }
    func(foo)
    console.log(foo)
    

两处输出分别为 2、{bar: 1}；这样的情况理解起来较为晦涩，其实总结下来就是：

  * 参数为基本类型时，函数体内复制了一份参数值，对于任何操作不会影响参数实际值
  * 函数参数是一个引用类型时，当在函数体内修改这个值的某个属性值时，将会对参数进行修改
  * 函数参数是一个引用类型时，如果我们直接修改了这个值的引用地址，则相当于函数体内新创建了一份引用，对于任何操作不会影响原参数实际值

### cannot read property of undefined 问题解决方案

这里我们分析一个常见的 JavaScript 细节：cannot read property of undefined
是一个常见的错误，如果意外的得到了一个空对象或者空值，这样恼人的问题在所难免。

考虑这样的一个数据结构：

    
    
    const obj = {
        user: {
            posts: [
                { title: 'Foo', comments: [ 'Good one!', 'Interesting...' ] },
                { title: 'Bar', comments: [ 'Ok' ] },
                { title: 'Baz', comments: []}
            ],
            comments: []
        }
    }
    

为了在对象中相关取值的过程，需要验证对象每一个 key 的存在性。常见的处理方案有：

  * && 短路运算符进行可访问性嗅探

    
    
    obj.user &&
    obj.user.posts &&
    obj.user.posts[0] &&
    obj.user.posts[0].comments
    

  * || 单元设置默认保底值

    
    
    (((obj.user || {}).posts||{})[0]||{}).comments 
    

  * try...catch

    
    
    var result
    try {
        result = obj.user.posts[0].comments
    }
    catch {
        result = null
    }
    

  * lodash 等库 get API

当然，我们也可以自己编写代码：

    
    
    const get = (p, o) => p.reduce((xs, x) => (xs && xs[x]) ? xs[x] : null, o)
    
    console.log(get(['user', 'posts', 0, 'comments'], obj)) // [ 'Good one!', 'Interesting...' ]
    console.log(get(['user', 'post', 0, 'comments'], obj)) // null
    

我们实现的方法中，接收两个参数，第一个参数表示获取值的路径（path）；另外一个参数表示目标对象。

同样，为了设计上的更加灵活和抽象，我们可以 curry 化方法：

    
    
    const get = p => o =>
        p.reduce((xs, x) =>
            (xs && xs[x]) ? xs[x] : null, o)
    
    const getUserComments = get(['user', 'posts', 0, 'comments'])
    
    console.log(getUserComments(obj))
    // [ 'Good one!', 'Interesting...' ]
    console.log(getUserComments({user:{posts: []}}))
    // null
    

最后，TC39 提案中有一个新的提案，支持：

    
    
    console.log(obj?.user?.posts[0]?.comments)
    

由此可见，JavaScript 语言也在不断演进。通过这个案例，想告诉大家：熟练掌握基础环节，将对于进阶起到关键作用。

### 分析一道网红题目

综合以上知识点，我们来看一道“网红”题目：

> Can (a == 1 && a == 2 && a == 3) ever evaluate to true?

即：

> a == 1 && a == 2 && a == 3 可能为 true 吗？

直观上分析，如果变量 a 是一个基本 Number 类型，这是不可能为 true 的，因此解题思路也需要从变量 a
的类型及（对象）转换（基本类型）上来考虑。

方案一：

    
    
    const a = {
        value: 1,
        toString: function () {
            return a.value++
        }
    }
    console.log(a == 1 && a == 2 && a == 3) // true
    

这个方案中，我们将 a 定义为一个对象，并重写了其 toString 方法。因此在每次进行判断时，按照规则，== 号两边出现了对象类型，另一边是
Number 类型，需要调用 a 对象 toString 方法，toString 方法的返回值会作为对象转为基本类型的值，我们每次将 value 属性加
1。同样，如果按照相同的方式重写 valueOf 方法，也是可以达到同样目的的。

方案二：

    
    
    let value = 0
    Object.defineProperty(window, 'a', {
        get: function() {
            return ++value
        }
    })
    
    console.log(a == 1 && a == 2 && a == 3) // true
    

这里我们将 a 作为属性，挂载在 window 对象当中，重写其 getter 方法。

当然，以上两种方法并不惟一，社区上也有给出其他“奇技艺巧”的解决方案。这里我们聚焦在本节课程的知识点上即可。

### type.js 源码解读

[type.js](https://github.com/jsmini/type) 是由颜海镜编写的用于判断数据类型的方法库，其兼容
IE6，灵活运用了多种判断类型方式：

    
    
    const toString = Object.prototype.toString;
    
    export function type(x, strict = false) {
        strict = !!strict;
    
        // fix typeof null = object
        if(x === null){
            return 'null';
        }
    
        const t = typeof x;
    
        // number string boolean undefined symbol
        if(t !== 'object'){
            return t;
        }
    
        let cls;
        let clsLow;
        try {
            cls = toString.call(x).slice(8, -1);
            clsLow = cls.toLowerCase();
        } catch(e) {
            // ie 下的 activex 对象
            return 'object';
        }
    
        if(clsLow !== 'object'){
            // 区分 String() 和 new String()
            if (strict && (clsLow === 'number' || clsLow === 'boolean' || clsLow === 'string')) {
                return cls;
            }
            return clsLow;
        }
    
        if(x.constructor == Object){
            return clsLow;
        }
    
        // Object.create(null)
        try {
            // __proto__ 部分早期 firefox 浏览器
            if (Object.getPrototypeOf(x) === null || x.__proto__ === null) {
                return 'object';
            }
        } catch(e) {
            // ie下无 Object.getPrototypeOf 会报错
        }
    
        // function A() {}; new A
        try {
            const cname = x.constructor.name;
    
            if (typeof cname === 'string') {
                return cname;
            }
        } catch(e) {
            // 无 constructor
        }
    
        // function A() {}; A.prototype.constructor = null; new A
        return 'unknown';
    }
    

其中关键点提炼出来有：

  * 通过 x === null 来判断 null 类型
  * 对于 typeof x 不为 object 的情况，直接返回 typeof x 结果，这时候可以判断出 number，string，boolean，undefined，symbol 类型
  * 其他情况，对于 IE6 以上版本，使用 Object.prototype.toString 方法并进行返回
  * 兼容性处理，比如对于不支持 Object.prototype.toString 方法的情况，返回 object
  * 其他兼容性处理

兼容性处理部分因为历史原因，我们不再追究。这里重点关注一下 Object.prototype.toString
方法，该方法确实可以称得上“终极方案”。对返回结果使用 .slice(8, -1)，更加方便拿到结果：

    
    
    Object.prototype.toString.call(true).slice(8, -1)
    
    // "Boolean"
    

相关规范文档：[Object.prototype.toString](http://lzw.me/pages/ecmascript/#304)

### 总结

这节课程，我们“零散”介绍了很多细节，细心的同学会发现，这些细节本质上都围绕着“类型”这个概念。关于类型，以及相关的类型转换，涉及到 JavaScript
语言特点，涉及到语言规范内容。对此，对于这些规则，需要开发者“熟记”，如果在自己认知之外的，能够做到查阅规范，找到解释即可。不必钻牛角尖。

### 分享交流

请大家留言分享自己开发实践中遇到的相关的难忘经历。在阅读文章的过程中有任何疑问随时可以跟其他小伙伴讨论，或者直接向作者 LucasHC
提问（作者看到后抽空答复）。 **你的分享不仅帮助他人，更会提升自己。**

你也可以说说自己最想了解的主题，课程内容会根据部分读者的意见和建议迭代和完善。

此外，我们为本课程付费读者创建了《前端开发核心知识进阶》微信交流群，以方便更有针对性地讨论课程相关问题。（入群请到第1-2课末尾添加 GitChat
小助手伽利略的微信，并注明「前端核心」，谢谢~）



## 异步不可怕“死记硬背”+ 实践拿下（上）

异步是前端开发的一个重点内容，也是难点之一。JavaScript
语言在各个历史阶段，为更优雅地实现异步，进行过多种尝试。但是由于异步天生的“复杂度”，使得开发者并不能够轻松地吃透理论并上手实践。

**理论方面，** 我们知道 JavaScript 是单线程的，那它又是如何实现异步的呢？在这个环节中，浏览器或 NodeJS
又起到了什么样的作用？什么是宏任务，什么是微任务？

**实践上，** 从 callback 到 promise，从 generator 到 async/await，到底应该如何更优雅地实现异步操作？

本课让我们来一探究竟。

相关知识点如下：

![enter image description
here](https://images.gitbook.cn/bd780440-9429-11e9-8a7a-fbd0c49819f7)

整个内容分为两节课：第一节课，实践上，我们从需求开始慢慢打磨，让我们都能成为运筹帷幄的“老司机”；第二节课，从多种例题入手，分析语言和浏览器行为。

另外，由于这门课程的目标是“进阶”， **这里不会再单独介绍类似 Promise 的使用，async/await
等基本概念和知识点请大家提前做好相关知识储备。**

###  异步流程初体验

让我们先从一个需求开始，来实现一个“运动路径动画”流程：

> 移动页面上元素 target（document.querySelectorAll('#man')[0]）

>

> 先从原点出发，向左移动 20px，之后再向上移动 50px，最后再次向左移动 30px，请把运动动画实现出来。

我们将移动的过程封装成一个 walk 函数，该函数要接受以下三个参数。

  * direction：字符串，表示移动方向，这里简化为“left”、“top”两种枚举
  * distance：整型，可正或可负
  * callback：动作执行后回调

direction 表示移动方向，distance 表示移动距离。通过 distance 的正负值，我们可以实现四个方向的移动。

#### 回调方案

因为每一个任务都是相互联系的：当前任务结束之后，将会马上进入下一个流程，如何将这些流程串联起来呢？我们采用最简单的 callback
实现，明确指示下一个任务。

    
    
    const target = document.querySelectorAll('#man')[0]
    target.style.cssText = `
        position: absolute;
        left: 0px;
        top: 0px
    `
    
    const walk = (direction, distance, callback) => {
        setTimeout(() => {
            let currentLeft = parseInt(target.style.left, 10)
            let currentTop = parseInt(target.style.top, 10)
    
            const shouldFinish = (direction === 'left' && currentLeft === -distance) || (direction === 'top' && currentTop === -distance)
    
            if (shouldFinish) {
                // 任务执行结束，执行下一个回调
                callback && callback()
            }
            else {
                if (direction === 'left') {
                    currentLeft--
                    target.style.left = `${currentLeft}px`
                }
                else if (direction === 'top') {
                    currentTop--
                    target.style.top = `${currentTop}px`
                }
    
                walk(direction, distance, callback)
            }
        }, 20)
    }
    
    walk('left', 20, () => {
        walk('top', 50, () => {
            walk('left', 30, Function.prototype)
        })
    })
    

有几点需要大家注意。

  * 为了简化问题，我们将目标元素的定位进行了初始化设定：

    
    
    position: absolute;
    left: 0px;
    top: 0px
    

且不再考虑边界 case（如移除屏幕外等）。

  * 为了能够展现出动画，我们将 walk 函数的执行逻辑包裹在 20 毫秒的定时器当中，每次执行一像素的运动时，都会有一个停留定格。

这样的实现完全面向过程，代码比较“丑”，读者只需体会使用回调来解决异步任务的处理方案。也要发现：

    
    
    walk('left', 20, () => {
        walk('top', 50, () => {
            walk('left', 30, Function.prototype)
        })
    })
    

这样的回调嵌套很不优雅，有几次位移任务，就会嵌套几层，是名副其实的回调地狱。

#### Promise 方案

我们再来看一下如何用 Promise 解决问题：

    
    
    const target = document.querySelectorAll('#man')[0]
    target.style.cssText = `
        position: absolute;
        left: 0px;
        top: 0px
    `
    
    const walk = (direction, distance) => 
        new Promise((resolve, reject) => {
            const innerWalk = () => {
                setTimeout(() => {
                    let currentLeft = parseInt(target.style.left, 10)
                    let currentTop = parseInt(target.style.top, 10)
    
                    const shouldFinish = (direction === 'left' && currentLeft === -distance) || (direction === 'top' && currentTop === -distance)
    
                    if (shouldFinish) {
                        // 任务执行结束
                        resolve()
                    }
                    else {
                        if (direction === 'left') {
                            currentLeft--
                            target.style.left = `${currentLeft}px`
                        }
                        else if (direction === 'top') {
                            currentTop--
                            target.style.top = `${currentTop}px`
                        }
    
                        innerWalk()
                    }
                }, 20)
            }
            innerWalk()
        })
    
    walk('left', 20)
        .then(() => walk('top', 50))
        .then(() => walk('left', 30))
    

几个注意点：

  * walk 函数不再嵌套调用，不再执行 callback，而是函数整体返回一个 promise，以利于后续任务的控制和执行 
  * 设置 innerWalk 进行每一像素的递归调用
  * 在当前任务结束时（shouldFinish 为 true），resolve 当前 promise

对比上述实现，我们发现使用 promise 的解决方案明显更加清晰、易读。

#### generator 方案

ES Next 中生成器其实并不是天生为解决异步而生的，但是它又天生非常适合解决异步问题。用 generator 方案解决异步任务也同样优秀：

    
    
    const target = document.querySelectorAll('#man')[0]
    target.style.cssText = `
        position: absolute;
        left: 0px;
        top: 0px
    `
    
    const walk = (direction, distance) => 
        new Promise((resolve, reject) => {
            const innerWalk = () => {
                setTimeout(() => {
                    let currentLeft = parseInt(target.style.left, 10)
                    let currentTop = parseInt(target.style.top, 10)
    
                    const shouldFinish = (direction === 'left' && currentLeft === -distance) || (direction === 'top' && currentTop === -distance)
    
                    if (shouldFinish) {
                        // 任务执行结束
                        resolve()
                    }
                    else {
                        if (direction === 'left') {
                            currentLeft--
                            target.style.left = `${currentLeft}px`
                        }
                        else if (direction === 'top') {
                            currentTop--
                            target.style.top = `${currentTop}px`
                        }
    
                        innerWalk()
                    }
                }, 20)
            }
            innerWalk()
        })
    
    function *taskGenerator() {
        yield walk('left', 20)
        yield walk('top', 50)
        yield walk('left', 30)
    }
    const gen = taskGenerator()
    

我们定义了一个 taskGenerator 生成器函数，并实例化出 gen，手动执行：

    
    
    gen.next()
    

将会向左偏移 20 像素。

再次手动执行：

    
    
    gen.next()
    

将会向上偏移 50 像素。

再次手动执行：

    
    
    gen.next()
    

将会向左偏移 30 像素。

整个过程掌控感十足，唯一的不便之处就是需要我们反复手动执行 gen.next()。为此社区上早有方案，kj 大神的 [co
库](https://github.com/tj/co)，能够自动包裹 generator 并执行，源码实现并不复杂，推荐给大家阅读。但是在新时代里，作为
generator 的语法糖，async/await 也许将会是“更优雅、更终极”解决方案。

#### async/await 方案

基于以上基础，改造成 async/await 方案也并不困难。

直接看代码：

    
    
    const target = document.querySelectorAll('#man')[0]
    target.style.cssText = `
        position: absolute;
        left: 0px;
        top: 0px
    `
    
    const walk = (direction, distance) => 
        new Promise((resolve, reject) => {
            const innerWalk = () => {
                setTimeout(() => {
                    let currentLeft = parseInt(target.style.left, 10)
                    let currentTop = parseInt(target.style.top, 10)
    
                    const shouldFinish = (direction === 'left' && currentLeft === -distance) || (direction === 'top' && currentTop === -distance)
    
                    if (shouldFinish) {
                        // 任务执行结束
                        resolve()
                    }
                    else {
                        if (direction === 'left') {
                            currentLeft--
                            target.style.left = `${currentLeft}px`
                        }
                        else if (direction === 'top') {
                            currentTop--
                            target.style.top = `${currentTop}px`
                        }
    
                        innerWalk()
                    }
                }, 20)
            }
            innerWalk()
        })
    
    const task = async function () {
        await walk('left', 20)
            await walk('top', 50)
            await walk('left', 30)
    } 
    

只需要直接执行 task() 即可。

通过对比 generator 和 async/await 这两种方式，读者应该准确认识到， **async/await 就是 generator
的语法糖，它能够自动执行生成器函数，更加方便地实现异步流程。**

###  红绿灯任务控制

有了前面内容的热身，我们直接趁热打铁，再来看一道比较典型的问题。

> 红灯 3s 亮一次，绿灯 1s 亮一次，黄灯 2s 亮一次；如何让三个灯不断交替重复亮灯？

>

> 三个亮灯函数已经存在：

    
    
    function red() {
        console.log('red');
    }
    function green() {
        console.log('green');
    }
    function yellow() {
        console.log('yellow');
    }
    

这道题其实和开头部分“异步流程初体验”的题目类似，更复杂的地方在于 **需要“交替重复”亮灯** ，而不是“移动完了”就结束的一锤子买卖。

请读者对着上述内容，比葫芦画瓢试着实现。

还是从最简单、最容易理解的 callback 方案入手：

    
    
    const task = (timer, light, callback) => {
        setTimeout(() => {
            if (light === 'red') {
                red()
            }
            else if (light === 'green') {
                green()
            }
            else if (light === 'yellow') {
                yellow()
            }
            callback()
        }, timer)
    }
    
    
    task(3000, 'red', () => {
        task(1000, 'green', () => {
            task(2000, 'yellow', Function.prototype)
        })
    })
    

上述代码有可优化空间，这里为了大家方便理解，我不再进行简化。同时存在一个明显的
bug：代码只是完成了一次流程，执行后红黄绿灯分别只亮一次。该如何让它交替重复进行呢？

我们上面提到过递归，那么该递归谁呢？当然是递归亮灯的一个周期：

    
    
    const step = () => {
        task(3000, 'red', () => {
            task(1000, 'green', () => {
                task(2000, 'yellow', step)
            })
        })
    }
    
    step()
    

**注意看黄灯亮的回调里，我们又再次调用了 step 方法** 以完成循环亮灯。

用 promise 实现：

    
    
    const task = (timer, light) => 
        new Promise((resolve, reject) => {
            setTimeout(() => {
                if (light === 'red') {
                    red()
                }
                else if (light === 'green') {
                    green()
                }
                else if (light === 'yellow') {
                    yellow()
                }
                resolve()
            }, timer)
        })
    
    const step = () => {
        task(3000, 'red')
            .then(() => task(1000, 'green'))
            .then(() => task(2000, 'yellow'))
            .then(step)
    }
    
    step()
    

我们将回调移除，在一次亮灯结束后，resolve 当前 promise，并依然使用递归进行。

同时给出 async/await 的实现，供大家参考：

    
    
    const taskRunner =  async () => {
        await task(3000, 'red')
        await task(1000, 'green')
        await task(2000, 'yellow')
        taskRunner()
    }
    
    taskRunner()
    

毫无疑问，还是 async/await 的方案更加舒服。

可见，熟悉 Promise 是基础，是理解 async/await 的必要知识，学习 async/await
代表了学习“最先进的生产力”。我曾经的文章：[ES6 Async/Await 完爆 Promise 的 6
个原因](https://segmentfault.com/a/1190000009070711)，对比过 async/await
的优秀之处，感兴趣的读者可以进行了解。

当然再次重申： **async/await 是语法糖，它更有魅力，但是学习 promise 是消化这颗糖的前提。**

###  复杂的真实场景案例

下面将一步一步制造一个较为复杂的场景，贴近真实环境，在实战中将异步操作用到极致。

#### 请求图片进行预先加载

假设预先有 urlIds 数组，数组的每一项都可以按照规则拼接成一个完整的图片地址。根据这个数组，依次请求图片进行预加载。

这个比较简单，我们先实现一个请求图片的方法：

    
    
    const loadImg = urlId => {
        const url = `https://www.image.com/${urlId}`
    
        return new Promise((resolve, reject) => {
            const img = new Image()
            img.onerror = function() { 
                reject(urlId)
            }
    
            img.onload = function() { 
                resolve(urlId)
            }
            img.src = url
        })
    }
    

该方法进行 promise 化（promisify），在图片成功加载时进行 resolve，加载失败时 reject。

依次请求图片：

    
    
    const urlIds = [1, 2, 3, 4, 5]
    
    urlIds.reduce((prevPromise, urlId) => {
        return prevPromise.then(() => loadImg(urlId))
    }, Promise.resolve())
    

我们使用了数组 reduce 方法，当然也可以面向过程实现：

    
    
    const loadImgOneByOne = index => {
        const length = urlIds.length
    
        loadImg(urlIds[index]).then(() => {
            if (index === length - 1) {
                return 
            }
            else {
                loadImgOneByOne(++index)
            }
        })
    
    }
    loadImgOneByOne(0)
    

当然也可以采用 async/await 实现：

    
    
    const loadImgOneByOne = async () => {
        for (i of urlIds) {
            await loadImg(urlIds[i])
        }
    }
    loadImgOneByOne()
    

上述代码的请求都是依次执行的，只有成功加载完第一张图片，才继续进行下一张图片的加载。

如果要求提高效率，将所有图片的请求一次性发出，该如何做呢？

    
    
    const urlIds = [1, 2, 3, 4, 5]
    
    const promiseArray = urlIds.map(urlId => loadImg(urlId))
    
    Promise.all(promiseArray)
        .then(() => {
            console.log('finish load all')
        })
        .catch(() => {
            console.log('promise all catch')
        })
    

继续提出需求，我们希望控制最大并发数为 3，最多 3 个请求一起发出，剩下 2 个一起发出，这就需要我们实现一个 loadByLimit
方法，实现可以考虑使用 Promise.race API：

    
    
    const loadByLimit = (urlIds, loadImg, limit) => {
     const urlIdsCopy = […urlIds]
    
     if (urlIdsCopy.length <= limit) {
      // 如果数组长度小于最大并发数，直接全部请求
      const promiseArray = urlIds.map(urlId => loadImg(urlId))
         return Promise.all(promiseArray)
     }
    
     // 注意 splice 方法会改变 urlIdsCopy 数组
     const promiseArray = urlIdsCopy.splice(0, limit).map(urlId => loadImg(urlId)) 
    
     urlIdsCopy.reduce(
      (prevPromise, urlId) => 
       prevPromise
        .then(() => Promise.race(promiseArray))
        .catch(error => {console.log(error)})
        .then(resolvedId => {
         // 将 resolvedId 剔除出 promiseArray 数组
         // 这里的删除只是伪代码，具体删除情况要看后端 Api 返回结果
         let resolvedIdPostion = promiseArray.findIndex(id => resolvedId === id)
         promiseArray.splice(resolvedIdPostion, 1)
         promiseArray.push(loadImg(urlId))
        })
      , 
      Promise.resolve()
     )
     .then(() => Promise.all(promiseArray))
    }
    

代码解读：Promise.race 接受一个 promise 数组，并返回这个数组中第一个 resolve 的 promise 的返回值。在有
Promise.race 返回后，我们不断地将已经 resolve 的 promise 从 promise
数组（promiseArray）中剔除，再添加进新的 promise 进入 promiseArray，重复执行，始终保持当前并发请求数小于等于 limit
值。

到此为止，我们已经掌握了比较基本的操作。 **再来看一个更加复杂的问题，这个问题出自阿里某部门 P7+ 的面试题。**

#### 改编自阿里某部门的面试题

这道题目我改编自阿里某（最核心）部门的面试题，并进行了一定程度的简化，希望大家不要刻意外传。

> 假设现在后端有一个服务，支持批量返回书籍信息，它接受一个数组作为请求数据，数组储存了需要获取书目信息的书目 id，这个服务 fetchBooksInfo
大概是这个样子：

    
    
    const fetchBooksInfo = bookIdList => {
        // ...
        return ([{
    
                id: 123,
                // ...
    
            },
            {
                id: 456
                // ...
            },
            // ...
        ])
    }
    

fetchBooksInfo 已经给出， **但是这个接口最多只支持 100 个 id 的查询。**

现在需要开发者实现 getBooksInfo 方法，该方法：

  * 支持调用单个书目信息：

    
    
    getBooksInfo(123).then(data => {console.log(data.id)}) // 123
    

  * 短时间（100 毫秒）内多次连续调用， **只发送一个请求** ，且获得各个书目信息：

    
    
    getBooksInfo(123).then(data => {console.log(data.id)}) // 123
    getBooksInfo(456).then(data => {console.log(data.id)}) // 456
    

**注意这里必须只发送一个请求，也就是说调用了一次 fetchBooksInfo。**

  * 要考虑服务端出错的情况，比如批量接口请求 [123, 446] 书目信息，但是服务端只返回了书目 123 的信息。此时应该进行合理的错误处理。

  * 对 id 重复进行处理

我们来将思路清理一下：

  * 100 毫秒内的连续请求，要求进行合并，只触发一次网络请求。因此需要一个 bookIdListToFetch 数组，并设置 100 毫秒的定时。在 100 毫秒以内，将所有的书目 id push 到 bookIdListToFetch 中， **bookIdListToFetch 长度为 100 时，进行 clearTimeout** ，并调用 fetchBooksInfo 发送请求
  * 因为服务端可能出错，返回的批量接口结果可能缺少某个书目信息。我们需要对相关的调用进行抛错，比如 100 毫秒内连续调用：

    
    
    getBooksInfo(123).then(data => {console.log(data.id)}) // 123
    getBooksInfo(456).then(data => {console.log(data.id)}) // 456
    

我们要归并只调用一次 fetchBooksInfo：

    
    
    fetchBooksInfo(123, 456)
    

如果返回有问题，只返回了：

    
    
    [{
        id: 123
        //...
    }]
    

没有返回 id 为 456 的书信息，需要：

    
    
    getBooksInfo(456).then(data => {console.log(data.id)}).catch(error => {
        console.log(error)
    }) 
    

捕获错误。

这样一来，我们要对每一个 getBooksInfo 对应的 promise 实例的 reject 和 resolve 方法进行存储，存储在内存
promiseMap 中，以便在合适的时机进行 reject 或 resolve 对应的 promise 实例。

请看代码（对边界 case 的处理省略），我加入了关键注释：

    
    
    // 储存将要请求的 id 数组
    let bookIdListToFetch = []
    
    // 储存每个 id 请求 promise 实例的 resolve 和 reject
    // key 为 bookId，value 为 resolve 和 reject 方法，如：
    // { 123: [{resolve, reject}]}
    // 这里之所以使用数组存储 {resolve, reject}，是因为可能存在重复请求同一个 bookId 的情况。其实这里我们进行了滤重，没有必要用数组。在需要支持重复的场景下，记得要用数组存储
    let promiseMap = {}
    
    // 用于数组去重
    const getUniqueArray = array => Array.from(new Set(array))
    
    // 定时器 id
    let timer
    
    const getBooksInfo = bookId => new promise((resolve, reject) => {
        promiseMap[bookId] = promiseMap[bookId] || []
        promiseMap[bookId].push({
            resolve,
            reject
        })
    
        const clearTask = () => {
            // 清空任务和存储
            bookIdListToFetch = []
            promiseMap = {}
        } 
    
        if (bookIdListToFetch.length === 0) {
            bookIdListToFetch.push(bookId)
    
            timer = setTimeout(() => {
                handleFetch(bookIdListToFetch, promiseMap)
    
                clearTask()
            }, 100)
        }
        else {
            bookIdListToFetch.push(bookId)
    
            bookIdListToFetch = getUniqueArray(bookIdListToFetch)
    
            if (bookIdListToFetch.length >= 100) {
                clearTimeout(timer)
    
                handleFetch(bookIdListToFetch, promiseMap)
    
                clearTask()
            }
        }
    })
    
    const handleFetch = (list, map) => {
        fetchBooksInfo(list).then(resultArray => {
            const resultIdArray = resultArray.map(item => item.id)
    
            // 处理存在的 bookId
            resultArray.forEach(data => promiseMap[data.id].forEach(item => {
                item.resolve(data)
            }))
    
            // 处理失败没拿到的 bookId
            let rejectIdArray ＝ []
            bookIdListToFetch.forEach(id => {
                // 返回的数组中，不含有某项 bookId，表示请求失败
                if (!resultIdArray.includes(id)) {
                    rejectIdArray.push(id)
                }
            })
    
            // 对请求失败的数组进行 reject
            rejectIdArray.forEach(id => promiseMap[id].forEach(item => {
                item.reject()
            }))
        }, error => {
            console.log(error)
        })
    }
    

做出这道题的关键是：

  * 准确理解题意，因为这个题目完全贴近实际场景需求，准确把控出题者的意图是第一步
  * 对 Promise 熟练掌握
  * 进行 setTimeout 合并 100 毫秒内的请求
  * 存储每个 bookId 的请求 promise 实例，存储该 promise 实例的 resolve 和 reject 方法，以便在批量数据返回时进行对应处理
  * 错误处理

### 总结

异步任务的处理，因其重要性，始终在前端开发中是一个不可忽视的考察点；又因其复杂性而考点灵活多变。需要开发者熟悉各种异步方案，同时每一种异步方案都是相辅相成的。如果你没有完全理解
callback，那你也许就很难理解 promise；如果 promise 没有熟练掌握，那么 generator 和 async/await 更无从谈起。

异步很多场景都涉及到网络、涉及到高风险计算，但本节还没有涉及到异步中 **错误处理** 这个重要内容，这方面的信息，我们会在后续课程《你以为我真的要你写一个
Promise 吗？》中进行穿插。

异步的整个学习过程需要我们从最基础开始，步步为营。如果一次理解不了，那就两次、三次。相信我，这一定是一个吃经验，吃重复次数的“水滴石穿”过程。

### 分享交流

在阅读文章过程中若有任何疑问随时可以跟其他小伙伴讨论，或者直接向作者 LucasHC 提问（作者看到后抽空回复）。
**你的分享不仅帮助他人，更会提升自己。**

也可以说说自己最想了解的主题，课程内容会根据部分读者的意见和建议迭代和完善。

此外，我们为本课程付费读者创建了《前端开发核心知识进阶》微信交流群，以方便更有针对性地讨论课程相关问题。（入群请到第1-2课末尾添加 GitChat
小助手伽利略的微信，并注明「前端核心」，谢谢~）



## 异步不可怕“死记硬背”+ 实践拿下（下）

上一讲了解了如何优雅地处理复杂异步任务。这一讲，我们回归理论，研究“同步异步”到底是个什么样的概念。我们从例题入手，梳理一下相关面试考点。这些题目有一个共同特点，判断输入输出的顺序：这是一类面试的“必考题”，考察点围绕着
JavaScript 和浏览器引擎交织的异步行为，包括 eventloop、宏任务、微任务等。

再次重复相关知识点，如下：

![](https://images.gitbook.cn/d8fe2920-7d03-11e9-9d75-b9239e62db53)

###  setTimeout 相关考察

观察以下代码：

    
    
    setTimeout(() => {
        console.log('setTimeout block')
    }, 100)
    
    while (true) {
    
    }
    
    console.log('end here')
    

将不会有任何输出。

原因很简单，因为 while 循环会一直循环代码块，因此主线程将会被占用。

但是：

    
    
    setTimeout(() => {
        while (true) {
    
        }
    }, 0)
    
    console.log('end here')
    

会打印出：end here。这段代码执行后，如果我们再执行任何语句，都不会再得到响应。

由此可以延伸出：JavaScript 中 **所有任务分为同步任务和异步任务** 。

  * 同步任务是指：当前主线程将要消化执行的任务，这些任务一起形成执行栈（execution context stack）
  * 异步任务是指：不进入主线程，而是进入任务队列（task queue），即不会马上进行的任务。

**当同步任务全都被消化，主线程空闲时，即上面提到的执行栈 execution context stack
为空时，将会执行任务队列中的任务，即异步任务。**

这样的机制保证了： **虽然 JavaScript
是单线程的，但是对于一些耗时的任务，我们可以将其丢入任务队列当中，这样一来，也就不会阻碍其他同步代码的执行。等到异步任务完成之后，再去进行相关逻辑的操作。**

回到例题，程序遇见 setTimeout 时，会将其内容放入任务队列（task queue）当中，继续执行同步任务，直到 while
循环，因为我们写死了一个循环条件，导致主线程同步任务被阻塞，主线程永远不会空闲。因此 console.log('end here')
代码不会执行，更没有可能在同步任务结束后，执行任务队列当中的 console.log('setTimeout block')。

如果稍做更改：

    
    
    const t1 = new Date()
    setTimeout(() => {
        const t3 = new Date()
        console.log('setTimeout block')
        console.log('t3 - t1 =', t3 - t1)
    }, 100)
    
    
    let t2 = new Date()
    
    while (t2 - t1 < 200) {
        t2 = new Date()
    }
    
    console.log('end here')
    

输出：

    
    
    // end here
    // setTimeout block
    // t3 - t1 = 200
    

我们看，即便 setTimeout 定时器的定时为 100 毫秒，但是同步任务中 while 循环将执行 200
毫秒，计时到时后仍然会先执行主线程中的同步任务，只有当同步任务全部执行完毕，end here 输出，才会开始执行任务队列当中的任务。此时 t3 和 t1
的时间差为 200 毫秒，而不是定时器设定的 100 毫秒。

上面两个例题比较简单，关于 setTimeout 最容易被忽视的其实是一个非常小的细节。 请看题目：

    
    
    setTimeout(() => {
        console.log('here 100')
    }, 100)
    
    setTimeout(() => {
        console.log('here 2')
    }, 0)
    

不要被吓到，这个题目并没有陷阱。因为第二个 setTimeout 将更快到时，所以先输出 here 2，再在 100 毫秒左右，输出 here 100。

但是如果：

    
    
    setTimeout(() => {
        console.log('here 1')
    }, 1)
    
    setTimeout(() => {
        console.log('here 2')
    }, 0)
    

按道理，也应该是第二个 setTimeout 将更快到时，先输出 here 2，再输出 here 1。但是在 Chrome 中运行结果相反，事实上针对这两个
setTimeout，谁先进入任务队列，谁先执行并不会严格按照 1 毫秒和 0 毫秒的区分。

表面上看，1 毫秒和 0 毫秒的延迟完全是等价的。这就有点类似“最小延迟时间”这个概念。直观上看，最小延迟时间是 1 毫秒，在 1
毫秒以内的定时，都以最小延迟时间处理。此时，在代码顺序上谁靠前，谁就先会在主线程空闲时优先被执行。

值得一提的是，MDN 上给出的最小延时概念是 4 毫秒，读者可以参考 [最小延迟时间](https://developer.mozilla.org/zh-
CN/docs/Web/API/Window/setTimeout)，另外，setTimeout
也有“最大延时”的概念。这都依赖于规范的制定和浏览器引擎的实现。

我个人认为没有太大的“钻牛角尖”必要。读者只需要心里清楚“有这么一个概念”即可。我们进入下一环节的学习。

### 宏任务 VS 微任务

在介绍宏任务和微任务之前，我们先看一下 Promise 相关输出情况：

    
    
    console.log('start here')
    
    new Promise((resolve, reject) => {
      console.log('first promise constructor')
      resolve()
    })
      .then(() => {
        console.log('first promise then')
        return new Promise((resolve, reject) => {
          console.log('second promise')
          resolve()
        })
          .then(() => {
            console.log('second promise then')
          })
      })
      .then(() => {
        console.log('another first promise then')
      })
    
    console.log('end here')
    

我们来分析一下：

  * 首先输出 start here 没有问题；
  * 接着到了一个 Promise 构造函数中，同步代码执行，输出 first promise constructor，同时将第一处 promise then 完成处理函数逻辑放入任务队列
  * 继续执行同步代码，输出 end here
  * 同步代码全部执行完毕，执行任务队列中的逻辑，输出 first promise then 以及 second promise
  * 当在 then 方法中返回一个 Promise 时（第 9 行），第一个 promise 的第二个完成处理函数（第 17 行）会置于返回的这个新 Promise 的 then 方法（第 13 行）后
  * 此时将返回的这个新 Promise 的 then 方法放到任务队列中，由于主线程并没有其他任务，转而执行第二个 then 任务，输出 second promise then
  * 最后输出 another first promise then

这道题目并不是很简单，主要涉及到了 Promise 的一些特性。我们会在下一课《你以为我真的让你手写 Promise 吗》中继续分析。

事实上，我们不难发现，Promise 完成处理函数也会被放到任务队列当中。但是这个“任务队列”和前面所提的 setTimeout
相关的的任务队列又有所不同。

任务队列中的异步任务其实又分为： **宏任务（macrotask）与微任务（microtask）**
，也就是说宏任务和微任务虽然都是异步任务，都在任务队列中，但是他们也是在两个不同的队列中。

那宏任务和微任务如何区分呢？

一般地宏任务包括：

  * setTimeout
  * setInterval
  * I/O
  * 事件
  * postMessage
  * setImmediate (Node.js，浏览器端该 API 已经废弃)
  * requestAnimationFrame
  * UI 渲染

微任务包括：

  * Promise.then
  * MutationObserver
  * process.nextTick (Node.js)

那么当代码中同时存在宏任务和微任务时，谁的优先级更高，先执行谁呢？请看代码：

    
    
    console.log('start here')
    
    const foo = () => (new Promise((resolve, reject) => {
        console.log('first promise constructor')
    
        let promise1 = new Promise((resolve, reject) => {
            console.log('second promise constructor')
    
            setTimeout(() => {
                console.log('setTimeout here')
                resolve()
            }, 0)
    
            resolve('promise1')
        })
    
        resolve('promise0')
    
        promise1.then(arg => {
            console.log(arg)
        })
    }))
    
    foo().then(arg => {
        console.log(arg)
    })
    
    console.log('end here')
    

这是一个更加复杂的例子，不要慌，我们一步一步分析。

  * 首先输出同步内容：start here，执行 foo 函数，同步输出 first promise constructor，

  * 继续执行 foo 函数，遇见 promise1，执行 promise1 构造函数，同步输出 second promise constructor，以及 end here。同时按照顺序：setTimeout 回调进入任务队列（宏任务），promise1 的完成处理函数（第 18 行）进入任务队列（微任务），第一个（匿名） promise 的完成处理函数（第 23 行）进入任务队列（微任务）

  * 虽然 setTimeout 回调率先进入任务队列，但是优先执行微任务，按照微任务顺序，先输出 promise1（promise1 结果），再输出 promise0（第一个匿名 promise 结果）

  * 此时所有微任务都处理完毕，执行宏任务，输出 setTimeout 回调内容 setTimeout here

由上分析得知，每次主线程执行栈为空的时候，引擎会优先处理微任务队列，处理完微任务队列里的所有任务，再去处理宏任务。

如同：

    
    
    console.log('start here')
    
    setTimeout(() => {
        console.log('setTimeout')
    }, 0)
    
    new Promise((resolve, reject) => {
        resolve('promise result')
    }).then(value => {console.log(value)})
    
    console.log('end here')
    

输出：

    
    
    start here
    end here
    promise result
    setTimeout
    

### 也谈头条那道“网红题”

综合上述所有知识，我们最后再来看一到头条的题目。这道题目非常“网红”，相信有的读者已经看过这道题目了。说实话，我个人认为这属于对异步理论纯知识点的考察，有些内容属于“你知道你就会，不知道就不会”，对于候选者的动手和解决问题能力的衡量稍欠。但是，面试官既然要考，不妨我们认真梳理分析一番。

题目：

    
    
    async function async1() {
        console.log('async1 start')
        await async2()
        console.log('async1 end')
    }
    
    async function async2() {
        console.log('async2')
    }
    
    console.log('script start')
    
    setTimeout(function() {
        console.log('setTimeout') 
    }, 0)  
    
    async1()
    
    new Promise(function(resolve) {
        console.log('promise1')
        resolve()
    }).then(function() {
        console.log('promise2')
    })
    
    console.log('script end')
    

千万不要看到 async 就害怕，其实它并不神秘。这里我并不打算赘述 async/await 的基础内容，读者需明白：

  * async 声明的函数，其返回值必定是 promise 对象，如果没有显式返回 promise 对象，也会用 Promise.resolve() 对结果进行包装，保证返回值为 promise 类型
  * await 会先执行其右侧表达逻辑（从右向左执行），并让出主线程，跳出 async 函数，而去继续执行 async 函数外的同步代码
  * 如果 await 右侧表达逻辑是个 promise，让出主线程，继续执行 async 函数外的同步代码，等待同步任务结束后，且该 promise 被 resolve 时，继续执行 await 后面的逻辑
  * 如果 await 右侧表达逻辑不是 promise 类型，那么仍然异步处理，将其理解包装为 promise， async 函数之外的同步代码执行完毕之后，会回到 async 函数内部，继续执行 await 之后的逻辑

因此我们来分析：

  * 首先执行同步代码，输出 script start，并向下执行，遇见 setTimeout，将其回调放入宏任务当中

  * 继续执行同步代码逻辑，遇见 async1()，执行 async1 内同步代码，输出 async1 start，继续下后执行到 await async2()，执行 async2 函数

  * async2 函数内并没有 await，按顺序执行，同步输出 async2，按照 async 函数规则，async2 函数仍然返回一个 promise，作为 async1 函数中的 await 表达式的值。相当于：

    
    
    Promise.resolve().then(() => {})
    

同时 async1 函数让出主线程，中断在 await 一行。

  * 回到 async1 函数外，继续执行，输出 Promise 构造函数内 promise1，同时将这个 promise 的执行完成逻辑放到微任务当中

  * 执行完最后一行代码，输出 script end

  * 此时同步代码全部执行完毕，回到 async1 函数中断处，优先执行微任务

    
    
    Promise.resolve().then(() => {})
    

其实什么也没做。但这时候 await 中断失效，继续执行 async1 函数，输出 async1 end

  * 这时候检查微任务，输出 promise2
  * 这时候微任务全部执行完毕，检查宏任务，输出 setTimeout

这时候，我将代码重新拷贝，加上注释，我们再来回顾一下：

    
    
    async function async1() {
        console.log('async1 start') // step 4: 直接打印同步代码 async1 start
        await async2() // step 5: 遇见 await，首先执行其右侧逻辑，并在这里中断 async1 函数
        console.log('async1 end') // step 11: 再次回到 async1 函数，await 中断过后，打印代码 async1 end
    }
    
    async function async2() {
        console.log('async2') // step 6: 直接打印同步代码 async2，并返回一个 resolve 值为 undefined 的 promise
    }
    
    console.log('script start') // step 1: 直接打印同步代码 script start
    
    // step 2: 将 setTimeout 回调放到宏任务中，此时 macroTasks: [setTimeout]
    setTimeout(function() {            
        console.log('setTimeout') // step 13: 开始执行宏任务，输出 setTimeout
    }, 0)  
    
    async1() // step 3: 执行 async1 
    
    // step 7: async1 函数已经中断，继续执行到这里
    new Promise(function(resolve) {
        console.log('promise1') // step 8: 直接打印同步代码 promise1
        resolve()
    }).then(function() { // step 9: 将 then 逻辑放到微任务当中
        console.log('promise2') // step 12: 开始执行微任务，输出 promise2
    })
    
    console.log('script end') // step 10: 直接打印同步代码 script end，并回到 async1 函数中继续执行 
    

至此，读者理解到这里就可以了。作为一个附加内容，其实在上面这道题目中，关于 promise2 和 async1 end 输出先后问题，是有一定争议的。比如在
Node10 版本前后，结果不一致。

关于这个争论，和 NodeJS 以及 V8 实现有关，相关文章：[《Faster async functions and
promises》](https://link.juejin.im/?target=https%3A%2F%2Fv8.dev%2Fblog%2Ffast-
async)，以及相关 [ECMA pull
request](https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Ftc39%2Fecma262%2Fpull%2F1250)

### 总结

由上述例题可见，这一类面试常见的“必考题”灵活多变，且会受到语言规范以及浏览器实现的影响。虽然有些考察点“涉嫌”“刁难”面试者，但是掌握最基本的异步理论、清楚规范要求细节，确实是能够灵活运用的关键，也是能够避免或追查
bugs 的必备知识。

我对大家的建议是，对于这些内容不必头大，见一个分析一个，分析一个就“死记”一个，规范永远没有为什么，但是仔细思考却总有它的道理。不然你们想想，JavaScript
为什么一开始就是单线程异步的？

### 分享交流

阅读文章过程中有任何疑问随时可以跟其他小伙伴讨论，或者直接向作者 LucasHC 提问（作者看到后抽空回复）。 **你的分享不仅帮助他人，更会提升自己。**

你也可以说说自己最想了解的主题，课程内容会根据部分读者的意见和建议迭代和完善。

此外，我们为本课程付费读者创建了《前端开发核心知识进阶》微信交流群，以方便更有针对性地讨论课程相关问题。（入群请到第1-2课末尾添加 GitChat
小助手伽利略的微信，并注明「前端核心」，谢谢~）



## 你以为我真的想让你手写 Promise 吗（上）

通过前面几节课的学习，我们认识到：想优雅地进行异步操作，必须要熟识一个极其重要的概念 ——
Promise。它是取代传统回调，实现同步链式写法的解决方案；是理解 generator、async/await 的关键。但是 Promise
对于初学者来说，并不是很好理解，其中的概念纷杂，且抽象程度较高。

与此同时，在中高级前端开发面试当中，对于 Promise 的考察也多种多样，近几年流行“让开发者实现一个
Promise”。那么这一讲，我就带大家实现一个简单的 Promise。注意： **实现不是最终目的，在实现的过程中，我会配以关键结论和关于 Promise
的考察题目，希望大家可以融会贯通。**

整个过程将分两节课完成，本讲的相关知识点如下：

![](https://images.gitbook.cn/f1981920-7f7c-11e9-9482-6704bcd43149)

### 从 Promise 化一个 API 谈起

熟悉微信小程序开发的读者应该知道，我们使用 wx.request() 在微信小程序环境中发送一个网络请求。参考官方文档，具体用法如下：

    
    
    wx.request({
      url: 'test.php', // 仅为示例，并非真实的接口地址
      data: {
        x: '',
        y: ''
      },
      header: {
        'content-type': 'application/json' // 默认值
      },
      success(res) {
        console.log(res.data)
      }
    })
    

配置化的 API 风格和我们早期使用 jQuery 中 Ajax 方法的封装类似。这样的设计有一个小的问题，就是容易出现“回调地狱”问题。如果我们想先通过
./userInfo 接口来获取登录用户信息数据，再从登录用户信息数据中，通过请求 `./${id}/friendList`
接口来获取登录用户所有好友列表，就需要：

    
    
    wx.request({
      url: './userInfo',
      success(res) {
        const id = res.data.id
        wx.request({
          url: `./${id}/friendList`,
          success(res) {
            console.log(res)
          }
        })
      }
    })
    

这只是嵌套了一层回调而已，还够不成“地狱”场景，但是足以说明问题。

我们知道解决“回调地狱”问题的一个极佳方式就是 Promise，将微信小程序 wx.request() 方法进行 Promise 化：

    
    
    const wxRequest = (url, data = {}, method = 'GET') => 
      new Promise((resolve, reject) => {
        wx.request({
          url,
          data,
          method,
          header: {
            //通用化 header 设置
          },
          success: function (res) {
            const code = res.statusCode
            if (code !== 200) {
              reject({ error: 'request fail', code })
              return
            }
            resolve(res.data)
          },
          fail: function (res) {
            reject({ error: 'request fail'})
          },
        })
      })
    

Promise 基本概念不再过多介绍。这是一个典型的 Promise 化案例，当然我们不仅可以对 wx.request() API 进行 Promise
化，更应该做的通用，能够 Promise 化更多类似（通过 success 和 fail 表征状态）的接口：

    
    
    const promisify = fn => args => 
      new Promise((resolve, reject) => {
        args.success = function(res) {
          return resolve(res)
        }
        args.fail = function(res) {
          return reject(res)
        }
      })
    

使用：

    
    
    const wxRequest = promisify(wx.request)
    

通过上例，我们知道：

Promise 其实就是一个构造函数，我们使用这个构造函数创建一个 Promise 实例。该构造函数很简单，它只有一个参数，按照 Promise/A+
规范的命名，把 Promise 构造函数的参数叫做 executor，executor 类型为函数。这个函数又“自动”具有 resolve、reject
两个方法作为参数。

请仔细体会上述结论，那么我们可以通过结论，开始实现 Promise 的第一步：

    
    
    function Promise(executor) {
    
    }
    

好吧，初始起步是够基本的了。如果读者还不理解构造函数的概念，我给大家推荐阅读： [构造函数与 new
命令](http://javascript.ruanyifeng.com/oop/basic.html)，在理解的基础上，让我们继续吧。

### Promise 初见雏形

在上面的 wx.request() 介绍中，实现了 Promise 化，因此对于嵌套回调场景，可以：

    
    
    wxRequest('./userInfo')
      .then(
        data => wxRequest(`./${data.id}/friendList`),
        error => {
          console.log(error)
        }
      )
      .then(
        data => {
          console.log(data)
        },
        error => {
          console.log(error)
        }
      )
    

通过观察使用例子，我们来剖析 Promise 的实质：

**结论** Promise 构造函数返回一个 promise 对象实例，这个返回的 promise 对象具有一个 then 方法。then
方法中，调用者可以定义两个参数，分别是 onfulfilled 和 onrejected，它们都是函数类型。其中 onfulfilled 通过参数，可以获取
promise 对象 resolved 的值，onrejected 获得 promise 对象 rejected
的值。通过这个值，我们来处理异步完成后的逻辑。

这些都是规范的基本内容： [Promise/A+](https://promisesaplus.com/)。

因此，继续实现我们的 Promise：

    
    
    function Promise(executor) {
    
    }
    
    Promise.prototype.then = function(onfulfilled, onrejected) {
    
    }
    

继续复习 Promise 的知识，看例子来理解：

    
    
    let promise1 = new Promise((resolve, reject) => {
      resolve('data')
    })
    
    promise1.then(data => {
      console.log(data)
    })
    
    let promise2 = new Promise((resolve, reject) => {
      reject('error')
    })
    
    promise2.then(data => {
      console.log(data)
    }, error => {
      console.log(error)
    })
    

**结论** 我们在使用 new 关键字调用 Promise 构造函数时，在合适的时机（往往是异步结束时），调用 executor 的参数 resolve
方法，并将 resolved 的值作为 resolve 函数参数执行，这个值便可以后续在 then
方法第一个函数参数（onfulfilled）中拿到；同理，在出现错误时，调用 executor 的参数 reject 方法，并将错误信息作为 reject
函数参数执行，这个错误信息可以在后续的 then 方法第二个函数参数（onrejected）中拿到。

因此，我们在实现 Promise 时，应该有两个值，分别储存 resolved 的值，以及 rejected 的值（当然，因为 Promise
状态的唯一性，不可能同时出现 resolved 的值和 rejected 的值，因此也可以用一个变量来存储）；同时也需要存在一个状态，这个状态就是
promise 实例的状态（pending，fulfilled，rejected）；同时还要提供 resolve 方法以及 reject
方法，这两个方法需要作为 executor 的参数提供给开发者使用：

    
    
    function Promise(executor) {
      const self = this
      this.status = 'pending'
      this.value = null
      this.reason = null
    
      function resolve(value) {
        self.value = value
      }
    
      function reject(reason) {
        self.reason = reason
      }
    
      executor(resolve, reject)
    }
    
    Promise.prototype.then = function(onfulfilled = Function.prototype, onrejected = Function.prototype) {
      onfulfilled(this.value)
    
      onrejected(this.reason)
    }
    

为了保证 onfulfilled、onrejected 能够强健执行，我们为其设置了默认值，其默认值为一个函数元（Function.prototype）。

**注意，因为 resolve 的最终调用是由开发者在不确定环境下（往往是在全局中）直接调用的。为了在 resolve 函数中能够拿到 promise
实例的值，我们需要对 this 进行保存，上述代码中用 self 变量记录 this，或者使用箭头函数：**

    
    
    function Promise(executor) {
      this.status = 'pending'
      this.value = null
      this.reason = null
    
      const resolve = value => {
        this.value = value
      }
    
      const reject = reason => {
        this.reason = reason
      }
    
      executor(resolve, reject)
    }
    
    Promise.prototype.then = function(onfulfilled = Function.prototype, onrejected = Function.prototype) {
      onfulfilled(this.value)
    
      onrejected(this.reason)
    }
    

**为什么 then 放在 Promise 构造函数的原型上，而不是放在构造函数内部呢？**

这涉及到原型、原型链的知识了，虽然不是本讲的内容，这里还是简单地提一下：每个 promise 实例的 then
方法逻辑是一致的，在实例调用该方法时，可以通过原型（Promise.prototype）找到，而不需要每次实例化都新创建一个 then
方法，这样节省内存，显然更合适。

### Promise 实现状态完善

我们先来看一到题目，判断输出：

    
    
    let promise = new Promise((resolve, reject) => {
      resolve('data')
      reject('error')
    })
    
    promise.then(data => {
      console.log(data)
    }, error => {
      console.log(error)
    })
    

**只会** 输出：data，因为我们知道 promise 实例状态只能从 pending 改变为 fulfilled，或者从 pending 改变为
rejected。状态一旦变更完毕，就不可再次变化或者逆转。也就是说：如果一旦变到 fulfilled，就不能再 rejected，一旦变到
rejected，就不能 fulfilled。

而我们的代码实现，显然无法满足这一特性。执行上一段代码时，将会输出 data 以及 error。

因此，需要对状态进行判断和完善：

    
    
    function Promise(executor) {
      this.status = 'pending'
      this.value = null
      this.reason = null
    
      const resolve = value => {
        if (this.status === 'pending') {
          this.value = value
          this.status = 'fulfilled'
        }
      }
    
      const reject = reason => {
        if (this.status === 'pending') {
          this.reason = reason
          this.status = 'rejected'
        }
      }
    
      executor(resolve, reject)
    }
    
    Promise.prototype.then = function(onfulfilled, onrejected) {
      onfulfilled = typeof onfulfilled === 'function' ? onfulfilled : data => data
      onrejected = typeof onrejected === 'function' ? onrejected : error => {throw error}
    
      if (this.status === 'fulfilled') {
        onfulfilled(this.value)
      }
      if (this.status === 'rejected') {
        onrejected(this.reason)
      }
    }
    

我们看，在 resolve 和 reject 方法中，我们加入判断，只允许 promise 实例状态从 pending 改变为 fulfilled，或者从
pending 改变为 rejected。

同时注意， **这里我们对 Promise.prototype.then 参数 onfulfilled 和 onrejected
进行了判断，当实参不是一个函数类型时，赋予默认函数值** 。这时候的默认值不再是函数元 Function.prototype
了。为什么要这么更改？后面会有介绍。

这样一来，我们的实现显然更加接近真实了。刚才的例子也可以跑通了：

    
    
    let promise = new Promise((resolve, reject) => {
      resolve('data')
      reject('error')
    })
    
    promise.then(data => {
      console.log(data)
    }, error => {
      console.log(error)
    })
    

但是不要高兴得太早，promise 是解决异步问题的，我们的代码全部都是同步执行的，似乎还差了更重要的逻辑。

### Promise 异步完善

到目前为止，实现还差了哪些内容呢？别急，我们再从示例代码分析：

    
    
    let promise = new Promise((resolve, reject) => {
      setTimeout(() => {
        resolve('data')
      }, 2000)
    })
    
    promise.then(data => {
      console.log(data)
    })
    

正常来讲，上述代码会在 2 秒之后输出 data，但是我们实现的代码，并没有输入任何信息。这是为什么呢？

原因很简单，因为我们的实现逻辑全是同步的。在上面实例化一个 promise 的构造函数时，我们是在 setTimeout 逻辑里才调用
resolve，也就是说，2 秒之后才会调用 resolve 方法，也才会去更改 promise 实例状态。而结合我们的实现，返回实现代码，then
方法中的 onfulfilled 执行是同步的，它在执行时 this.status 仍然为 pending，并没有做到“2 秒中之后再执行
onfulfilled”。

那该怎么办呢？我们似乎应该在“合适”的时间才去调用 onfulfilled 方法，这个合适的时间就应该是开发者调用 resolve
的时刻，那么我们先在状态（status）为 pending 时，把开发者传进来的 onfulfilled 方法存起来，在 resolve
方法中再去执行即可：

    
    
    function Promise(executor) {
      this.status = 'pending'
      this.value = null
      this.reason = null
      this.onFulfilledFunc = Function.prototype
      this.onRejectedFunc = Function.prototype
    
      const resolve = value => {
        if (this.status === 'pending') {
          this.value = value
          this.status = 'fulfilled'
    
          this.onFulfilledFunc(this.value)
        }
    
      }
    
      const reject = reason => {
        if (this.status === 'pending') {
          this.reason = reason
          this.status = 'rejected'
    
          this.onRejectedFunc(this.reason)
        }
      }
    
      executor(resolve, reject)
    }
    
    Promise.prototype.then = function(onfulfilled, onrejected) {
      onfulfilled = typeof onfulfilled === 'function' ? onfulfilled : data => data
      onrejected = typeof onrejected === 'function' ? onrejected : error => {throw error}
    
      if (this.status === 'fulfilled') {
        onfulfilled(this.value)
      }
      if (this.status === 'rejected') {
        onrejected(this.reason)
      }
      if (this.status === 'pending') {
        this.onFulfilledFunc = onfulfilled
        this.onRejectedFunc = onrejected
      }
    }
    

测试一下，发现现在我们的实现也可以支持异步了！

同时， **我们知道 Promise 是异步执行的：**

    
    
    let promise = new Promise((resolve, reject) => {
       resolve('data')
    })
    
    promise.then(data => {
      console.log(data)
    })
    console.log(1)
    

正常的话，这里会 **按照顺序** ，输出 1 再输出 data。

而我们的实现，却没有考虑这种情况，先输出 data 再输出 1。因此，需要将 resolve 和 reject 的执行，放到任务队列中。这里姑且先放到
setTimeout 里，保证异步执行（这样的做法并不严谨，为了保证 Promise 属于 microtasks，很多 Promise 的实现库用了
MutationObserver 来模仿 nextTick）。

    
    
    const resolve = value => {
      if (value instanceof Promise) {
        return value.then(resolve, reject)
      }
      setTimeout(() => {
        if (this.status === 'pending') {
          this.value = value
          this.status = 'fulfilled'
    
          this.onFulfilledFunc(this.value)
        }
      })
    }
    
    const reject = reason => {
      setTimeout(() => {
        if (this.status === 'pending') {
          this.reason = reason
          this.status = 'rejected'
    
          this.onRejectedFunc(this.reason)
        }
      })
    }
    
    
    executor(resolve, reject)
    

这样一来，在执行到 executor(resolve, reject) 时，也能保证在 nextTick 中才去执行，不会阻塞同步任务。

同时我们在 resolve 方法中，加入了对 value 值是一个 Promise 实例的判断。看一下到目前为止的实现代码：

    
    
    function Promise(executor) {
      this.status = 'pending'
      this.value = null
      this.reason = null
      this.onFulfilledFunc = Function.prototype
      this.onRejectedFunc = Function.prototype
    
      const resolve = value => {
        if (value instanceof Promise) {
          return value.then(resolve, reject)
        }
        setTimeout(() => {
          if (this.status === 'pending') {
            this.value = value
            this.status = 'fulfilled'
    
            this.onFulfilledFunc(this.value)
          }
        })
      }
    
      const reject = reason => {
        setTimeout(() => {
          if (this.status === 'pending') {
            this.reason = reason
            this.status = 'rejected'
    
            this.onRejectedFunc(this.reason)
          }
        })
      }
    
      executor(resolve, reject)
    }
    
    Promise.prototype.then = function(onfulfilled, onrejected) {
      onfulfilled = typeof onfulfilled === 'function' ? onfulfilled : data => data
      onrejected = typeof onrejected === 'function' ? onrejected : error => {throw error}
    
      if (this.status === 'fulfilled') {
        onfulfilled(this.value)
      }
      if (this.status === 'rejected') {
        onrejected(this.reason)
      }
      if (this.status === 'pending') {
        this.onFulfilledFunc = onfulfilled
        this.onRejectedFunc = onrejected
      }
    }
    

这样的实现：

    
    
    let promise = new Promise((resolve, reject) => {
       resolve('data')
    })
    
    promise.then(data => {
      console.log(data)
    })
    console.log(1)
    

也会 **按照顺序** ，输出 1 再输出 data。

    
    
    let promise = new Promise((resolve, reject) => {
       resolve('data')
    })
    promise.then(data => {
      console.log(data)
    })
    console.log(1)
    

也会 **按照顺序** ，输出 1 再输出 data。

### Promise 细节完善

到此为止，似乎我们的 Promise 实现越来越靠谱了，但是还有些细节需要完善。

比如当我们在 promise 实例状态变更之前，添加多个 then 方法：

    
    
    let promise = new Promise((resolve, reject) => {
      setTimeout(() => {
        resolve('data')
      }, 2000)
    })
    
    promise.then(data => {
      console.log(`1: ${data}`)
    })
    promise.then(data => {
      console.log(`2: ${data}`)
    })
    

应该输出：

    
    
    1: data
    2: data
    

而我们的实现，只会输出 2: data，这是因为第二个 then 方法中的 onFulfilledFunc 会覆盖第一个 then 方法中的
onFulfilledFunc。

这个问题也好解决，只需要将所有 then 方法中的 onFulfilledFunc 储存为一个数组 onFulfilledArray，在 resolve
时，依次执行即可。对于 onRejectedFunc 同理，改动后的实现为：

    
    
    function Promise(executor) {
      this.status = 'pending'
      this.value = null
      this.reason = null
      this.onFulfilledArray = []
      this.onRejectedArray = []
    
      const resolve = value => {
        if (value instanceof Promise) {
          return value.then(resolve, reject)
        }
        setTimeout(() => {
          if (this.status === 'pending') {
            this.value = value
            this.status = 'fulfilled'
    
            this.onFulfilledArray.forEach(func => {
              func(value)
            })
          }
        })
      }
    
      const reject = reason => {
        setTimeout(() => {
          if (this.status === 'pending') {
            this.reason = reason
            this.status = 'rejected'
    
            this.onRejectedArray.forEach(func => {
              func(reason)
            })
          }
        })
      }
    
      executor(resolve, reject)
    }
    
    Promise.prototype.then = function(onfulfilled, onrejected) {
      onfulfilled = typeof onfulfilled === 'function' ? onfulfilled : data => data
      onrejected = typeof onrejected === 'function' ? onrejected : error => {throw error}
    
      if (this.status === 'fulfilled') {
        onfulfilled(this.value)
      }
      if (this.status === 'rejected') {
        onrejected(this.reason)
      }
      if (this.status === 'pending') {
        this.onFulfilledArray.push(onfulfilled)
        this.onRejectedArray.push(onrejected)
      }
    }
    

另外一个细节，在构造函数中如果出错，将会自动触发 promise 实例状态为 rejected，我们用 try...catch 块对 executor
进行包裹：

    
    
    try {
      executor(resolve, reject)
    } catch(e) {
      reject(e)
    }
    

当我们故意写错时：

    
    
    let promise = new Promise((resolve, reject) => {
      setTout(() => {
        resolve('data')
      }, 2000)
    })
    
    promise.then(data => {
      console.log(data)
    }, error => {
      console.log('got error from promise', error)
    })
    

就可以对错误进行处理，捕获到：

    
    
    got error from promise ReferenceError: setTimeouteout is not defined
        at <anonymous>:2:3
        at <anonymous>:33:7
        at o (web-46c6729d4d8cac92aed8.js:1)
    

### 总结

这一小节，我们已经初步实现了基本的 Promise，实现结果固然重要，但是在实现过程中，也加深了对 Promise 的理解，得出了一些重要结论：

  * Promise 状态具有凝固性
  * Promise 错误处理
  * Promise 实例添加多个 then 处理

最后，附上到此为止的全部代码：

    
    
    function Promise(executor) {
      this.status = 'pending'
      this.value = null
      this.reason = null
      this.onFulfilledArray = []
      this.onRejectedArray = []
    
      const resolve = value => {
        if (value instanceof Promise) {
          return value.then(resolve, reject)
        }
        setTimeout(() => {
          if (this.status === 'pending') {
            this.value = value
            this.status = 'fulfilled'
    
            this.onFulfilledArray.forEach(func => {
              func(value)
            })
          }
        })
      }
    
      const reject = reason => {
        setTimeout(() => {
          if (this.status === 'pending') {
            this.reason = reason
            this.status = 'rejected'
    
            this.onRejectedArray.forEach(func => {
              func(reason)
            })
          }
        })
      }
    
    
      try {
        executor(resolve, reject)
      } catch(e) {
        reject(e)
      }
    }
    
    Promise.prototype.then = function(onfulfilled, onrejected) {
      onfulfilled = typeof onfulfilled === 'function' ? onfulfilled : data => data
      onrejected = typeof onrejected === 'function' ? onrejected : error => { throw error}
    
      if (this.status === 'fulfilled') {
        onfulfilled(this.value)
      }
      if (this.status === 'rejected') {
        onrejected(this.reason)
      }
      if (this.status === 'pending') {
        this.onFulfilledArray.push(onfulfilled)
        this.onRejectedArray.push(onrejected)
      }
    }
    

下一讲我们将会继续实现 Promise、处理 Promise 实例的返回问题，以及更多的 Promise 静态方法。

### 分享交流

阅读文章过程中有任何疑问随时可以跟其他小伙伴讨论，或者直接向作者 LucasHC 提问（作者看到后抽空回复）。 **你的分享不仅帮助他人，更会提升自己。**

你也可以说说自己最想了解的主题，课程内容会根据部分读者的意见和建议迭代和完善。

此外，我们为本课程付费读者创建了《前端开发核心知识进阶》微信交流群，以方便更有针对性地讨论课程相关问题。（入群请到第1-2课末尾添加 GitChat
小助手伽利略的微信，并注明「前端核心」，谢谢~）



## 你以为我真的想让你手写 Promise 吗（下）

在上一讲中，我们渐进式地实现了一个貌似能工作的 Promise，并配以实例进行完善。如果你觉得已经接近“大功告成”了，其实这才刚刚开始。Promise
这个概念相对来说比较复杂，下面继续一边研究、一边实现吧。

先来回顾一下这两节课的相关知识点：

![enter image description
here](https://images.gitbook.cn/5089c410-8130-11e9-867f-b5a1456c4340)

话不多说，让我们开始吧。

### 从 Promise then 的链式调用继续谈起

先来看一道题目：

    
    
    const promise = new Promise((resolve, reject) => {
        setTimeout(() => {
          resolve('lucas')
      }, 2000)
    })
    
    promise.then(data => {
      console.log(data)
      return `${data} next then`
    })
    .then(data => {
      console.log(data)
    })
    

这段代码执行后，将会在 2 秒后输出：lucas，紧接着输出：lucas next then。

我们看到，Promise 实例的 then 方法支持链式调用，输出 resolved 值后，如果在 then 方法体 onfulfilled
函数中同步显式返回新的值，将会在新 Promise 实例的 then 方法 onfulfilled 函数中输出新值。

如果在第一个 then 方法体 onfulfilled 函数中返回另一个 Promise 实例 ：

    
    
    const promise = new Promise((resolve, reject) => {
      setTimeout(() => {
          resolve('lucas')
      }, 2000)
    })
    
    promise.then(data => {
      console.log(data)
      return new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve(`${data} next then`)
        }, 4000)
      })
    })
    .then(data => {
      console.log(data)
    })
    

将在 2 秒后输出：lucas，紧接着再过 4 秒后（第 6 秒）输出：lucas next then。

由此可知：

一个 Promise 实例的 then 方法体 onfulfilled 函数和 onrejected 函数中，是支持再次返回一个 Promise
实例的，也支持返回一个非 Promise 实例的普通值；并且返回的这个 Promise 实例或者这个非 Promise 实例的普通值将会传给下一个 then
方法 onfulfilled 函数或者 onrejected 函数中，这样就支持链式调用了。

那我们该怎么实现这种行为呢？

### 链式调用初步实现

让我们来分析一下：为了能够支持 then 方法的链式调用，那么每一个 then 方法的 onfulfilled 函数和 onrejected
函数都应该返回一个 Promise 实例。

我们一步一步来，先实现：

    
    
    const promise = new Promise((resolve, reject) => {
      setTimeout(() => {
          resolve('lucas')
      }, 2000)
    })
    
    promise.then(data => {
      console.log(data)
      return `${data} next then`
    })
    .then(data => {
      console.log(data)
    })
    

这种 onfulfilled 函数返回一个普通值的场景，这里 onfulfilled 函数指的是：

    
    
    data => {
      console.log(data)
      return `${data} next then`
    }
    

在我们上一讲实现的 then 方法中，就可以创建一个新的 promise2 用以返回：

    
    
    Promise.prototype.then = function(onfulfilled, onrejected) {
        onfulfilled = typeof onfulfilled === 'function' ? onfulfilled : data => data
      onrejected = typeof onrejected === 'function' ? onrejected : error => { throw error }
      // promise2 将作为 then 方法的返回值
      let promse2
      if (this.status === 'fulfilled') {
        return promse2 = new Promise((resolve, reject) => {
                setTimeout(() => {
                    try {
                        // 这个新的 promse2 resolved 的值为 onfulfilled 的执行结果
                        let result = onfulfilled(this.value)
                        resolve(result)
                    }
                    catch(e) {
                        reject(e)
                    }
                })
        })
    
      }
      if (this.status === 'rejected') {
        onrejected(this.reason)
      }
      if (this.status === 'pending') {
        this.onFulfilledArray.push(onfulfilled)
        this.onRejectedArray.push(onrejected)
      }
    }
    

当然别忘了 this.status === 'rejected' 状态和 this.status === 'pending' 状态也要加入相同的逻辑：

    
    
    Promise.prototype.then = function(onfulfilled, onrejected) {
      // promise2 将作为 then 方法的返回值
      let promise2
      if (this.status === 'fulfilled') {
        return promise2 = new Promise((resolve, reject) => {
                setTimeout(() => {
                    try {
                        // 这个新的 promise2 resolved 的值为 onfulfilled 的执行结果
                        let result = onfulfilled(this.value)
                        resolve(result)
                    }
                    catch(e) {
                        reject(e)
                    }
                })
        })
      }
      if (this.status === 'rejected') {
        return promise2 = new Promise((resolve, reject) => {
                setTimeout(() => {
                    try {
                        // 这个新的 promise2 reject 的值为 onrejected 的执行结果
                        let result = onrejected(this.value)
                        resolve(result)
                    }
                    catch(e) {
                        reject(e)
                    }
                })
        })
      }
      if (this.status === 'pending') {
        return promise2 = new Promise((resolve, reject) => {
          this.onFulfilledArray.push(() => {
            try {
              let result = onfulfilled(this.value)
              resolve(result)
            }
            catch(e) {
              reject(e)
            }
          })
    
          this.onRejectedArray.push(() => {
            try {
              let result = onrejected(this.reason)
              resolve(result)
            }
            catch(e) {
              reject(e)
            }
          })      
        })
      }
    }
    

这里要重点理解 this.status === 'pending' 判断分支中的逻辑，这也最难理解的。我们先想想：当使用 Promise 实例，调用其
then 方法时，应该返回一个 Promise 实例，返回的就是 this.status === 'pending' 判断分支中返回的
promise2。那么这个 promise2 什么时候被 resolve 或者 reject 呢？应该是在异步结束，依次执行
onFulfilledArray 或者 onRejectedArray 数组中的函数时。

我们再思考，那么 onFulfilledArray 或者 onRejectedArray 数组中的函数应该做些什么呢？很明显，需要将 promise2
的状态切换，并 resolve onfulfilled 函数执行结果或者 reject onrejected 结果。

这也就是我们的改动，将 this.onFulfilledArray.push 的函数由：

    
    
    this.onFulfilledArray.push(onfulfilled)
    

改为：

    
    
    () => {
        setTimeout(() => {
            try {
                let result = onfulfilled(this.value)
                resolve(result)
            }
            catch(e) {
                reject(e)
            }
        })
    }
    

的原因。 this. onRejectedArray.push 的函数的改动点同理。

这非常不容易理解，如果读者仍然想不明白，也不需要着急。还是应该先理解透 Promise，再返回来看，多看几次，一定会有所收获。

请注意，此时 Promise 实现的完整代码为：

    
    
    function Promise(executor) {
      this.status = 'pending'
      this.value = null
      this.reason = null
      this.onFulfilledArray = []
      this.onRejectedArray = []
    
      const resolve = value => {
        if (value instanceof Promise) {
          return value.then(resolve, reject)
        }
        setTimeout(() => {
          if (this.status === 'pending') {
            this.value = value
            this.status = 'fulfilled'
    
            this.onFulfilledArray.forEach(func => {
              func(value)
            })
          }
        })
      }
    
      const reject = reason => {
        setTimeout(() => {
          if (this.status === 'pending') {
            this.reason = reason
            this.status = 'rejected'
    
            this.onRejectedArray.forEach(func => {
              func(reason)
            })
          }
        })
      }
    
    
        try {
            executor(resolve, reject)
        } catch(e) {
            reject(e)
        }
    }
    
    Promise.prototype.then = function(onfulfilled, onrejected) {
      // promise2 将作为 then 方法的返回值
      let promise2
      if (this.status === 'fulfilled') {
        return promise2 = new Promise((resolve, reject) => {
                setTimeout(() => {
                    try {
                        // 这个新的 promise2 resolved 的值为 onfulfilled 的执行结果
                        let result = onfulfilled(this.value)
                        resolve(result)
                    }
                    catch(e) {
                        reject(e)
                    }
                })
        })
      }
      if (this.status === 'rejected') {
        return promise2 = new Promise((resolve, reject) => {
                setTimeout(() => {
                    try {
                        // 这个新的 promise2 reject 的值为 onrejected 的执行结果
                        let result = onrejected(this.value)
                        resolve(result)
                    }
                    catch(e) {
                        reject(e)
                    }
                })
        })
      }
      if (this.status === 'pending') {
        return promise2 = new Promise((resolve, reject) => {
          this.onFulfilledArray.push(() => {
            try {
              let result = onfulfilled(this.value)
              resolve(result)
            }
            catch(e) {
              reject(e)
            }
          })
    
          this.onRejectedArray.push(() => {
            try {
              let result = onrejected(this.reason)
              resolve(result)
            }
            catch(e) {
              reject(e)
            }
          })      
        })
      }
    }
    

### 链式调用实现完善

我们继续来实现 then 方法显式返回一个 Promise 实例的情况。对应场景：

    
    
    const promise = new Promise((resolve, reject) => {
      setTimeout(() => {
          resolve('lucas')
      }, 2000)
    })
    
    promise.then(data => {
      console.log(data)
      return new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve(`${data} next then`)
        }, 4000)
      })
    })
    .then(data => {
      console.log(data)
    })
    

对比第一种情况（ onfulfilled 函数和 onrejected 函数返回一个普通值的情况），实现这种 onfulfilled 函数和
onrejected 函数返回一个 Promise 实例也并不困难。但是我们需要小幅度重构一下代码，在上面实现的 let result =
onfulfilled(this.value) 语句和 let result = onrejected(this.reason) 语句中，变量 result
由一个普通值会成为一个 Promise 实例。换句话说就是：变量 result 既可以是一个普通值，也可以是一个 Promise 实例，为此我们抽象出
resolvePromise 方法进行统一处理。改动已有实现为：

    
    
    const resolvePromise = (promise2, result, resolve, reject) => {
    
    }
    
    Promise.prototype.then = function(onfulfilled, onrejected) {
      // promise2 将作为 then 方法的返回值
      let promise2
      if (this.status === 'fulfilled') {
        return promise2 = new Promise((resolve, reject) => {
                setTimeout(() => {
                    try {
                        //这个新的 promise2 resolved 的值为 onfulfilled 的执行结果
                        let result = onfulfilled(this.value)
                        resolvePromise(promise2, result, resolve, reject)
                    }
                    catch(e) {
                        reject(e)
                    }
                })
        })
      }
      if (this.status === 'rejected') {
        return promise2 = new Promise((resolve, reject) => {
                setTimeout(() => {
                    try {
                        //这个新的 promise2 reject 的值为 onrejected 的执行结果
                        let result = onrejected(this.value)
                     resolvePromise(promise2, result, resolve, reject)
                    }
                    catch(e) {
                        reject(e)
                    }
                })
        })
      }
      if (this.status === 'pending') {
        return promise2 = new Promise((resolve, reject) => {
          this.onFulfilledArray.push(value => {
            try {
              let result = onfulfilled(value)
              resolvePromise(promise2, result, resolve, reject)
            }
            catch(e) {
              reject(e)
            }
          })
    
          this.onRejectedArray.push(reason => {
            try {
              let result = onrejected(reason)
              resolvePromise(promise2, result, resolve, reject)
            }
            catch(e) {
              reject(e)
            }
          })      
        })
      }
    }
    

现在的任务就是完成 resolvePromise 函数，这个函数接受四个参数：

  * promise2: 返回的 Promise 实例
  * result: onfulfilled 或者 onrejected 函数的返回值
  * resolve: promise2 的 resolve 方法
  * reject: promise2 的 reject 方法

有了这些参数，我们就具备了抽象逻辑的必备条件。接下来就是动手实现：

    
    
    const resolvePromise = (promise2, result, resolve, reject) => {
      // 当 result 和 promise2 相等时，也就是说 onfulfilled 返回 promise2 时，进行 reject
      if (result === promise2) {
        reject(new TypeError('error due to circular reference'))
      }
    
      // 是否已经执行过 onfulfilled 或者 onrejected
      let consumed = false
      let thenable
    
      if (result instanceof Promise) {
        if (result.status === 'pending') {
          result.then(function(data) {
            resolvePromise(promise2, data, resolve, reject)
          }, reject)
        } else {
          result.then(resolve, reject)
        }
        return
      }
    
      let isComplexResult = target => (typeof target === 'function' || typeof target === 'object') && (target !== null)
    
      // 如果返回的是疑似 Promise 类型
      if (isComplexResult(result)) {
        try {
          thenable = result.then
          // 如果返回的是 Promise 类型，具有 then 方法
          if (typeof thenable === 'function') {
            thenable.call(result, function(data) {
              if (consumed) {
                return
              }
              consumed = true
    
              return resolvePromise(promise2, data, resolve, reject)
            }, function(error) {
              if (consumed) {
                return
              }
              consumed = true
    
              return reject(error)
            })
          }
          else {
            resolve(result)
          }
    
        } catch(e) {
          if (consumed) {
            return
          }
          consumed = true
          return reject(e)
        }
      }
      else {
        resolve(result)
      }
    }
    

我们看 resolvePromise 方法第一步进行了以“死循环”的处理。并在发生死循环是，reject 掉，错误信息为 new
TypeError('error due to circular reference')。怎么理解这个处理呢，规范中为我们指出：

![enter image description
here](https://images.gitbook.cn/65a8bbf0-8129-11e9-95af-d396387f5d0e)

其实出现“死循环”的情况如下：

    
    
    const promise = new Promise((resolve, reject) => {
      setTimeout(() => {
          resolve('lucas')
      }, 2000)
    })
    
    promise.then(onfulfilled = data => {
      console.log(data)
      return onfulfilled(data)
    })
    .then(data => {
      console.log(data)
    })
    

接着，对于 onfulfilled 函数返回的结果 result：如果 result 非 Promise
实例，非对象，非函数类型，是一个普通值的话（上述代码中 isComplexResult 函数进行判断），我们直接将 promise2 以该值 resolve
掉。

对于 onfulfilled 函数返回的结果 result：如果 result 含有 then 属性方法，我们称该属性方法为 thenable，说明
result 是一个 Promise 实例，我们执行该实例的 then 方法（既 thenable），此时的返回结果有可能又是一个 Promise
实例类型，也可能是一个普通值，因此还要递归调用 resolvePromise。如果读者还是不明白这里为什么需要递归调用
resolvePromise，可以看代码例子：

    
    
    const promise = new Promise((resolve, reject) => {
      setTimeout(() => {
          resolve('lucas')
      }, 2000)
    })
    
    promise.then(data => {
      console.log(data)
      return new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve(`${data} next then`)
        }, 4000)
      })
      .then(data => {
        return new Promise((resolve, reject) => {
          setTimeout(() => {
              resolve(`${data} next then`)
          }, 4000)
        })
      })
    })
    .then(data => {
      console.log(data)
    })
    

该段代码将会在 2 秒是输出：lucas，10 秒时输出：lucas next then next then。

此时我们的 Promise 实现的完整代码为：

    
    
    function Promise(executor) {
      this.status = 'pending'
      this.value = null
      this.reason = null
      this.onFulfilledArray = []
      this.onRejectedArray = []
    
      const resolve = value => {
        if (value instanceof Promise) {
          return value.then(resolve, reject)
        }
        setTimeout(() => {
          if (this.status === 'pending') {
            this.value = value
            this.status = 'fulfilled'
    
            this.onFulfilledArray.forEach(func => {
              func(value)
            })
          }
        })
      }
    
      const reject = reason => {
        setTimeout(() => {
          if (this.status === 'pending') {
            this.reason = reason
            this.status = 'rejected'
    
            this.onRejectedArray.forEach(func => {
              func(reason)
            })
          }
        })
      }
    
    
        try {
            executor(resolve, reject)
        } catch(e) {
            reject(e)
        }
    }
    
    const resolvePromise = (promise2, result, resolve, reject) => {
      // 当 result 和 promise2 相等时，也就是说 onfulfilled 返回 promise2 时，进行 reject
      if (result === promise2) {
        reject(new TypeError('error due to circular reference'))
      }
    
      // 是否已经执行过 onfulfilled 或者 onrejected
      let consumed = false
      let thenable
    
      if (result instanceof Promise) {
        if (result.status === 'pending') {
          result.then(function(data) {
            resolvePromise(promise2, data, resolve, reject)
          }, reject)
        } else {
          result.then(resolve, reject)
        }
        return
      }
    
      let isComplexResult = target => (typeof target === 'function' || typeof target === 'object') && (target !== null)
    
      // 如果返回的是疑似 Promise 类型
      if (isComplexResult(result)) {
        try {
          thenable = result.then
          // 如果返回的是 Promise 类型，具有 then 方法
          if (typeof thenable === 'function') {
            thenable.call(result, function(data) {
              if (consumed) {
                return
              }
              consumed = true
    
              return resolvePromise(promise2, data, resolve, reject)
            }, function(error) {
              if (consumed) {
                return
              }
              consumed = true
    
              return reject(error)
            })
          }
          else {
            resolve(result)
          }
    
        } catch(e) {
          if (consumed) {
            return
          }
          consumed = true
          return reject(e)
        }
      }
      else {
        resolve(result)
      }
    }
    
    Promise.prototype.then = function(onfulfilled, onrejected) {
      onfulfilled = typeof onfulfilled === 'function' ? onfulfilled : data => data
      onrejected = typeof onrejected === 'function' ? onrejected : error => { throw error }
    
      // promise2 将作为 then 方法的返回值
      let promise2
    
      if (this.status === 'fulfilled') {
        return promise2 = new Promise((resolve, reject) => {
          setTimeout(() => {
            try {
              // 这个新的 promise2 resolved 的值为 onfulfilled 的执行结果
              let result = onfulfilled(this.value)
              resolvePromise(promise2, result, resolve, reject)
            }
            catch(e) {
              reject(e)
            }
          })
        })
      }
      if (this.status === 'rejected') {
        return promise2 = new Promise((resolve, reject) => {
          setTimeout(() => {
            try {
              // 这个新的 promise2 reject 的值为 onrejected 的执行结果
             let result = onrejected(this.reason)
             resolvePromise(promise2, result, resolve, reject)
            }
            catch(e) {
              reject(e)
            }
          })
        })
      }
      if (this.status === 'pending') {
        return promise2 = new Promise((resolve, reject) => {
          this.onFulfilledArray.push(value => {
            try {
              let result = onfulfilled(value)
              resolvePromise(promise2, result, resolve, reject)
            }
            catch(e) {
              reject(e)
            }
          })
    
          this.onRejectedArray.push(reason => {
            try {
              let result = onrejected(reason)
              resolvePromise(promise2, result, resolve, reject)
            }
            catch(e) {
              reject(e)
            }
          })      
        })
      }
    }
    

### Promise 穿透实现

到这里，读者可以松口气，我们的 Promise 基本实现除了静态方法以外，已经完成了 95%。为什么不是 100% 呢？其实还有一处细节，我们看代码：

    
    
    const promise = new Promise((resolve, reject) => {
      setTimeout(() => {
          resolve('lucas')
      }, 2000)
    })
    
    
    promise.then(null)
    .then(data => {
      console.log(data)
    })
    

这段代码将会在 2 秒后输出：lucas。这就是 Promise 穿透现象：

给 .then() 函数传递非函数值作为其参数时，实际上会被解析成 .then(null)，这时候的表现应该是：上一个 promise
对象的结果进行“穿透”，如果在后面链式调用仍存在第二个 .then() 函数时，将会获取被穿透下来的结果。

那该如何实现 Promise 穿透呢？

其实很简单，并且我们已经做到了。想想在 then() 方法的实现中：我们已经对 onfulfilled 和 onrejected 函数加上判断：

    
    
    Promise.prototype.then = function(onfulfilled = Function.prototype, onrejected = Function.prototype) {
      onfulfilled = typeof onfulfilled === 'function' ? onfulfilled : data => data
      onrejected = typeof onrejected === 'function' ? onrejected : error => { throw error }
    
        // ...
    }
    

如果 onfulfilled 不是函数类型，则给一个默认值，该默认值是返回其参数的函数。onrejected
函数同理。这段逻辑，就是起到了实现“穿透”的作用。

### Promise 静态方法和其他方法实现

这一部分，我们将实现：

  * Promise.prototype.catch
  * Promise.resolve，Promise.reject
  * Promise.all
  * Promise.race

#### Promise.prototype.catch 实现

Promise.prototype.catch 可以进行异常捕获，它的典型用法：

    
    
    const promise1 = new Promise((resolve, reject) => {
      setTimeout(() => {
          reject('lucas error')
      }, 2000)
    })
    
    promise1.then(data => {
      console.log(data)
    }).catch(error => {
      console.log(error)
    })
    

会在 2 秒后输出：lucas error。

其实在这种场景下，它就相当于：

    
    
    Promise.prototype.catch = function(catchFunc) {
      return this.then(null, catchFunc)
    }
    

因为我们知道 .then() 方法的第二个参数也是进行异常捕获的，通过这个特性，我们比较简单地实现了 Promise.prototype.catch。

#### Promise.prototype.resolve 实现

MDN 上对于 Promise.resolve(value) 方法的介绍：

> Promise.resolve(value) 方法返回一个以给定值解析后的 Promise 实例对象。

请看实例：

    
    
    Promise.resolve('data').then(data => {
      console.log(data)
    })
    console.log(1)
    

先输出 1 再输出 data。

那么实现 Promise.resolve(value) 也很简单：

    
    
    Promise.resolve = function(value) {
      return new Promise((resolve, reject) => {
        resolve(value)
      })
    }
    

顺带实现一个 Promise.reject(value)：

    
    
    Promise.reject = function(value) {
      return new Promise((resolve, reject) => {
        reject(value)
      })
    }
    

#### Promise.all 实现

MDN 关于 的解释：

> Promise.all(iterable) 方法返回一个 Promise 实例，此实例在 iterable 参数内所有的 promise
都“完成（resolved）”或参数中不包含 promise 时回调完成（resolve）；如果参数中 promise
有一个失败（rejected），此实例回调失败（reject），失败原因的是第一个失败 promise 的结果。

还是看实例体会一下：

    
    
    const promise1 = new Promise((resolve, reject) => {
      setTimeout(() => {
          resolve('lucas')
      }, 2000)
    })
    
    const promise2 = new Promise((resolve, reject) => {
      setTimeout(() => {
          resolve('lucas')
      }, 2000)
    })
    
    Promise.all([promise1, promise2]).then(data => {
      console.log(data)
    })
    

将在 2 秒后输出：["lucas", "lucas"]。

实现思路也很简单：

    
    
    Promise.all = function(promiseArray) {
      if (!Array.isArray(promiseArray)) {
          throw new TypeError('The arguments should be an array!')
      }
      return new Promise((resolve, reject) => {
        try {
          let resultArray = []
    
          const length = promiseArray.length
    
          for (let i = 0; i <length; i++) {
            promiseArray[i].then(data => {
              resultArray.push(data)
    
              if (resultArray.length === length) {
                resolve(resultArray)
              }
            }, reject)
          }
        }
        catch(e) {
          reject(e)
        }
      })
    }
    

我们先进行了对参数 promiseArray 的类型判断，对于非数组类型参数，进行抛错。Promise.all 会返回一个 Promise
实例，这个实例将会在 promiseArray 中的所有 Promise 实例 resolve 后进行 resolve，且 resolve
的值是一个数组，这个数组存有 promiseArray 中的所有 Promise 实例 resolve 的值。

整体思路依赖一个 for 循环对 promiseArray 进行遍历。同样按照这个思路，我们对 Promise.race 进行实现。

#### Promise.race 实现

还是先来看一下 Promise.race 的用法。

    
    
    const promise1 = new Promise((resolve, reject) => {
      setTimeout(() => {
          resolve('lucas1')
      }, 2000)
    })
    
    const promise2 = new Promise((resolve, reject) => {
      setTimeout(() => {
          resolve('lucas2')
      }, 4000)
    })
    
    Promise.race([promise1, promise2]).then(data => {
      console.log(data)
    })
    

将会在 2 秒后输出：lucas1，实现 Promise.race 为：

    
    
    Promise.race = function(promiseArray) {
      if (!Array.isArray(promiseArray)) {
          throw new TypeError('The arguments should be an array!')
      }
      return new Promise((resolve, reject) => {
        try {
              const length = promiseArray.length
          for (let i = 0; i <length; i++) {
            promiseArray[i].then(resolve, reject)
          }
        }
        catch(e) {
          reject(e)
        }
      })
    }
    

我们来简单分析一下，这里使用 for 循环同步执行 promiseArray 数组中的所有 promise 实例 then 方法，第一个 resolve
的实例直接会触发新 Promise（代码中新 new 出来的） 实例的 resolve 方法。

### 总结

这两节课，相信读者通过对 Promise 实现的学习，对 Promise 这个概念的理解大大加深。其实，实现一个 Promise 不是目的，并且这个
Promise 实现也没有完全 100%
遵循规范，我们更加应该掌握概念，融会贯通。另外，整体来看，这部分内容不好理解，如果暂时难以接受全部概念，也不要灰心。实现的代码就在那里，我们要有决心慢慢地掌握它。

最终把所有的实现放在一起：

    
    
    function Promise(executor) {
      this.status = 'pending'
      this.value = null
      this.reason = null
      this.onFulfilledArray = []
      this.onRejectedArray = []
    
      const resolve = value => {
        if (value instanceof Promise) {
          return value.then(resolve, reject)
        }
        setTimeout(() => {
          if (this.status === 'pending') {
            this.value = value
            this.status = 'fulfilled'
    
            this.onFulfilledArray.forEach(func => {
              func(value)
            })
          }
        })
      }
    
      const reject = reason => {
        setTimeout(() => {
          if (this.status === 'pending') {
            this.reason = reason
            this.status = 'rejected'
    
            this.onRejectedArray.forEach(func => {
              func(reason)
            })
          }
        })
      }
    
    
        try {
            executor(resolve, reject)
        } catch(e) {
            reject(e)
        }
    }
    
    const resolvePromise = (promise2, result, resolve, reject) => {
      // 当 result 和 promise2 相等时，也就是说 onfulfilled 返回 promise2 时，进行 reject
      if (result === promise2) {
        return reject(new TypeError('error due to circular reference'))
      }
    
      // 是否已经执行过 onfulfilled 或者 onrejected
      let consumed = false
      let thenable
    
      if (result instanceof Promise) {
        if (result.status === 'pending') {
          result.then(function(data) {
            resolvePromise(promise2, data, resolve, reject)
          }, reject)
        } else {
          result.then(resolve, reject)
        }
        return
      }
    
      let isComplexResult = target => (typeof target === 'function' || typeof target === 'object') && (target !== null)
      // 如果返回的是疑似 Promise 类型
      if (isComplexResult(result)) {
        try {
          thenable = result.then
          // 如果返回的是 Promise 类型，具有 then 方法
          if (typeof thenable === 'function') {
            thenable.call(result, function(data) {
              if (consumed) {
                return
              }
              consumed = true
    
              return resolvePromise(promise2, data, resolve, reject)
            }, function(error) {
              if (consumed) {
                return
              }
              consumed = true
    
              return reject(error)
            })
          }
          else {
            return resolve(result)
          }
    
        } catch(e) {
          if (consumed) {
            return
          }
          consumed = true
          return reject(e)
        }
      }
      else {
        return resolve(result)
      }
    }
    
    Promise.prototype.then = function(onfulfilled, onrejected) {
      onfulfilled = typeof onfulfilled === 'function' ? onfulfilled : data => data
      onrejected = typeof onrejected === 'function' ? onrejected : error => {throw error}
    
      // promise2 将作为 then 方法的返回值
      let promise2
    
      if (this.status === 'fulfilled') {
        return promise2 = new Promise((resolve, reject) => {
          setTimeout(() => {
            try {
              // 这个新的 promise2 resolved 的值为 onfulfilled 的执行结果
              let result = onfulfilled(this.value)
              resolvePromise(promise2, result, resolve, reject)
            }
            catch(e) {
              reject(e)
            }
          })
        })
      }
      if (this.status === 'rejected') {
        return promise2 = new Promise((resolve, reject) => {
          setTimeout(() => {
            try {
              // 这个新的 promise2 reject 的值为 onrejected 的执行结果
             let result = onrejected(this.reason)
             resolvePromise(promise2, result, resolve, reject)
            }
            catch(e) {
              reject(e)
            }
          })
        })
      }
      if (this.status === 'pending') {
        return promise2 = new Promise((resolve, reject) => {
          this.onFulfilledArray.push(value => {
            try {
              let result = onfulfilled(value)
              resolvePromise(promise2, result, resolve, reject)
            }
            catch(e) {
              return reject(e)
            }
          })
    
          this.onRejectedArray.push(reason => {
            try {
              let result = onrejected(reason)
              resolvePromise(promise2, result, resolve, reject)
            }
            catch(e) {
              return reject(e)
            }
          })      
        })
      }
    }
    
    Promise.prototype.catch = function(catchFunc) {
      return this.then(null, catchFunc)
    }
    
    Promise.resolve = function(value) {
      return new Promise((resolve, reject) => {
        resolve(value)
      })
    }
    
    Promise.reject = function(value) {
      return new Promise((resolve, reject) => {
        reject(value)
      })
    }
    
    Promise.race = function(promiseArray) {
      if (!Array.isArray(promiseArray)) {
          throw new TypeError('The arguments should be an array!')
      }
      return new Promise((resolve, reject) => {
        try {
          const length = promiseArray.length
          for (let i = 0; i <length; i++) {
            promiseArray[i].then(resolve, reject)
          }
        }
        catch(e) {
          reject(e)
        }
      })
    }
    
    Promise.all = function(promiseArray) {
      if (!Array.isArray(promiseArray)) {
          throw new TypeError('The arguments should be an array!')
      }
      return new Promise((resolve, reject) => {
        try {
          let resultArray = []
    
          const length = promiseArray.length
    
          for (let i = 0; i <length; i++) {
            promiseArray[i].then(data => {
              resultArray.push(data)
    
              if (resultArray.length === length) {
                resolve(resultArray)
              }
            }, reject)
          }
        }
        catch(e) {
          reject(e)
        }
      })
    }
    

### 分享交流

阅读文章过程中有任何疑问随时可以跟其他小伙伴讨论，或者直接向作者 LucasHC 提问（作者看到后抽空回复）。 **你的分享不仅帮助他人，更会提升自己。**

你也可以说说自己最想了解的主题，课程内容会根据部分读者的意见和建议迭代和完善。

此外，我们为本课程付费读者创建了《前端开发核心知识进阶》微信交流群，以方便更有针对性地讨论课程相关问题（入群请到第1-2课末尾添加 GitChat
小助手伽利略的微信，并注明「前端核心」，谢谢~）



## 面向对象和原型——永不过时的话题

“对象”——这个概念在编程中非常重要，任何语言和领域的开发者都应该具有面向对象思维，能够有效运用对象。良好的面向对象系统设计将是应用强健性、可维护性和可扩展性的关键；反之，如果面向对象环节有失误，那么将是项目的灾难。

说到 JavaScript 面向对象，它实质是基于原型的对象系统，而不是基于类的。这是由设计之初所决定的，是基因层面的。随着 ES Next
标准的进化和新特性的添加，使得 JavaScript
面向对象更加贴近其他传统面向对象型语言。有幸目睹语言的发展和变迁，伴随着某个语言的成长，我认为是开发者之幸。

这一讲就让我们深入对象和原型，理解 JavaScript 在这个方向上的能力。请注意，
**我们不再过多赘述基础，而是面向进阶，需要读者具有一定的知识准备。**

相关知识点如下：

![](https://images.gitbook.cn/5052ad30-829e-11e9-8efd-6b08a473483f)

### 实现 new 没有那么容易

说起 JavaScript 当中的 new 关键字，有一段很有趣的历史。其实 JavaScript 创造者 Brendan Eich 实现 new
是为了获得更高的流行度，它是强行学习 Java 的一个残留产出，他想让 JavaScript 成为 Java 的小弟。很多人认为这个设计掩盖了
JavaScript 中真正的原型继承，只是表面上看，更像是基于类的继承。

这样的误会使得很多传统 Java 开发者并不能很好理解 JavaScript。实际上，我们前端工程师应该明白，new 关键字到底做了什么事情。

  * step1：首先创建一个空对象，这个对象将会作为执行 new 构造函数() 之后，返回的对象实例
  * step2：将上面创建的空对象的原型（`__proto__`），指向构造函数的 prototype 属性
  * step3：将这个空对象赋值给构造函数内部的 this，并执行构造函数逻辑
  * step4：根据构造函数执行逻辑，返回第一步创建的对象或者构造函数的显式返回值

因为 new 是 JavaScript 的关键字，我们不能直接覆盖，实现一个 newFunc 来进行模拟，预计使用方式：

    
    
    function Person(name) {
      this.name = name
    }
    
    const person = new newFunc(Person, 'lucas')
    
    console.log(person)
    
    // {name: "lucas"}
    

实现为：

    
    
    function newFunc(...args) {
      // 取出 args 数组第一个参数，即目标构造函数
      const constructor = args.shift()
    
      // 创建一个空对象，且这个空对象继承构造函数的 prototype 属性
      // 即实现 obj.__proto__ === constructor.prototype
      const obj = Object.create(constructor.prototype)
    
      // 执行构造函数，得到构造函数返回结果
      // 注意这里我们使用 apply，将构造函数内的 this 指向为 obj
      const result = constructor.apply(obj, args)
    
      // 如果造函数执行后，返回结果是对象类型，就直接返回，否则返回 obj 对象
      return (typeof result === 'object' && result != null) ? result : obj
    }
    

上述代码并不复杂，几个关键点：

  * 使用 Object.create 将 obj 的 `__proto__` 指向为构造函数的原型
  * 使用 apply 方法，将构造函数内的 this 指向为 obj
  * 在 newFunc 返回时，使用三目运算符决定返回结果

我们知道，构造函数如果有显式返回值，且返回值为对象类型，那么构造函数返回结果不再是目标实例。如下代码：

    
    
    function Person(name) {
      this.name = name
      return {1: 1}
    }
    
    const person = new Person(Person, 'lucas')
    
    console.log(person)
    
    // {1: 1}
    

了解这些注意点，对于理解 newFunc 的实现就不再困难。

### 如何优雅地实现继承

实现继承式是面向对象的一个重点概念。我们前面提到过 JavaScript 的面向对象系统是基于原型的，它的继承不同于其他大多数语言。

社区上对于 JavaScript 继承讲解的资料不在少数，这里我不再赘述每一种继承方式的实现过程，还需要开发者事先进行了解。

#### ES5 相对可用的继承方案

我们仅总结以下 JavaScript 中实现继承的关键点。

如果想使 Child 继承 Parent，那么

  * 原型链实现继承最关键的要点是：

    
    
    Child.prototype = new Parent()
    

这样的实现，不同的 Child 实例的 `__proto__` 会引用同一 Parent 的实例。

  * 构造函数实现继承的要点是：

    
    
    function Child (args) {
        // ...
        Parent.call(this, args)
    }
    

这样的实现问题也比较大，其实只是实现了实例属性继承，Parent 原型的方法在 Child 实例中并不可用。

  * 组合继承的实现才基本可用，其要点是：

    
    
    function Child (args1, args2) {
        // ...
        this.args2 = args2
        Parent.call(this, args1)
    }
    Child.prototype = new Parent()
    Child.prototype.constrcutor = Child
    

它的问题在于 Child 实例会存在 Parent 的实例属性。因为我们在 Child 构造函数中执行了 Parent
构造函数。同时，`Child.__proto__` 也会存在同样的 Parent 的实例属性，且所有 Child 实例的 `__proto__`
指向同一内存地址。

  * 同时上述实现也都没有对静态属性的继承

还有一些其他不完美的继承方式，我们这里不再过多介绍。

一个比较完整的实现为：

    
    
    function inherit(Child, Parent) {
         // 继承原型上的属性 
        Child.prototype = Object.create(Parent.prototype)
    
         // 修复 constructor
        Child.prototype.constructor = Child
    
        // 存储超类
        Child.super = Parent
    
        // 静态属性继承
        if (Object.setPrototypeOf) {
            // setPrototypeOf es6
            Object.setPrototypeOf(Child, Parent)
        } else if (Child.__proto__) {
            // __proto__ es6 引入，但是部分浏览器早已支持
            Child.__proto__ = Parent
        } else {
            // 兼容 IE10 等陈旧浏览器
            // 将 Parent 上的静态属性和方法拷贝一份到 Child 上，不会覆盖 Child 上的方法
            for (var k in Parent) {
                if (Parent.hasOwnProperty(k) && !(k in Child)) {
                    Child[k] = Parent[k]
                }
            }
        }
    
    }
    

上面静态属性继承存在一个问题：在陈旧浏览器中，属性和方法的继承我们是静态拷贝的，继承完后续父类的改动不会自动同步到子类。这是不同于正常面向对象思想的。但是这种组合式继承，已经相对完美、优雅。

#### 继承 Date

值得一提的一个小细节是：这种继承方式无法实现对 Date 对象的继承。我们来进行测试：

    
    
    function DateConstructor() {
        Date.apply(this, arguments)
        this.foo = 'bar'
    }
    
    inherit(DateConstructor, Date)
    
    DateConstructor.prototype.getMyTime = function() {
        return this.getTime()
    };
    
    
    let date = new DateConstructor()
    
    console.log(date.getMyTime())
    

将会得到报错：Uncaught TypeError: this is not a Date object.

究其原因，是因为： **JavaScript 的日期对象只能通过 JavaScript Date 作为构造函数来实例化得到。**

因此 v8 引擎实现代码中就一定有所限制，如果发现调用 getTime() 方法的对象不是 Date 构造函数构造出来的实例，则抛出错误。

那么如何实现对 Date 的继承呢？

    
    
    function DateConstructor() {
        var dateObj = new(Function.prototype.bind.apply(Date, [Date].concat(Array.prototype.slice.call(arguments))))()
    
        Object.setPrototypeOf(dateObj, DateConstructor.prototype)
    
        dateObj.foo = 'bar'
    
        return dateObj
    }
    
    Object.setPrototypeOf(DateConstructor.prototype, Date.prototype)
    
    DateConstructor.prototype.getMyTime = function getTime() {
        return this.getTime()
    }
    
    let date = new DateConstructor()
    
    console.log(date.getMyTime())
    

我们来分析一下代码：调用构造函数 DateConstructor 返回的对象 dateObj 有：

    
    
    dateObj.__proto__ === DateConstructor.prototype
    

而我们通过：

    
    
    Object.setPrototypeOf(DateConstructor.prototype, Date.prototype)
    

实现了：

    
    
    DateConstructor.prototype.__proto__ === Date.prototype
    

因此连起来就是：

    
    
    date.__proto__.__proto__ === Date.prototype
    

继续分析，DateConstructor 构造函数里，返回的 dateObj 是一个真正的 Date 对象，因为：

    
    
    var dateObj = new(Function.prototype.bind.apply(Date, [Date].concat(Array.prototype.slice.call(arguments))))()var dateObj = new(Function.prototype.bind.apply(Date, [Date].concat(Array.prototype.slice.call(arguments))))()
    

它终归还是由 Date 构造函数实例化出来，因此它有权调用 Date 原型上的方法，而不会被引擎所限制。

整个实现过程通过更改原型关系，在构造函数里调用原生构造函数
Date，并返回其实例的方法，“欺骗了”浏览器。当然这样的做法比较取巧，其副作用是更改了原型关系，这样也会干扰浏览器某些优化操作。

那么有没有更加“体面”的方式呢？

其实随着 ES6 class 的推出，我们完全可以直接使用 extends 关键字了：

    
    
    class DateConstructor extends Date {
        constructor() {
            super()
            this.foo ='bar'
        }
        getMyTime() {
            return this.getTime()
        }
    }
    
    let date = new DateConstructor()
    

上面的方法可以完美执行：

    
    
    date.getMyTime()
    // 1558921640586
    

直接在支持 ES6 class 的浏览器中完全没有问题。可是我们项目大部分都是使用 Babel 进行编译。按照上一讲 Babel 编译 class
的方法，运行其产出后，仍然会得到报错：Uncaught TypeError: this is not a Date object.，因此我们得知：Babel
并没有对继承 Date 进行特殊处理，无法做到兼容。

#### ES6 实现继承剖析

在 ES6 时代，我们可以使用 class extends 进行继承。但是我们都知道 ES6 的 class 其实也就是 ES5 原型的语法糖。我们通过研究
Babel 编译结果，来深入了解一下。

首先，我们定义一个父类：

    
    
    class Person {
        constructor(){
            this.type = 'person'
        }
    }
    

这个类包含了一个实例属性。

然后，实现一个 Student 类，这个“学生”类继承“人”类：

    
    
    class Student extends Person {
        constructor(){
            super()
        }
    }
    

从简出发，我们定义的 Person 类只包含了 type 为 person 的这一个属性，不含有方法。我们 Student 类也继承了同样的属性。

如下：

    
    
    var student1 = new Student()
    student1.type // "person"
    

我们进一步可以验证原型链上的关系：

    
    
    student1 instanceof Student // true
    student1 instanceof Person // true
    student1.hasOwnProperty('type') // true
    

那么，经过 Babel 编译，我们的代码是什么样呢？

一步一步来看：

    
    
    class Person {
        constructor(){
            this.type = 'person'
        }
    }
    

被编译为：

    
    
    var Person = function Person() {
        _classCallCheck(this, Person);
        this.type = 'person';
    };
    

我们看到其实还是构造函数那一套。

    
    
    class Student extends Person {
        constructor(){
            super()
        }
    }
    

编译结果：

    
    
    // 实现定义 Student 构造函数，它是一个自执行函数，接受父类构造函数为参数
    var Student = (function(_Person) {
        // 实现对父类原型链属性的继承
        _inherits(Student, _Person);
    
        // 将会返回这个函数作为完整的 Student 构造函数
        function Student() {
            // 使用检测
            _classCallCheck(this, Student);  
            // _get 的返回值可以先理解为父类构造函数       
            _get(Object.getPrototypeOf(Student.prototype), 'constructor', this).call(this);
        }
    
        return Student;
    })(Person);
    
    // _x为Student.prototype.__proto__
    // _x2为'constructor'
    // _x3为this
    var _get = function get(_x, _x2, _x3) {
        var _again = true;
        _function: while (_again) {
            var object = _x,
                property = _x2,
                receiver = _x3;
            _again = false;
            // Student.prototype.__proto__为null的处理
            if (object === null) object = Function.prototype;
            // 以下是为了完整复制父类原型链上的属性，包括属性特性的描述符
            var desc = Object.getOwnPropertyDescriptor(object, property);
            if (desc === undefined) {
                var parent = Object.getPrototypeOf(object);
                if (parent === null) {
                    return undefined;
                } else {
                    _x = parent;
                    _x2 = property;
                    _x3 = receiver;
                    _again = true;
                    desc = parent = undefined;
                    continue _function;
                }
            } else if ('value' in desc) {
                return desc.value;
            } else {
                var getter = desc.get;
                if (getter === undefined) {
                    return undefined;
                }
                return getter.call(receiver);
            }
        }
    };
    
    function _inherits(subClass, superClass) {
        // superClass 需要为函数类型，否则会报错
        if (typeof superClass !== 'function' && superClass !== null) {
            throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);
        }
        // Object.create 第二个参数是为了修复子类的 constructor
        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        // Object.setPrototypeOf 是否存在做了一个判断，否则使用 __proto__
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    

我们进行拆解：

    
    
    var Student = (function(_Person) {
        _inherits(Student, _Person);
    
        function Student() {
            _classCallCheck(this, Student);            
            _get(Object.getPrototypeOf(Student.prototype), 'constructor', this).call(this);
        }
    
        return Student;
    })(Person);
    

这是一个自执行函数，它接受一个参数 Person（就是它要继承的父类），返回一个构造函数 Student。

上面 `_inherits` 方法的本质其实就是让 Student 子类继承 Person 父类原型链上的方法。它的实现原理可以归结为一句话：

    
    
    Student.prototype = Object.create(Person.prototype);
    Object.setPrototypeOf(Student, Person)
    

是不是这就非常熟悉了。注意，Object.create 接收了第二个参数，这顺带实现了对 Student 的 constructor 修复。

以上通过 `_inherits` 实现了对父类原型链上属性的继承，那么对于父类的实例属性（就是 constructor
定义的属性）的继承，也可以归结为一句话：

    
    
    Person.call(this);
    

我们看到 Babel 将 class extends 编译成了 ES5 组合模式的继承，这才是 JavaScript 面向对象的实质。

### jQuery 中的对象思想

可能会有读者有这样的问题：“所有的面试官都那么注重面向对象，可是我在工作中很少涉及到啊？面向对象到底有什么用？”

回答这个问题我想说，“如果你没有开发大型复杂项目的经验，不具备封装抽象的思想，也许确实用不到面向对象，也很难解释为什么要有面向对象的设计和考察。”这一讲，我从
jQuery 源码架构设计入手，来分析一下基本的原型和原型链知识如何在 jQuery 源码中发挥作用的。

> “什么，这都哪一年了你还在说 jQuery？”

其实优秀的思想是永远不过时的，研究清楚 `$`
到底是个什么，你会受益匪浅。顺带我自己的一个知乎回答：[jQuery为什么还在发布新版本？](https://www.zhihu.com/question/324179465/answer/694045746)。

从一个问题开始：

    
    
    const pNodes = $('p')
    // 我们得到一个数组
    const divNodes= $('div')
    // 我们得到一个数组
    

但是我们又可以：

    
    
    const pNodes = $('p')
    pNodes.addClass('className')
    

数组上可是没有 addClass 方法的吧？

这个问题先放一边。我们想一想 `$` 是什么？你的第一反应可能是一个函数，因此我们可以这么调用执行：

    
    
    $('p')
    

但是你一定又见过这样的使用：

    
    
    $.ajax()
    

那么 `$` 又是一个对象，它有 `ajax` 的静态方法。

类似：

    
    
    // 构造函数
    function $() {
    
    }
    
    $.ajax = function () {
        // ...
    }
    

实际上，我们翻看 jQuery 源码架构会发现（具体内容有删减和改动）：

    
    
    var jQuery = (function(){
        var $
    
        // ...
    
        $ = function(selector, context) {
            return function (selector, context) {
                var dom = []
                dom.__proto__ = $.fn
    
                // ...
    
                return dom
            }
        }
    
        $.fn = {
            addClass: function() {
                // ...
            },
            // ...
        }
    
        $.ajax = function() {
            // ...
        }
    
        return $
    })()
    
    window.jQuery = jQuery
    window.$ === undefined && (window.$ = jQuery)
    

我们顺着源码分析，当调用 `$('p')` 时，最终返回的是 dom，而 `dom.__proto__` 指向了 `$.fn`，`$.fn`
是包含了多种方法的对象集合。因此返回的结果（dom）可以在其原型链上找到 addClass 这样的方法。同理，`$('span')`
也不例外，任何实例都不例外。

    
    
    $('span').__proto__ === $.fn
    

同时 ajax 方法直接挂载在构造函数 `$` 上，它是一个静态属性方法。

请读者仔细体会整个 jQuery 的架构，其实翻译成 ES class 就很好理解了（不完全对等）：

    
    
    class $ {
      static ajax() {
        // ...
      }
    
      constructor(selector, context) {
        this.selector = selector
        this.context = context
    
        // ...
      }
    
      addClass() {
        //  ...
      }
    }
    

这个应用虽然并不复杂，但是还是很微妙地表现出来了面向对象的精妙设计。

### 类继承和原型继承的区别

我们了解了 JavaScript
中的原型继承，那么它和传统面向对象语言的类继承有什么不同呢？这就涉及到编程语言范畴了，传统的面向对象语言的类继承，会引发一些问题：

  * 紧耦合问题
  * 脆弱基类问题
  * 层级僵化问题
  * 必然重复性问题
  * 大猩猩—香蕉问题

这些内容属于纯理论，多说无益。但我借用 Eric Elliott 的著名文章：[Difference between class prototypal
inheritance](https://www.zcfy.cc/article/master-the-javascript-interview-what-
s-the-difference-between-class-amp-prototypal-inheritance-2185.html)，展开一点：

![](https://images.gitbook.cn/6863c480-82ae-11e9-a8e7-67046055f720)

从上图，我们看出一些问题（单一继承、紧耦合以及层级分类问题），对于类
8，只想继承五边形的属性，却得到了继承链上其他并不需要的属性，比如五角星，正方形属性。这就是大猩猩/香蕉问题，“我只想要一个香蕉，但是你给我了整个森林”。

对于类 9，对比其父类，我只需要把五角星属性修改成四角形，但是五角星继承自基类
1，如果要去修改，那就影响整个继承树（脆弱基类/层级僵化问题）；好吧，我不去修改，那就需要给类 9 新建一个基类（必然重复性问题）。

那么基于原型的继承可以怎么解决上述问题呢？

![](https://images.gitbook.cn/7d983c00-82ae-11e9-a327-4364b56a668e)

采用原型继承，其实本质是对象组合，可以避免复杂纵深的层级关系。当类 1 需要四角星特性的时候，只需要组合新特性即可，不会影响到其他实例。

**上述图示出自：[类继承和原型继承的区别](https://mp.weixin.qq.com/s/CqXmu4n6aZsqB-jJ0O0t-g?)**

了解了这些，你还会吐槽 JavaScript 吗？请爱上我们的 JavaScript 吧！

### 面向对象在实战场景中的应用

最后，让我们分析一个真实场景案例。

在产品当中，一个页面可能存在多处“收藏”组件：

![](https://images.gitbook.cn/939385f0-82ae-11e9-a327-4364b56a668e)
![](https://images.gitbook.cn/aa96ca00-82ae-11e9-8efd-6b08a473483f)

点击按钮，对页面进行收藏，成功收藏之后，按钮的状态会变为“已收藏”，再点击不会有响应。

这样就出现页面中多处“收藏”组件之间通信问题，点击页面顶部收藏按钮成功收藏之后，页面底部的收藏按钮状态也需要变化，进行同步。

其实实现这个功能很简单，但是历史代码实现方式如果落后，耦合严重就很麻烦了。良好的设计和肆意而为的实现差别是巨大的。

以 ES6 class 实现为例，不借助任何框架，我们实现这样的对象关系：所有 UI 组件（包括收藏组件）都会继承 UIBase class：

    
    
    class Widget extends UIBase {
        constructor() {
            super();
            ...
        }
    }
    

而 UIBase 本身会产生一个全局唯一的 id，这样通过继承，使得所有组件都有一个唯一的 id 标识。同时，UIBase 又继承 EventEmitter
这个 pub/sub 模式组件：

    
    
    class UIBase extends EventEmitter{
        constructor() {
            super();
            this.guid = guid();
        }
    }
    

因此，所有的组件也同样拥有了 pub/sub 模式，即事件发布订阅功能。这就相对完美的解决了组件之间的通信问题，达到了“高内聚、低耦合”的效果。

具体来说，我们的任何组件，当然包括收藏按钮在发起收藏行为时：

    
    
    widget.emit('favorAction')
    

同时，其他的收藏组件：

    
    
    widget.on('favorAction', function() {
        // toggle status
    })
    

具体的实现结构如图：

![](https://images.gitbook.cn/c4e01150-82ae-11e9-a8e7-67046055f720)

这样的组件行为在一些先进的 MVVM、MVC 等框架中可以良好的实现，比如 React 框架中，可以借助 Redux 实现组件间的通信。Redux
实质就是一个事件发布订阅系统，而 connect 就是将组件的行为具备“发布和订阅”的能力。在上述简单的架构中，我们通过面向对象继承，自动具备了这样的能力。

同样的设计思想也可以在 NodeJS 源码中找到线索，想想 NodeJS 中的 EventEmitter 类即可。

### 总结

面向对象是一个永远说不完的话题，更是一个永远不会过时的话题，具备良好的面向对象架构能力，对于开发者来说至关重要。同时由于 JavaScript
面向对象的特殊性，使它区别于其他语言，而“与众不同”。我们在了解 JavaScript
原型、原型链知识的前提下，对比其他语言的思想，就变得非常重要和有意义了。

### 分享交流

阅读文章过程中有任何疑问随时可以跟其他小伙伴讨论，或者直接向作者 LucasHC 提问（作者看到后抽空回复）。 **你的分享不仅帮助他人，更会提升自己。**

你也可以说说自己最想了解的主题，课程内容会根据部分读者的意见和建议迭代和完善。

此外，我们为本课程付费读者创建了《前端开发核心知识进阶》微信交流群，以方便更有针对性地讨论课程相关问题（入群请到第1-2课末尾添加 GitChat
小助手伽利略的微信，并注明「前端核心」，谢谢~）



## 究竟该如何学习与时俱进的 ES

JavaScript 语言规范始终在与时俱进，除了过于激进的 ES4 被“废除”之外，ES Next 始终茁壮发展。到如今，TC39（Technical
Committee 39，JavaScript 委员会）已经明确表示每年更新一个版本，因此使用 ES Next 表示那些“正在演进、正在发展”的新特性集。

作为前端开发者，我们该如何看待每年一版的 ES Next，又该如何去保持学习呢？这一讲，我们就来谈谈 ES
Next。我认为列举新特性没有价值，这些东西随处可见，更重要的是分析新特性的由来，剖析如何学习新特性，分析如何利用新特性。

相关知识点如下：

![](https://images.gitbook.cn/30b41f70-88e5-11e9-8115-8f03dd50b734)

### 新特性添加的必要性

有很多人不幸患上了“JavaScript fatigue”，表示我“再也学不动了”，求“不要再更新”了。到底要不要更新？我们来从一处细节看看 ES Next
发展的必要性。

ES7 规范中定义了一个新的数组 API，签名如下：

    
    
    Array.prototype.includes(value : any): boolean
    

它用起来就像这样：

    
    
    [1, 2, 3].includes(3)
    // true
    

从命名上就不难理解，这是判断数组中是否含有一个元素的方法，该方法最终返回一个布尔值。有的开发者可能会问，判断数组中是否含有一个元素，不是有很多现成的方法可以使用吗？我能列举出来很多：

    
    
    [1, 2, 3].findIndex(i => i === 2) 
    // 1
    
    [1, 2, 3].find(i => i == 2) 
    // 2
    
    [1, 2, 3].indexOf(2) 
    
    // 1
    

难道这还不够吗？我们甚至完全可以实现一个“一模一样” 的 API：

    
    
    const includes = (array, target) =>  !!~ array.indexOf(target)
    
    includes([1,2,3], 3)
    // true
    
    includes([1,2,3], 4)
    // false
    

对于任何 ES Next 的新特性，开发者若有疑问，都可以在 TC39 提议的 GitHub
中找到，这个也不例外。我们就来分析这一新特性的意义：首先，在语义上它直观明朗，这是 indexof 所无法取代的。当然还有更深层次的必要性和不可替代性。

我们认真审视 Array.prototype.includes 这个
API，它用来判断数组是否包含某一元素，那么“是否包含”必然有判断“是否相等”的逻辑。那么这个“相等”，又是如何定义的呢？最简单的，是 == 还是 ===？

**这里可以说明的是：Array.prototype.indexOf 采用的是 === 比较，而Array.prototype.includes
不同，它采用了 SameValueZero() 比较。**

SameValueZero() 是什么呢？这个是引擎内置的比较方式，并没有对外接口，其实现采用了 Map 和 Set。采用这种比较，最直接的收益就是可以判断
NaN：

    
    
    [NaN].includes(NaN) // true
    [NaN].indexOf(NaN) // -1
    

因为：

    
    
    NaN === NaN
    // false
    

而 SameValueZero() 却不受干扰，可以准确地判断 NaN === NaN。

这就是新特性区别于老传统的不同，很多都体现在细节上，需要开发者用心体会，这也是学习 ES Next 的“正确姿势”之一。

当然，新特性除了体现在这些细节上，也体现在更多更有意义的方面，比如异步处理，相信学习过前面课程的读者已经能有所体会了。想想异步处理从回调到
Promise，再到 generator 和 async/await，也许你就会明白语言发展的必要性。

### 学习新特性的正确姿势

前面我们已经通过剖析一个细节，为大家介绍了学习的“正确姿势”。除了认真、事无巨细以外，有的时候还需要一些“刨根问底”、“吹毛求疵”的态度。我们来进入场景。

#### Object Spread VS Object.assign

Object Spread 和 Object.assign 在很多情况下做的事情是一致的，它们都属于 ES Next 的新特性，当然 Object
Spread 更新。事实上，规范说明中，也告诉我们 “object spread”：{... obj} 和 Object.assign（{}，obj）
是等价的。

但是一定还具有区别。实际上，Object.assign() 将会修改它的第一个参数对象，这个修改可以触发其第一个参数对象的
setter。熟悉函数式编程，了解 React/Redux 技术栈的读者，可能会听说过“不可变性”的概念。从这个层面上讲，Object spread
操作符会创建一个对象副本，而不会修改任何值，这也许是更好的选择。

当然，喜欢“抬杠”的读者可以说，如果使用
Object.assign()，我们始终保证一个空对象作为第一个参数，也能实现同样的“不可变性”。话虽是如此，但是既然你“抬杠”，那我也“抬杠”，我就告诉你这么做的话，性能比
Object Spread 就差的比较多了。

采用 [object-assign-vs-object-spread](http://thecodebarbarian.com/object-assign-
vs-object-spread.html) 提供的 benchmark：

    
    
    const Benchmark = require('benchmark');
    
    const suite = new Benchmark.Suite;
    
    const obj = { foo: 1, bar: 2 };
    
    suite.
      add('Object spread', function() {
        ({ baz: 3, ...obj });
      }).
      add('Object.assign()', function() {
        Object.assign({}, obj, { baz: 3 });
      })
    

得出结果：

    
    
    Object spread x 3,065,831 ops/sec +-2.12% (85 runs sampled)
    Object.assign() x 2,461,926 ops/sec +-1.52% (88 runs sampled)
    Fastest is Object spread
    

使用 Object spread 性能要明显领先于 Object.assign。

#### 箭头函数不适用的场景

我们再来分析一道思考题， **“哪些场景下不适合使用 ES6 箭头函数”？**

这个问题不是死板地考察队 ES Next 箭头函数的理解，而是反其道行之，考察其不适用的场景。 回答这个问题，我们思考：开发者习惯使用箭头函数来对 this
指向进行干预，那么反过来说，“不需要进行 this 指向干预的情况下，我们就不适合使用箭头函数”。总结下来，有：

  * 构造函数的原型方法上

构造函数的原型方法需要通过 this 获得实例，因此箭头函数不可以出现在构造函数的原型方法上：

    
    
    Person.prototype = () => {
      // ...
    }
    

这样的做法是错误的。

  * 需要获得 arguments 时

箭头函数不具有 arguments，因此在其函数体内无法访问这一特殊的伪数组，那么相关场景下也不适合使用箭头函数。

  * 使用对象方法时

    
    
    const person = {
      name: 'lucas',
      getName: () => {
        console.log(this.name)
      }
    };
    person.getName()
    

上述代码中，getName 函数体内的 this 指向 window，显然不符合其用意。

  * 使用动态回调时

同理，类似下面这种对回调函数的 this 有特殊场景需求的用法，箭头函数的 this 无法满足要求：

    
    
    const btn = document.getElementById('btn')
    
    btn.addEventListener('click', () => {
        console.log(this === window)
    });
    

当点击 id 为 btn 的按钮时，将会输出：true，事件绑定函数的 this 指向了 window，而无法获取事件对象。

“箭头函数”不适用的场景社区上也有相关文章分析，我个人认为这是一个很好的切入点。思考“哪些场景不适用”，不仅能够全面了解学习新特性，也能够和老知识融会贯通，可谓学习
ES Next 的正确姿势之一了。

### 新特性可以做些什么有趣的事儿

可能有开发者有这样的体会：“ES Next” 那么多新特性，但是我使用的来来回回都是那么几项，很多感觉并用不上啊？

同时，讲了这么多细节，我们可以用新特性实现哪些很 cool
的操作呢？其实除了日常用到的新特性以外，一些不为大家所熟知的特性往往在框架开发，或者实现更深层次行为操作的场景中，应用比比皆是。比如
Proxy，它可以用来定义对象各种基本操作的自定义行为，比如 Vue 双向绑定的实现，就可以借助 Proxy 完成。

#### Proxy 代理

我们先来看一些简单的场景，借用上节课的例子：

    
    
    class Person {
      constructor (name) {
           this.name = name
      }
    }
    
    let proxyPersonClass = new Proxy(Person, {
      apply (target, context, args) {
        throw new Error(`hello: Function ${target.name} cannot be invoked without 'new'`)
      }
    })
    

我们对 Person 构造函数进行了代理，这样就可以防止非构造函数实例化的调用：

    
    
    proxyPersonClass('lucas')
    
    // VM173058:9 Uncaught Error: hello: Function Person cannot be invoked without 'new'
        at <anonymous>:1:1
    
    new proxyPersonClass('lucas')
    // {name: "lucas"}
    

同样道理，也可以静默处理非构造函数实例化的调用，将其强制转换为 new 调用：

    
    
    class Person {
      constructor (name) {
           this.name = name
      }
    }
    
    let proxyPersonClass = new Proxy(Person, {
      apply (target, context, args) {
        return new (target.bind(context, ...args))()
      }
    })
    

这样即便在不使用 new 关键字时，仍然可以得到 new 调用的实例：

    
    
    proxyPersonClass('lucas')
    // Person {name: "lucas"}
    

另外一个场景：熟悉前端测试的读者，可能对断言 assert 并不陌生，一种常用的使用方式是：

    
    
    const lucas = {
        age: 23
    }
    assert['lucas is older than 22!!!'] = 22 > lucas.age
    
    // Error: lucas is older than 22!!!
    

我们看 assert 赋值语句右侧表达式结果为一个布尔值，当表达式成立时，断言不会抛出；如果 assert
赋值语句右侧表达式不成立时，也就是断言失败时，断言抛出错误。

乍看上去这是不是很神奇？如果面试过程中，面试官要求你实现一个 assert，该怎么做呢？这样一个断言库本质上还是拦截 assert
对象的赋值（set）操作：

    
    
    const assert = new Proxy({}, {
      set (target, warning, value) {
        if (!value) {
            console.error(warning)
        }
      }
    })
    

这样我们只需要判读对 assert 的赋值值是否为 true，如果不为 true，则打印错误。

是不是很简单？这样我们就可以随意进行断言：

    
    
    const weather = 'cold'
    assert['The weather is not good!!!'] = weather === 'good'
    
    // Error: The weather is not good!!!
    

这些只是 Proxy 实现的一些很简单的例子，这里抛砖引玉，大家可以充分发挥想象力，创造更多的玩法。

#### Decorator 那些事

除此之外，介绍给大家的就是 ES7 中的装饰器 Decorator。

> 装饰器（Decorators）让你可以在设计时对类和类的属性进行“注解”和修改。

说直白一些，Decorator 就是给类添加或者修改类的属性与方法的。这么听上去似乎跟我们刚刚介绍的 proxy
似乎有异曲同工之秒。一些开发者可能已经在使用 Decorator 了，这里我借助 autobind 这个类库的实现，介绍一下 Decorator 的玩法。

我们知道：

    
    
    class Person {
      constructor (name) {
           this.name = name
      }
      getPersonName() {
        return this.name
      }
    }
    
    const person = new Person('lucas')
    
    const fn = person.getPersonName
    
    fn()
    
    //  Cannot read property 'name' of undefined
        at getPersonName (<anonymous>:6:17)
        at <anonymous>:3:1
    

这里在执行 fn() 时，this 已经指向了 window，使用 autobind 可以完成对 this 的绑定：

    
    
    class Person {
      constructor (name) {
           this.name = name
      }
      @autobind
      getPersonName() {
        return this.name
      }
    }
    

那么 autobind 怎么实现呢？伪代码如下：

    
    
     function autobind(target, key, { value: fn, configurable, enumerable }) {
      return {
        configurable,
        enumerable,
        get() {
          const boundFn = fn.bind(this);
          defineProperty(this, key, {
            configurable: true,
            writable: true,
            enumerable: false,
            value: boundFn
          });
          return boundFn;
        },
        set: createDefaultSetter(key)
      };
    }
    

autobind 这个 decorator 接受以下三个参数。

  * target：目标对象，这里是作用于 Person 中的函数、属性的
  * key：属性名称
  * descriptor：属性原本的描述符

autobind decorator 函数最终返回描述符，这个描述符运行时相当于调用 Object.defineProperty()
修改原有属性，我们看最终修改的结果为：

    
    
    {
        configurable,
        enumerable,
        get() {
          const boundFn = fn.bind(this);
          defineProperty(this, key, {
            configurable: true,
            writable: true,
            enumerable: false,
            value: boundFn
          });
          return boundFn;
        },
        set: createDefaultSetter(key)
    }
    

这样在使用 get 赋值时（const fn = person.getPersonName），赋值结果通过 const boundFn =
fn.bind(this) 进行对 this 绑定，并返回绑定 this 后的结果，因此达到了我们对 getPersonName 属性方法绑定 this
的目的。

这就是 decorator 在 autobind 这个库中的应用，这个库大家接触的不多，也许有 React 开发者使用 autobind
来对事件处理函数进行 this 绑定。总之，autobind 源码实现很好地利用了 decorator 特性。

### Babel 编译对代码做了什么

为了能够使用到新鲜出炉的 ES Next 新特性，必不可少的一环就是 Babel，相信每个前端开发者都听说过它的大名。虽然 Babel
目前已经是个丰富的生态社区了，但是它刚出道时的目标，以及目前最核心的能力就是：编译 ES Next 代码，进行降级处理，进而规避了兼容性问题。

那么 Babel 编译到底是施展了什么魔法呢？它的核心原理是使用
AST（抽象语法树）将源码进行分析并转为目标代码，这中间的细节部分我们会在工程化章节中有所涉及。在上一讲中，我们已经对 ES6 class
的编译产出进行了分析，这里再分析一些比较典型的编译结果。

#### const、let 编译分析

简单来说，const、let 一律转成 var。为了保证 const 的不可变性：Babel 如果在编译过程中发现对 const
声明的变量进行了二次赋值，将会直接报错，这样就在编译阶段进行了处理。至于 let 的块级概念，ES5 中，我们一般通过 IIFE 实现块级作用域，但是
Babel 处理非常取巧，那就是在块内给变量换一个名字，块外自然就无法访问到。

在之前的课程中我们介绍使用 let 或者 const
声明的变量，存在暂时性死区（TDZ）现象。简单回顾下：代码声明变量所在的区块中，会形成一个封闭区域。在这个区域中，只要是在声明变量前使用这些变量，就会报错。

    
    
    var foo = 123
    
    {
      foo = 'abc'
      let foo
    }
    

将会报错：Uncaught ReferenceError: Cannot access 'foo' before initialization。

那么 Babel 怎么编译模拟这种行为呢？其实我们提到 Babel 编译会将 let、const 变量重新命名，同时在 **JavaScript
严格模式（strict mode）不允许使用未声明的变量** ，这样在声明前使用这个变量，也会报错。如下代码：

    
    
    "use strict";
    var foo = 123
    {
      _foo = 'abc'
      var _foo
    }
    

我们加上严格模式的标记，自然就可以实现了 TDZ 的效果。

对于经典的 for 循环问题，Babel 的处理并不让我们感到意外：

    
    
    let array = []
    for (let i = 0; i < 10; i++) {
      array[i] = function () {
        console.log(i)
      }
    }
    array[6]()
    // 6
    
    let array = []
    for (var i = 0; i < 10; i++) {
      array[i] = function () {
        console.log(i)
      }
    }
    array[6]()
    // 10
    

为了保存每一个循环变量 i 的值，Babel 也使用了闭包：

    
    
    "use strict";
    var array = [];
    
    var _loop = function _loop(i) {
      array[i] = function () {
        console.log(i);
      };
    };
    
    for (var i = 0; i < 10; i++) {
      _loop(i);
    }
    array[6]();
    

细心的同学可能还会想到：使用 const 声明的变量一旦声明，其变量（内存地址）是不可改变的。

    
    
    const foo = 0
    foo = 1
    
    // VM982:2 Uncaught TypeError: Assignment to constant variable
    

对此 Babel 的处理有比较有意思：

    
    
    "use strict";
    function _readOnlyError(name) { throw new Error("\"" + name + "\" is read-only"); }
    
    var foo = 0;
    foo = (_readOnlyError("a"), 1);
    

我们看编译结果，Babel 检测到 const 声明的变量被改变赋值，就会主动插入了一个 `_readOnlyError`
函数，并执行此函数。这个函数的执行内容就是报错，因此代码执行时就会直接抛出异常。

#### 箭头函数的编译分析

对于箭头函数的转换，也不难理解，看代码：

    
    
    var obj = {
        prop: 1,
        func: function() {
            var _this = this;
    
            var innerFunc = () => {
                this.prop = 1;
            };
    
            var innerFunc1 = function() {
                this.prop = 1;
            };
        },
    
    };
    

转换为：

    
    
    var obj = {
        prop: 1,
        func: function func() {
            var _this2 = this;
    
            var _this = this;
    
            var innerFunc = function innerFunc() {
                _this2.prop = 1;
            };
    
            var innerFunc1 = function innerFunc1() {
                this.prop = 1;
            };
        }
    
    };
    

通过 `var _this2 = this;` 保存当前环境的 this 为 `_this2`，在调用 innerFunc 时，用新储存的 `_this2`
进行替换函数体内的 this 即可。

#### Decorators 的编译分析

上面的内容中，我们介绍了 decorators 新特性，那么 Babel 又是怎么编译 decorators 的呢？

使用方式：

    
    
    class Person{
      @log
      say(){}
    }
    

我们有一个名为 log 的 decorators，Babel 编译：

    
    
    _applyDecoratedDescriptor(
      Person.prototype, 
      'say', 
      [log],
      Object.getOwnPropertyDescriptor(Person.prototype, 'say'),
      Person.prototype)
    )
    
    function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
      var desc = {};
      Object['ke' + 'ys'](descriptor).forEach(function (key) {
        desc[key] = descriptor[key];
      });
      desc.enumerable = !!desc.enumerable;
      desc.configurable = !!desc.configurable;
    
      if ('value' in desc || desc.initializer) {
        desc.writable = true;
      }
    
      desc = decorators.slice().reverse().reduce(function (desc, decorator) {
        return decorator(target, property, desc) || desc;
      }, desc);
    
      if (context && desc.initializer !== void 0) {
        desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
        desc.initializer = undefined;
      }
    
      if (desc.initializer === void 0) {
        Object['define' + 'Property'](target, property, desc);
        desc = null;
      }
    
      return desc;
    }
    

我们看这里主要依赖了 _applyDecoratedDescriptor 方法。这个方法将返回描述符 desc，具体执行逻辑为：先把所有
decorators 包装成一个数组，作为 _applyDecoratedDescriptor 方法的第三个参数传入，对于 decorators
这个数组，我们将 target、property、desc 作为参数，依次遍历执行数组中的每一个 decorator 函数。执行后返回每一个
decorator 产生的属性描述符。上述代码样例就是：decorators 这个数组只有一项：log。[log]，遍历数组时，我们将
target、property、desc 作为参数传给 log 函数并执行：log(target, property,
desc)，返回结果即是新的属性描述符。

如果读者对于 decorators 特性能够熟练掌握，上述源码的理解并不困难。

再加上上一节课对 class 编译结果的分析，我们可以知道：Babel 并没有什么“深不可测”的魔法，感兴趣的读者可以翻看各种 ES Next
的编译结果，通过对编译结果的学习，对于基础的提高，具有帮助作用。

本小节对 Babel 编译结果的进行分析，“抛砖引玉”，希望感兴趣的读者可以自行研究更多内容。值得提醒大家的一个细节是：Babel
编译产出结果主要分为两种模式，normal 模式的转换更贴近 ES Next 的写法，力求编译转换的更少，更“激进”。而另一种模式，loose 模式则更贴近
ES5 或者现有 ES 老规范的写法，也就是说在兼容性上更加有保障，因此转换代码结果也可能会更加的复杂。

### 来自群里一个问题的延伸

前两天本课程的核心群里，有读者问了一个关于 ES6 尾递归调用的问题。我解释了什么样的行为算是尾递归调用优化，什么行为不能算尾递归调用优化。

![](https://images.gitbook.cn/911a50a0-88e5-11e9-b068-5302ecb579f2)

![](https://images.gitbook.cn/ad019080-88e5-11e9-b068-5302ecb579f2)

简而言之：递归非常耗费内存，也很容易发生“栈溢出”错误。但是对于尾递归来说，之所以可能形成优化，是因为全部执行过程中不会在调用栈上增加新的堆栈帧，而是直接更新调用栈，进而永远不会发生“栈溢出”错误。因此真正实现尾递归调用优化，最关键的是改写递归函数，确保最后只调用自身。

我们来看 fibonacci 数列求和的例子：

    
    
    const fibonacci = n => {
      if (n === 0) return 0
      if (n === 1) return 1
      return fibonacci(n - 1) + fibonacci(n - 2)
    }
    

fibonacci 数列求和非常耗费内存，如果用尾递归进行优化：

    
    
    const fibonacciTail = (n, a = 0, b = 1) => {
      if (n === 0) return a
      return fibonacciTail(n - 1, b, a + b)
    }
    

我们看，每次调用 fibonacciTail 函数后，会继续递归调用 fibonacciTail，函数的 n 会依次递减
1，它实际上是用来记录递归剩余求和的次数。而 a 和 b 两个参数在每次递归时也会在计算后再次传入 fibonacciTail 函数，最终返回值为 a，a
是上一次 a + b 的结果。这样每次递归都不会增加调用栈的长度，只是更新当前的堆栈帧而已。也就避免了内存的浪费和爆栈的危险。

然而可惜的是，据我所知，很多浏览器引擎并没有支持尾递归调用优化，即便支持，也要求代码运行环境在 strict mode 下。

那么，对于不支持尾递归调用优化的场景，我们可以做些什么实现类似的优化呢？答案一般有两个：蹦床函数和改为循环。改为循环：

    
    
    const fibonacciLoop = (n, a = 0, b = 1) => {
      while(n--) {
        [a, b] = [b, a + b]
      }
      return a
    }
    

这样一来就不存在函数的多次调用。因此，将递归改为循环，是防止递归暴栈的重要优化点之一。

另外一个优化手段是使用蹦床函数，我们来看蹦床函数：

    
    
    const trampoline = func => {
        while(func && func instanceof Function){
            func = func()
        }
        return func
    }
    

蹦床函数其实并没有实现真正的尾递归，它只是将整个执行过程拆散，还是类似循环的效果：每次产生一个结果，该结果将会对下一次执行产生影响，就像蹦床一样，越蹦越高。我们看蹦床函数接受一个函数作为参数，在蹦床函数内部执行这个函数，如果执行结果，也就是该函数的返回值还是一个函数，那么就继续执行。一直到返回值不再是一个函数时，我们返回最终的结果。

在使用蹦床函数时，我们的 fibonacci 函数需要进行一定的改动：

    
    
    const fibonacciFunc = (n, a = 0, b = 1) => {
      if (n > 0) {
        [a, b] = [b, a + b]
    
        return fibonacciFunc.bind(null, n - 1, a , b)
      }
      else {
        return a 
      }
    }
    

在使用时：

    
    
    trampoline(fibonacciFunc(10)) 
    

就能带到良好的优化效果。

这是一种比较“取巧”的方式，并不是实现了真正的尾递归调用优化。那么有没有真正实现尾递归调用优化的手段呢？答案也是有的：

    
    
    const tailCallOpt = func => {
      let result
      let started = false
    
      const accumulated = []
    
      return function accumulator() {
        accumulated.push(arguments)
        if (!started) {
          started = true
    
          while (accumulated.length) {
            result = func.apply(this, accumulated.shift())
          }
    
          started = false
    
          return result
        }
      }
    }
    

同样，我们改动相应的 fibonacci 函数为：

    
    
    const fibonacciTailOpt = tailCallOpt(function (n, a = 0, b = 1) {
      if (n === 0) return a
    
      return fibonacciTailOpt(n - 1, b, a + b)
    })
    
    fibonacciTailOpt(5)
    

我们观察整个实现过程，结合修改后的 fibonacciTailOpt 函数尝试理解：tailCallOpt 接受一个待优化的函数 func，返回一个新的
accumulator 函数。执行 fibonacciTailOpt(5) 就是第一步执行 accumulator。

第一次执行 accumulator 时，先将参数推入 accumulated 数组当中，started 标记为 true。然后进入 while
循环，循环中执行待优化的 func 函数，func 这个函数执行过程中需要保证调用 tailCallOpt 函数的返回值，这里为
fibonacciTailOpt；第二次执行 accumulator，将新的参数加入 accumulated 数组；这样 accumulated
数组长度始终不为零，循环继续进行。

整个过程就是 accumulated 数组放进去一个参数，执行一次，得到结果，accumulated
清空；再放进去新的参数，执行得到结果，accumulated 再清空，以此类推。直到 func 返回了基本类型值（非函数值），这时候 accumulated
数组不会再有新的参数进来，因此返回最终结果。

这是一个通用的尾递归调用优化的轮子实现。核心原理就是不增加调用栈，拆成调用单元去分布执行。理解起来相对晦涩。不过这只是一点延伸，和 ES Next
并不太强相关，读者简单了解一下即可。

### 总结

JavaScript 语言、ES
规范总是在不断进步、发展，那么每个开发者都要做到时刻学习、跟进。在这个过程中，除了了解新特性之外，新老知识相结合，融会贯通，不断去思考“是什么”、“为什么”非常重要。这节课程挑选了几个典型的特性、分析了
Babel 编译结果、最后从尾调用优化展开，内容并不算太深，但却是一个很好的的切入角度。

希望大家能够掌握学习的正确“姿势”，保持好的心态，这也是进阶路上至关重要的一点。

### 分享交流

阅读文章过程中有任何疑问随时可以跟其他小伙伴讨论，或者直接向作者 LucasHC 提问（作者看到后抽空回复）。 **你的分享不仅帮助他人，更会提升自己。**

你也可以说说自己最想了解的主题，课程内容会根据部分读者的意见和建议迭代和完善。

此外，我们为本课程付费读者创建了《前端开发核心知识进阶》微信交流群，以方便更有针对性地讨论课程相关问题（入群请到第1-2课末尾添加 GitChat
小助手伽利略的微信，并注明「前端核心」，谢谢~）



## 前端面试离不开的“面子工程”

我们都知道前端开发中的“三驾马车”：HTML + CSS + JavaScript。从难易程度、受关注程度上来讲，显然 JavaScript
始终处于核心地位。但是这并不意味着 HTML 和 CSS 不重要，如果你轻视它们，那么也许会在工作开发中、甚至面试中吃亏。

作为多年的面试官，我的考察重点无疑是 JavaScript，但在面试过程中，每次也总是会“蜻蜓点水”下，这足以了解候选者对待 HTML 和 CSS
的态度以及了解程度。其实事实上，HTML 和 CSS 也有很多有趣的内容，下面就让我们在复习重点知识的同时，了解一些前沿用法。

这一讲，我挑选出了 HTML 和 CSS 几个关键概念，不去力求“面面俱到”，但希望给大家带来新的启发。

相关知识点如下：

![](https://images.gitbook.cn/db85d420-88e5-11e9-b068-5302ecb579f2)

### 如何理解 HTML 语义化

HTML 语义化——这个概念其实诞生了挺长时间，我经常发现在面试 JD（Job Description） 中出现要求候选者“了解 HTML 语义化”、“对
HTML 语义化有深刻认知”的需求。对于这么一句 JD 范式标配，如果面试官真的问起，该如何回答呢？

#### 语义化是什么、为什么、怎么做

简单来说，HTML 语义化就是：

> 根据结构化的内容，选择合适的标签。

那么为什么要做到语义化呢？

直观上很好理解，“合适的标签”是内容表达的高度概括，这样浏览器爬虫或者任何机器在读取 HTML 时，都能更好地理解，进而解析效率更高。这样带来的收益如下：

  * 有利于 SEO
  * 开发维护体验更好
  * 用户体验更好（如使用 alt 标签用于解释图片信息）
  * 更好的 accessibility，方便任何设备解析（如盲人阅读器）

那么如何做到语义化呢？

其实很简单，这就要求我们实时跟进、学习并使用语义化标签。这里我帮大家总结了一些典型的 HTML 标签，并进行分类。

![enter image description
here](https://images.gitbook.cn/2aa65430-88e6-11e9-8115-8f03dd50b734)

我将 HTML 标签分为 9 大类别，每一种类别都包含有语义化的标签内容，小图如下：

![enter image description
here](https://images.gitbook.cn/50392a10-88e6-11e9-b157-776f1929e232)

![enter image description
here](https://images.gitbook.cn/78d71d10-88e6-11e9-88f0-f1d5a1392b19)

![](https://images.gitbook.cn/ef3dc850-88e6-11e9-8115-8f03dd50b734)

了解了这些语义化的标签，我们就可以按照“适合内容与否”，进行使用。关于选取标准，我也简单总结了一下，抽象成代码表达为：

    
    
    if (导航) {
      return <nav />
    }
    else if (文稿内容、博客内容、评论内容...包含标题元素的内容) {
      return <article />
    }
    else if (目录抽象、边栏、广告、批注) {
      return <aside />
    }
    else if (含有附录、图片、代码、图形) {
      return <figure />
    }
    else if (含有多个标题或内容的区块) {
     return <section />
    }
    else if (含有段落、语法意义) {
      return <p /> || <address /> || <blockquote /> || <pre /> || ...
    }
    else {
      return <div />
    }
    

#### 语义化的发展和高级玩法

说到语义化的发展，我这里指向重点提一个概念：Microformats，如果面试官问的语义化时，你能把这个概念搬出来，效果是非常好的。那什么是
Microformats 呢？

> Microformats，翻译为微格式，是 HTML 标记某些实体的小模式，这些实体包括人、组织、事件、地点、博客、产品、评论、简历、食谱等。它们是在
HTML 中嵌套语义的简单协议，且能迅速地提供一套可被搜索引擎、聚合器等其他工具使用的 API。

除了 hCard 和 hCalendar，有好几个库特别开发了微格式。

是不是看的一脸懵逼？其实很简单，Microformats 的原理就是扩展 HTML 元素或者属性，来增强 HTML 的语义表达能力。

我们来看一个案例：

![enter image description
here](https://images.gitbook.cn/4bd676c0-88e7-11e9-8115-8f03dd50b734)

Wikipedia 的页面中，给某一部分加上了 vCard 的 class，这是用来做什么的呢？

![enter image description
here](https://images.gitbook.cn/d8469cc0-88e7-11e9-b068-5302ecb579f2)

Google 搜索引擎可以通过 Wikipedia 页面 vCard 这个 class，读取相关内容，在呈现搜索结果时，匹配展现出人物信息。从而语义化的
class，帮助了机器（搜索爬出）学习到更多信息，展现出了更好的结果页面。

Microdata 属于 WHATWG（网页超文本应用技术工作小组：Web Hypertext Application Technology
Working） HTML 规范，它并不是标准，但这是一个很典型的语义化发展和应用尝试。

### BFC 背后的布局问题

CSS 给人的感觉就是 simple，但是前端开发者一定深有体会：simple 并不意味着 easy。我们这里不一一列举各种 CSS
“疑难杂症”，而是深入一个概念 —— BFC。BFC 是前端面试中的一个超级热点，今日头条某部门曾经就问过我：

> 请解释一下 BFC 是什么？

回答这个问题并不困难，但是我们可以继续追问：

> BFC 会引起哪些布局现象？

这一小节，我们通过对 BFC 的分析，也顺带回顾一下那些 CSS 常考的小细节。

#### BFC 是什么

简单来说，BFC 就是：

BFC 是 Block Formatting Context 的简写，我们可以直接翻译成“块级格式化上下文”。它会创建一个特殊的区域，在这个区域中，只有
block box 参与布局。而 BFC
的一套特点和规则就规定了在这个特殊的区域中如何进行布局，如何进行定位，区域内元素的相互关系和相互作用。这个特殊的区域不受外界影响。

上面提到了 block box 的概念，block box 是指 display 属性为 block、list-item、table 的元素。

顺便插一个问题：那你还知道其他哪些 box 类型呢？

相应地，我们有 inline box，它是指 display 属性为 inline、inline-block、inline-table 的元素。CSS3
规范中又加入了 run in box，这里我们不再展开。

#### 如何形成 BFC

那么什么样的情况会创建一个 BFC 呢？MDN 总结如下：

  * 根元素或其他包含它的元素
  * 浮动元素 (元素的 float 不是 none)
  * 绝对定位元素 (元素具有 position 为 absolute 或 fixed)
  * 内联块 (元素具有 display: inline-block)
  * 表格单元格 (元素具有 display: table-cell，HTML 表格单元格默认属性)
  * 表格标题 (元素具有 display: table-caption, HTML 表格标题默认属性)
  * 具有 overflow 且值不是 visible 的块元素
  * display: flow-root 的元素
  * column-span: all 的元素

#### BFC 决定了什么

我们上面谈到了 BFC 的一套规则，那么这些规则都有哪些呢？

  * 内部的 box 将会独占宽度，且在垂直方向，一个接一个排列
  * box 垂直方向的间距由 margin 属性决定，但是同一个 BFC 的两个相邻 box 的 margin 会出现边距折叠现象
  * 每个 box 水平方向上左边缘，与 BFC 左边缘相对齐，即使存在浮动也是如此
  * BFC 区域不会与浮动元素重叠，而是会依次排列
  * BFC 区域内是一个独立的渲染容器，容器内元素和 BFC 区域外元素不会形成任何干扰
  * 浮动元素的高度也参与到 BFC 高度的计算当中

从这些规则中，我们至少能总结出一些关键要点，比如：

  * 边距折叠
  * 清除浮动
  * 自适应多栏布局

这也是我选取 BFC 这个概念来剖析的原因，理解了 BFC，这些常见、常考知识点我们都可以融会贯通，具体来看下下面的场景。

#### BFC 实战应用

  * 例题1

给出如下代码：

    
    
    <style>
        body {
            width: 600px;
            position: relative;
        }
    
        .left {
            width: 80px;
            height: 150px;
            float: left;
            background: blue;
        }
    
        .right {
            height: 200px;
            background: red;
        }
    </style>
    
    <body>
        <div class="left"></div>
        <div class="right"></div>
    </body>
    

我们得到布局如图：

![enter image description
here](https://images.gitbook.cn/04b9dab0-88e8-11e9-88f0-f1d5a1392b19)

请在不修改已有内容情况下，加入样式，实现自适应（.left 宽度固定，.right 占满剩下宽度）两栏布局。

我们来思考：根据 BFC 布局规则：“每个 box 水平方向上左边缘，与 BFC 左边缘相对齐。即使存在浮动也是如此”，因此 .left 和 .right
的左边相接触。出现如此布局结果并不意外。

同时，再想想 BFC 布局规则：“BFC 区域不会与浮动元素重叠，而是会依次排列”，因此我们可以使 .right 形成
BFC，来实现自适应两栏布局。如何形成 BFC 前面已经做过介绍了，于是添加：

    
    
    .right {
        overflow: hidden;
    }
    

就可以得到：

![enter image description
here](https://images.gitbook.cn/a9bd6130-8915-11e9-b157-776f1929e232)

当然，这种布局可以用更先进的 flex 或者 grid 手段解决，但是对于 BFC 这些 CSS 基础知识，同样要做到了然于胸。

  * 例题 2

看代码：

    
    
    <style>
        .root {
            border: 5px solid blue;
            width: 300px;
        }
    
        .child {
            border: 5px solid red;
            width:100px;
            height: 100px;
            float: left;
        }
    </style>
    <body>
        <div class="root">
            <div class="child child1"></div>
            <div class="child child2"></div>
        </div>
    </body>
    

首先来回答第一个问： **.root 的高度是多少？**

事实上，因为 .child 为浮动元素，因此造成了“高度塌陷”现象，.root 的高度为 0。

![](https://images.gitbook.cn/ca790c80-8915-11e9-8115-8f03dd50b734)

那么如何解决“高度塌陷”问题呢？

想想 BFC 规则：“浮动元素的高度也参与到 BFC 高度的计算当中”，因此使 .root 形成 BFC，就能解决问题：

    
    
    .root {
        overflow: hidden;
    }
    

![](https://images.gitbook.cn/06df63e0-8916-11e9-8115-8f03dd50b734)

我们看此时高度已经被你撑开了。

  * 例题 3

代码：

    
    
    <style>
        p {
            color: blue;
            background: red;
            width: 400px;
            line-height: 100px;
            text-align:center;
            margin: 40px;
        }
    </style>
    <body>
        <p>paragraph 1</p>
        <p>paragraph 2</p>
    </body>
    

首先回答问题： **两段之间的垂直距离为多少？** 想想 BFC 规则：“box 垂直方向的间距由 margin 属性决定，但是 **同一个** BFC
的两个相邻 box 的 margin 会出现边距折叠现象”。事实上，因为边距折叠现象，答案为 40px。

那么如何解决这个问题呢？

最简单地，我们可以在 p 标签再包裹一个元素，并触发该元素形成一个BFC。那么这两个 p 标签，不再属于同一个 BFC，从而解决问题。

    
    
    <style>
        p {
            color: blue;
            background: red;
            width: 400px;
            line-height: 100px;
            text-align:center;
            margin: 40px;
        }
        .wrapper {
            overflow: hidden
        }
    </style>
    <body>
        <p>paragraph 1</p>
        <div class="wrapper">
            <p>paragraph 2</p>
        </div>
    </body>
    

![](https://images.gitbook.cn/2f329240-8916-11e9-b157-776f1929e232)

**总结** ：我们通过分析 BFC 是什么、如何形成、布局规则，融会贯通了 CSS
当中很多关键问题。也许不少读者能够解决“边距折叠”、“多栏自适应”、“高度塌陷”等问题，但是并不能说出解决问题的原理。通过这一环节的学习，我们对 CSS
加深了理解，我更希望地是能够启发大家思考：我们到底应该如何对待 CSS、如何学习 CSS。

### 多种方式实现居中

“实现居中”也是一道必考题。参考代码：

    
    
    <style>
    .wp {
        border: 1px solid red;
        width: 300px;
        height: 300px;
    }
    
    .box {
        background: green;    
    }
    
    .box .fixed-size {
        width: 100px;
        height: 100px;
    }
    </style>
    
    <body>
        <div class="wp">
           <div class="box fixed-size">text</div>
        </div>
    </body>
    

如图：

![](https://images.gitbook.cn/5c895260-8916-11e9-b157-776f1929e232)

如何让绿色的块水平垂直居中呢？

总结一下：

#### 仅适用于居中元素定宽高

  * absolute + 负 margin

    
    
    .wp {
        position: relative;
    }
    .box {
        position: absolute;;
        top: 50%;
        left: 50%;
        margin-left: -50px;
        margin-top: -50px;
    }
    

绝对定位的百分比是相对于父元素的宽高，我们设置：

    
    
    top: 50%;
    left: 50%;
    

使得元素偏移后，在修正元素自身宽高的一半即可：

    
    
    margin-left: -50px;
    margin-top: -50px;
    

这其实是一个简单的数学几何运算。

  * absolute + margin auto

    
    
    .wp {
        position: relative;
    }
    .box {
        position: absolute;;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        margin: auto;
    }
    

这种方式将设置各个方向的距离都是 0，此时配合 margin 为 auto，就可以在各个方向上居中了。

  * absolute + calc

    
    
    .root {
        position: relative;
    }
    .textBox {
        position: absolute;;
        top: calc(50% - 50px);
        left: calc(50% - 50px);
    }
    

此种方法和第一种类似，不再展开。

#### 居中元素不定宽高

对于剧中元素不定宽高的情况：

    
    
    <style>
    .wp {
        border: 1px solid red;
        width: 300px;
        height: 300px;
    }
    
    .box {
        background: green;    
    }
    </style>
    
    <body>
        <div class="wp">
           <div class="box ">text</div>
        </div>
    </body>
    

我们依然也有很多方法。

  * absolute + transform

不定宽高时，利用 CSS3 新增的 transform，transform 的 translate
属性也可以设置百分比，这个百分比是相对于自身的宽和高，因此可以将 translate 设置为 ﹣50%：

    
    
    .wp {
        position: relative;
    }
    .box {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
    }
    

原理和第一种方法也类似。

  * lineheight

把 box 设置为行内元素，通过 text-align 也可以做到水平居中，同时通过 vertical-align 做到垂直方向上的居中，代码如下：

    
    
    .wp {
        line-height: 300px;
        text-align: center;
        font-size: 0px;
    }
    .box {
        font-size: 16px;
        display: inline-block;
        vertical-align: middle;
        line-height: initial;
        text-align: left; /* 修正文字 */
    }
    

这个方法充分利用了行内 / 块级元素的特点。

  * table

其实历史上 table 经常被用来做页面布局，这么做的缺点是会增加很多冗余代码，并且性能也不友好。不过处理居中问题，它可是能手：

    
    
    <table>
        <tbody>
            <tr>
                <td class="wp">
                    <div class="box">test</div>
                </td>
            </tr>
        </tbody>
    </table>
    
    .wp {
        text-align: center;
    }
    .box {
        display: inline-block;
    }
    

  * css-table

如何使用 table 布局的特性效果，但是不采用 table 元素呢？答案是 css-table：

    
    
    .wp {
        display: table-cell;
        text-align: center;
        vertical-align: middle;
    }
    .box {
        display: inline-block;
    }
    

我们使用了 display: table-cell，同时和 table 布局相比，减少了很多冗余代码。

  * flex

flex 是非常现代的布局方案，只需几行代码就可以优雅地做到居中：

    
    
    .wp {
        display: flex;
        justify-content: center;
        align-items: center;
    }
    

  * grid

grid 布局非常超前，虽然兼容性不好，但是能力超强：

    
    
    .wp {
        display: grid;
    }
    .box {
        align-self: center;
        justify-self: center;
    }
    

我们总结一下：

  * PC 端有兼容性要求，宽高固定，推荐 absolute + 负 margin
  * PC 端有兼容要求，宽高不固定，推荐 css-table
  * PC 端无兼容性要求，推荐 flex
  * 移动端推荐使用 flex

最后整理一个列表：

![](https://images.gitbook.cn/8cce31c0-8916-11e9-88f0-f1d5a1392b19)

### 总结

HTML 和 CSS
面试中考察较少，但是如果答的不好，将是致命性的。同时工作中，如果这方面知识存在短板，往往会造成不必要的效率消耗。我们应该正视前端领域这两个离不开的“面子工程”，为了更好的面试结果，更为了自己的技能。

### 分享交流

阅读文章过程中有任何疑问随时可以跟其他小伙伴讨论，或者直接向作者 LucasHC 提问（作者看到后抽空回复）。 **你的分享不仅帮助他人，更会提升自己。**

你也可以说说自己最想了解的主题，课程内容会根据部分读者的意见和建议迭代和完善。

此外，我们为本课程付费读者创建了《前端开发核心知识进阶》微信交流群，以方便更有针对性地讨论课程相关问题（入群请到第1-2课末尾添加 GitChat
小助手伽利略的微信，并注明「前端核心」，谢谢~）



## 进击的 CSS 和 HTML

通过前面的课程介绍，我们认识到了 JavaScript 语言的飞速发展。其实 HTML 和 CSS 也不断“要求着”进步，本节课程我们就来了解一下发展中的
HTML 和 CSS。之所以叫做“进击的”，是因为确实有很多新的特性非常实用且具有变革精神。

相关知识点如下：

![](https://images.gitbook.cn/1c028dd0-8fdb-11e9-9c86-a1bad3faf0f2)

其中，除了罗列一些热点面试题目以外，我们将重点分析 CSS 变量和 CSS
Modules，我认为这两个概念代表了未来的发展方向。当下来看，也有必要根据情况，融合到成熟的项目中，加以应用。因此这方面的内容除了基本理论，我都会给出实战案例和构建流程。

### 进击的 HTML

我们再来看看 HTML 的历史和规范常识。HTML 规范是 W3C 与 WHATWG 合作共同产出的，HTML5 因此也不例外。其中：

  * W3C 指 World Wide Web Consortium
  * WHATWG 指 Web Hypertext Application Technology Working Group

说好听了是“合作产出”，但其实更像是“HTML5
有两套规范”。但话说天下大势合久必分，分久必合，如今（就在前几天，2018.5.29）它们又表示将会开发单一版本的 HTML 规范。

那么 HTML5 给开发者提供了哪些便利呢？简单列举有：

  * 用于绘画的 canvas 元素
  * 用于媒介播放的 video 和 audio 元素
  * 对本地离线存储更好的支持（localStorage、sessionStorage）
  * 新的语义化标签（article、footer、header、nav、section...)
  * 新的表单控件（calendar、date、time、email、url、search...)

除了这些常规的之外，还有：

  * 给汉字加拼音

    
    
    <ruby> 
        前端开发核心知识进阶
        <rt>
            qianduankaifahexinzhishijinjie
        </rt> 
    </ruby>
    

![](https://images.gitbook.cn/2853de80-8fd2-11e9-afed-87af38460e36)

  * 展开收起组件

简单几行代码：

    
    
    <details>
      <summary>前端开发核心知识进阶</summary>
    前端领域，入门相对简单，可是想要“更上一层楼”却难上加难，也就是我们常说的“职业天花板较低”，君不见——市场上高级/资深前端工程师凤毛麟角。这当然未必完全是坏事，一旦突破瓶颈，在技能上脱颖而出，便是更广阔的空间。那么，如何从夯实基础到突破瓶颈？
    </details>
    

就可以实现：

![](https://images.gitbook.cn/649e4970-8fd2-11e9-afed-87af38460e36)

上图为“收起”效果。

![](https://images.gitbook.cn/dc7b6810-8fd2-11e9-8b34-c732c3ec276d)

上图为“展开”效果。

以往要实现这样的内容，我们都必须依靠 JavaScript 实现。现在来看，HTML 也变得更加具有“可交互性”。

  * 原生进度条和度量

progress 标签显示进度：

![enter image description
here](https://images.gitbook.cn/08358f30-8fd3-11e9-9c86-a1bad3faf0f2)

值得一提的是：progress 不适合用来表示度量衡，如果想表示度量衡，我们应该使用 meter 标签代替。这又是什么标签？

其实 HTML5 新带来的标签多种多样，感兴趣的读者可以自行了解，我们这里不再用更多篇幅介绍。

### 不可忽视的 Web components

事实上，Web components 的概念在几年前也已经提出，貌似一直没有发展的“如火如荼”，这里我为什么又单独拿出来讲呢？

我并不想赘述 Web components
的基础概念，但是我认为，作为“更高阶”的前端工程师，要时刻保持技术视野和信息广度。在框架带来的“组件化”、“生命周期化”这些统治级别的概念下，对比并结合
Web components，我认为是可以深入研究的一个课题方向。我总结一下 Web components 的特殊点或者优点：

  * 原生规范，无需框架

这条优点的后半句话是：“但是继承且具备了框架的优点”，在新的 Web components 规范中，我们会发现组件生命周期的概念、slot
概念、模版概念（类比 JSX 或者 Vue template），再结合本来就已经存在的组件化，shadow dom，扩展原生元素的能力，我认为 Web
components 还是具备了较好的发展前景。

  * 原生使用，无需编译

想想现有的一系列框架，不论是 Vue 还是 React，都需要进行编译。而 Web components
因为原生，会得到浏览器的天然支持，自然就可以免去编译构建过程。

  * 真正的 CSS scope

Web components 实现了真正的 CSS scope，做到了样式隔离。这一点读者可以对比我们下面即将介绍的 CSS Modules。真正的 CSS
scope 对于项目的可维护性至关重要。

进击的 HTML 和 CSS 带来了进击的 Web components 概念。通过这个案例，我更想建议读者：真正的高级工程师，不仅仅要理解
this、熟练掌握各种基础（当然这是前提），更要有技术嗅觉，对新的解决方案能够理解，并进行对比，面向“未来”编程。

### 移动端 H5 注意事项总结

HTML5 因为其强大先进的能力，毫无疑问打来了一场开发的变革。在国内，体现最明显的就是各种 H5 移动页面。

因为移动端的碎片化现象，以及技术落地的成熟度尚浅，造成了不少问题，那么移动端开发 H5 有哪些坑以及小技巧呢？

这里列举一些典型情况，目的在于梳理和整理，不再一一详解。具体信息社区上都可以找到，感兴趣的读者可以另行学习。

  * 打电话发短信写邮件的小技巧

这些技巧都和 a 标签相关，其中打电话：

    
    
    <a href="tel: 110">打电话给警察局</a>
    

发短信：

    
    
    <a href="sms: 110">发短信给警察局</a>
    

写邮件依赖“mailto”：

    
    
    <a href="mailto: 110@govn.com">发邮件给警察局</a>
    

我们设置可以添加抄送：

    
    
    <a href="mailto: 110@govn.com?cc=baba@family.com">发邮件给警察局，并抄送给我爸爸</a>
    

除了抄送，也可以私密发送：

    
    
    <a href="mailto: 110@govn.com?cc=baba@family.com&bcc=mama@family.com">发邮件给警察局，并抄送给我爸爸，密送给我妈妈</a >
    

群发也可以：

    
    
    <a href="mailto: 110@govn.com; 120@govn.com">发邮件给警察局，以及 120 急救</a>
    

既然都支持群发了，那么定义主题和内容也不在话下：

    
    
    <a href="mailto: 110@govn.com?subject=SOS">发邮件给警察局，并添加救命主题</a>
    

包含内容用 body 体现：

    
    
    <a href="mailto: 110@govn.com?subject=SOS&body=快来救我">发邮件给警察局，并添加救命主题和内容</a>
    

内容也是支持插入图片和链接的，这里不再一一列举。

  * 移动端 300 毫秒点击延迟以及点击穿透现象

这是由于历史原因造成的，一般解决手段为禁止混用 touch 和 click，或者增加一层“透明”蒙层，也可以通过延迟上层元素消失来实现。

  * 点击元素禁止产生背景或边框

一般可以使用：

    
    
    -webkit-tap-highlight-color: rgba(0,0,0,0); 
    

属性进行禁用。

  * 禁止长按链接与图片弹出菜单

一般可以使用：

    
    
    -webkit-touch-callout: none;
    

  * 禁止用户选中文字

    
    
    -webkit-user-select:none; 
    user-select: none;
    

  * 取消 input 输入时，英文首字母的默认大写

    
    
    <input autocapitalize="off" autocorrect="off" />
    

iOS 有效。

  * 语音和视频自动播放

自动播放是一个很麻烦的话题。不同浏览器内核支持自动播放的情况不一样，甚至 webkit
内核对于自动播放的策略也一直在调整当中。自动播放有时候也带着条件：比如设置静音等。

具体信息更新可以参考：[New video Policies for iOS](https://webkit.org/blog/6784/new-
video-policies-for-ios/)。

一般我们设置自动播放的回退策略是用户触摸屏幕时进行的播放：

    
    
    // JS 绑定自动播放（操作 window 时，播放音乐）
    $(window).on('touchstart', () => {
        video.play()
    })
    
    // 微信环境
    document.addEventListener("WeixinJSBridgeReady", () => {
        video.play()
    }, false)
    

  * 视频全屏播放

为了使视频全屏播放，我们一般设置：

    
    
    <video x-webkit-airplay="true" webkit-playsinline="true" preload="auto" autoplay src=""></video>
    

但是最终情况还是要受到浏览器引擎实现的影响。

  * 开启硬件加速

在做动画时，为了达到更好的性能效果，我们往往会选用硬件加速。一般手段为：

    
    
    transform: translate3d(0,0,0);
    

  * fixed 定位问题

这个问题主要体现在 iOS 端，比如软键盘弹出时，某些情况下，会影响 fixed 元素定位；配合使用 transform、translate
时，某些情况下，也会影响 fixed 元素定位。一般解决方案是模拟 fixed 定位，或者使用 iScroll 库。

  * 怎么让 Chrome 支持小于 12px 的文字？

一般通过：

    
    
    -webkit-text-size-adjust:none;
    

实现。

### HTML5 和 CSS3 其他面试问题整理

关于 HTML5 和 CSS3 的面试问题都并不困难，往往都是属于“是否听说过”、“用过哪些”，这种知道即可的问题，不会太有“深度”。这里我们总结一下关于
HTML5 和 CSS3 新特性的问题，答案也比较容易找到，这里仅做梳理，不再进行展开。如果有疑问的读者，欢迎在读者群中讨论。

  * link 和 @import 的区别
  * CSS3 新增选择符有哪些
  * CSS 如何定义权重规则
  * 如何使用纯 CSS 创建一个三角形
  * CSS3 如何写出一个旋转的立方体
  * localStorage 和 cookies 的区别是什么
  * 如何实现浏览器内多个标签页之间的通信
  * 渐进增强和优雅降级概念区别是什么
  * 如何实现 CSS3 动画

这些内容比较基本，和进阶关系不大，我们不过多纠结。

### CSS 变量和主题切换优雅实现

CSS 变量或者 CSS 自定义属性一直以来是一个值得关注的方向。我们前端没必要去“叫嚣” CSS + HTML 是否图灵完备，但是 CSS
变量时代确实已经到来。注意这里所说的不是 CSS 预处理器（类似 Less，Sass）中的变量，而是实实在在的原生支持特性。

#### 什么是 CSS 变量

什么是 CSS 变量呢？我们直接来看实例，有代码：

    
    
    body {
      background: white;
      color: #555;
    }
    
    a, a:link {
      color: #639A67;
    }
    a:hover {
      color: #205D67;
    }
    

如果我们借助 CSS 变量，定义：

    
    
    :root {
      --bg: white;
      --text-color: #555;
      --link-color: #639A67;
      --link-hover: #205D67;
    }
    

之后，上述代码可以直接简化为：

    
    
    body {
      background: var(--bg);
      color: var(--text-color);
    }
    
    a, a:link {
      color: var(--link-color);
    }
    a:hover {
      color: var(--link-hover);
    }
    

这个很好理解，在任何语言中，变量是个好东西：它可以降低维护成本，甚至实现更好的性能。

CSS 变量语法也很简单：我们使用`--变量名`的方式定义变量，使用`var(--变量名)`的方式消费变量。

更多 CSS 变量的基础内容可以访问：[使用 CSS 变量](https://developer.mozilla.org/zh-
CN/docs/Web/CSS/Using_CSS_custom_properties)。

值得一提的是，CSS 变量的兼容性“出乎意料”的好：

![enter image description
here](https://images.gitbook.cn/e8d70d70-8fd3-11e9-8b34-c732c3ec276d)

我就在自己的项目中大范围使用了 CSS 变量，在 html 根节点下，定义 :root ：

![enter image description
here](https://images.gitbook.cn/15260510-8fd5-11e9-b9c8-7fcc2264bbb1)

除了简单应用变量，我们能玩出哪些更高级的用法呢？

#### 使用 CSS 变量实现主题切换

一键切换主题，以往实现方式较为复杂。借助 CSS 变量，一切变得容易起来。

仍然以开头：

    
    
    :root {
      --bg: white;
      --text-color: #555;
      --link-color: #639A67;
      --link-hover: #205D67;
    }
    

为例，我们再定义一个 .pink-theme 对应粉色主题：

    
    
    .pink-theme {
      --bg: hotpink;
      --text-color: white;
      --link-color: #B793E6;
      --link-hover: #3532A7;
    }
    

这样一来，在切换主题时，就变得和 toggle class 一样简单。

    
    
    const toggleBtn = document.querySelector('.toggle-theme')
    
    toggleBtn.addEventListener('click', e => {
      e.preventDefault()
    
      if (document.body.classList.contains('pink-theme')) {
         // 当前主题为粉色主题，需要移除 pink-theme class
        document.body.classList.remove('pink-theme')
    
        toggle.innerText = '切换正常主题色'
      } else {
        document.body.classList.add('pink-theme')
        toggle.innerText = '切换为粉色少女主题'
      }
    })
    

同时，我们可以将“进击的 CSS”和“进击的 HTML”相结合，利用 localStorage 实现主题的保存：

    
    
    const toggleBtn = document.querySelector('.toggle-theme')
    
    if (localStorage.getItem('pinkTheme')) {
      document.body.classList.add('pink-theme')
      toggle.innerText = '切换为粉色少女主题'
    }
    
    toggleBtn.addEventListener('click', e => {
      e.preventDefault()
    
      if (document.body.classList.contains('pink-theme')) {
         // 当前主题为粉色主题，需要移除 pink-theme class
        document.body.classList.remove('pink-theme')
    
        toggle.innerText = '切换正常主题色'
        localStorage.removeItem('pinkTheme')
      } else {
        document.body.classList.add('pink-theme')
        toggle.innerText = '切换为粉色少女主题'
        localStorage.setItem('pinkTheme', true)
      }
    })
    

非常的简单直观，我认为这将会成为 CSS 发展的一个不可避免的趋势。

### CSS Modules 理论和实战

我做面试官时，对 CSS 的考察除了基础布局和经验以外，非常喜欢问 CSS 工程相关的题目，比如：

> 如何维护大型项目的 z-index

比如，

> 如何维护 CSS 选择器和样式之间的冲突

这个环节我们就来谈谈 CSS Modules，看看这个方案是否能让“CSS 冲突成为历史”。

#### 什么是 CSS Modules

CSS Modules 是指：

> 项目中所有 class 名称默认都是局部起作用的。

其实，CSS Modules 并不是一个官方规范，更不是浏览器的机制。它依赖我们的项目构建过程，因此实现往往需要借助 Webpack。借助 Webpack
或者其他构建工具的帮助，可以将 class 的名字唯一化，从而实现局部作用。

这么说可能比较抽象，我们来看一个例子：

    
    
    <div class="test">This is a test</div>
    

对应的样式表为：

    
    
    .test {
      color: red;
    }
    

再经过编译构建之后，对应的 HTML 和 CSS 分别为：

    
    
    <div class="_style_test_309571057">
      This is a test
    </div>
    
    
    
    ._style_test_309571057 {
        color: red;
    }
    

其中 class 名是动态生成的，全项目唯一的。因此通过命名规范的唯一性，达到了避免样式冲突的目的。

仔细想来，这样的解决方案似乎有一个问题：如何实现样式复用？因为生成了全局唯一的 class 名，那么我们如何像传统方式那样实现样式复用呢？

从原理上想，全局唯一的 class 是在构建过程中，如果能给在构建过程进行标识，表示该 class 将被复用，就可以解决问题了。这样的方式，就依靠
composes 关键字实现。我们来看案例：

样式表 style.css 文件中：

    
    
    .common {
      color: red;
    }
    
    .test {
      composes: common;
      font-size: 18px;
    }
    

注意我们使用了 composes 关键字，在 .test 中关联了 .common 样式。

对于 HTML 文件：

import style from "./style.css";

    
    
    <div class="${style.test}">
        This is a test
    </div>
    

进行编译构建后：

    
    
    <div class="_style__test_0980340 _style__common_404840">
        This is a test
    </div>
    

我们看 div 的 class 被加进了 _style__common_404840，这样就实现了复用样式。

明白了道理，我们该如何应用 CSS Modules 呢？

#### CSS Modules 实战

实战应用 CSS Modules，我将会选取 Webpack 构建一个项目，一步一步进行分析讲解。因为主题并不是“如何配置 Webpack”，因此一些
Webpack 基础不再赘述，同时为了简化问题，我们不进行其他 Webpack（比如 dev server）配置。

  * Step 1：创建项目

    
    
    npm init --y
    

此时生成 package.json 如下：

    
    
    {
      "name": "css-modules",
      "version": "1.0.0",
      "description": "README.md",
      "main": "index.js",
      "scripts": {
        "test": "echo \"Error: no test specified\" && exit 1"
      },
      "keywords": [],
      "author": "",
      "license": "ISC"
    }
    

  * Step 2：创建必要文件

    
    
    mkdir src
    touch index.html
    

在 ./src 文件夹中，创建：index.js：

    
    
    import bluestyle from './style.css';
    import greenstyle from './app.css';
    
    let html = `
    <h2 class="${bluestyle.my_css_selector}">I should be displayed in blue.</h2>
    <br/>
    <h2 class="${greenstyle.my_css_selector}">I should be displayed in green.</h2> 
    `;
    document.write(html);
    

以及 style.css：

    
    
    .my_css_selector {
        color: blue;
    }
    

和 app.css：

    
    
    .my_css_selector {
        color: green;
    }
    

在这两个样式文件中，我们使用了相同的 class 名。

  * Step 3：安装依赖

接下来我们按照 webpack、webpack-cli、babel 全家桶（babel-core、babel-loader、abel-preset-
env）和相应的 loaders：css-loader、style-loader 以及 extract-text-webpack-plugin 插件。

这些依赖项具体是做什么的这里不再赘述，有不了解的读者可以自行 Google 学习。另外，强烈建议安装版本遵循：

    
    
    "babel-core": "^6.26.3",
    "babel-loader": "^7.1.4",
    "babel-preset-env": "^1.6.1",
    "css-loader": "^0.28.11",
    "extract-text-webpack-plugin": "^4.0.0-beta.0",
    "style-loader": "^0.21.0",
    "webpack": "^4.1.0",
    "webpack-cli": "^3.1.1"
    

否则会出现类似 webpack 版本和 extract-text-webpack-plugin 不兼容等依赖版本问题。

正常流程下来，我们 package.json 如下：

    
    
    {
      "name": "css-modules",
      "version": "1.0.0",
      "description": "README.md",
      "main": "index.js",
      "scripts": {
        "test": "echo \"Error: no test specified\" && exit 1"
      },
      "keywords": [],
      "author": "",
      "license": "ISC",
      "devDependencies": {
        "babel-core": "^6.26.3",
        "babel-loader": "^7.1.4",
        "babel-preset-env": "^1.6.1",
        "css-loader": "^0.28.11",
        "extract-text-webpack-plugin": "^4.0.0-beta.0",
        "style-loader": "^0.21.0",
        "webpack": "^4.1.0",
        "webpack-cli": "^3.1.1"
      }
    }
    

  * Step 4：编写 webpack 配置

创建 webpack 配置文件：

    
    
    touch webpack.config.js
    

并编写：

    
    
    var ExtractTextPlugin = require('extract-text-webpack-plugin');
    
    module.exports = {
        entry: './src',
        output: {
            path: __dirname + '/build',
            filename: 'bundle.js'
        },
        module: {
            rules: [
                {
                    test: /\.js/,
                    loader: 'babel-loader',
                    include: __dirname + '/src'
                },
                {
                    test: /\.css/,
                    loader: ExtractTextPlugin.extract("css-loader?modules&importLoaders=1&localIdentName=[name]__[local]__[hash:base64:5]")
                }
            ]
        },
        plugins: [
            new ExtractTextPlugin("styles.css")
        ]
    }
    

我们使用了 extract-text-webpack-plugin 插件，并定义入口为 ./src 目录，产出为 `__dirname +
'/build'` 目录。对后缀名为 css 的文件使用 css-loader 解析，产出为 styles.css 文件并在 index.html 中使用。

注意我们看对于 css-loader，设置了 modules 参数，进行了 css modules 处理。

  * Step 4：编写 npm script 并运行

还差一步，我们将 package.json 中的 script 命令改为：

    
    
    "scripts": {
        "start": "webpack --mode development"
    },
    

便是运行 webpack，此时 package.json 内容为：

    
    
    {
      "name": "css-modules",
      "version": "1.0.0",
      "description": "README.md",
      "main": "index.js",
      "scripts": {
        "start": "webpack --mode development"
      },
      "keywords": [],
      "author": "",
      "license": "ISC",
      "devDependencies": {
        "babel-core": "^6.26.3",
        "babel-loader": "^7.1.4",
        "babel-preset-env": "^1.6.1",
        "css-loader": "^0.28.11",
        "extract-text-webpack-plugin": "^4.0.0-beta.0",
        "style-loader": "^0.21.0",
        "webpack": "^4.1.0",
        "webpack-cli": "^3.1.1"
      }
    }
    

运行 npm start，得到产出，打开页面会发现：

如图，已经在编译过程中完成了 css module 处理。

![enter image description
here](https://images.gitbook.cn/bf6eefd0-8fd7-11e9-b9c8-7fcc2264bbb1)

### 总结

本节课程我们既有“大面儿”上的梳理，也有关键点的“实战”深入。有趣实用的标签和属性、移动端 H5 注意事项总结、HTML5 和 CSS3
面试题梳理，这三块内容旨在将碎片化的知识点以“记事本”式的排列；Web components 更多给大家带来对新技术的思考和总结；CSS 变量、CSS
Module 是我认为最有发展潜力、最有实用价值、最能马上落地实现的解决方案。

HTML 和 CSS 向来被忽视，但是涉及到项目组织和构建，涉及到新技术的调研和决断，我们切不可含糊。

### 分享交流

阅读文章过程中有任何疑问随时可以跟其他小伙伴讨论，或者直接向作者 LucasHC 提问（作者看到后抽空回复）。 **你的分享不仅帮助他人，更会提升自己。**

你也可以说说自己最想了解的主题，课程内容会根据部分读者的意见和建议迭代和完善。

此外，我们为本课程付费读者创建了《前端开发核心知识进阶》微信交流群，以方便更有针对性地讨论课程相关问题（入群请到第1-2课末尾添加 GitChat
小助手伽利略的微信，并注明「前端核心」，谢谢~）



## 响应式布局和 Bootstrap 的实现分析

响应式这个概念曾经非常流行，但从发展来看，似乎“响应式”布局不再是一个必不可少的话题。究其原因我认为主要有以下几点：

  * 公司研发人力越来越充足，PC 端、移动端可以实现两套布局，分项目维护
  * 响应式布局适配越来越简单

但是我们仍然不能对这个概念“掉以轻心”，因为响应式布局仍然有其存在的价值：移动端碎片化的现象将会无限期存在；前端也必然进入物联网，任何设备界面的响应布局将会成为关键挑战。除此之外，响应式布局也体现了
CSS 的灵活和发展。

本讲我们就来深入这个话题，相关知识点如下：

![](https://images.gitbook.cn/3dd287e0-90a2-11e9-8b34-c732c3ec276d)

### 上帝视角——响应式布局适配方案

我们首先来梳理一下响应式布局的几种典型方案：

  * 传统 float 浮动布局
  * 相对单位布局
  * 媒体查询
  * 基于相对单位 rem 的 flexible 布局
  * flex 布局
  * grid 布局
  * 借助 JavaScript

其中“传统 float 浮动布局”已经在「第3-1课：前端面试离不开的“面子工程”」中有所体现（多栏自适应），这种实现方式比较传统，且能力较弱。

相对单位布局比较容易理解，梳理 CSS 中的相对单位有：

  * em
  * rem
  * vh、vw、vmin、vmax 
  * %
  * calc() 

重点是理解这些相对单位的使用规范，“到底是相对于谁”（注意，这也是一个很重要的面试考点），比如：

  * em 相对于当前元素或当前元素继承来的字体的宽度，但是每个字母或汉字的宽度有可能是不一样的，那么一般来说，就是一个大写字母 M 的宽度（事实上，规范中有一个 x-height 概念，建议取 X 的高度，但并没有推荐绝对的计算执行标准，还需要看浏览器的实现，也有的地方采用 O 的高度）；一个非常容易出错的点在于：很多同学会认为 em 相对于父元素的字体大小，但是实际上取决于应用在什么 CSS 属性上。对于 font-size 来说，em 相对于父元素的字体大小；line-height 中，em 却相对于自身字体的大小。
  * rem 相对于根节点（html）的字体大小，根节点一个大写字母 M 的宽度（同上）。

这两个单位在响应式布局中非常重要，我们后续在真实线上适配案例中就能发现，以 rem 为核心，诞生了淘宝的 flexible 响应式布局的方案。

  * vw 相对于视口宽度，100vw 就相当于一个视口宽度
  * vh 同理，1vh 表示视口高度的 1/100，100vh 就是一个视口高度
  * vmin 相对于视口的宽度或高度中较小的那个，也就是 1vw 和 1vh 取最小（Math.min(1vw, 1vh)）；vmax 相对于视口的宽度或高度中较大的那个，（Math.max(1vw, 1vh)）
  * % 的相对对象我们专门挑出来在后续的环节中介绍
  * calc 也是一个响应式布局神器，它使得 CSS 有了运算的能力：

    
    
    width: calc(100vw - 80px)
    

除了相对单位以外，媒体查询（Media Query）以及 flex、grid 布局也都比较好理解。相关内容都容易找到，这里插播一下借助 JavaScript
实现响应式布局的案例，结合上一讲“进击的 HTML 和 CSS”中的 CSS 变量，往往也能简化很多问题：

    
    
    p {
        height: var(--test-height);
    }
    
    function changePHeight (height)
        document.documentElement.style.setProperty('--test-height', `${height}px);
    }
    

其实总结下来，这也是一道非常常见的面试题：“你如何实现自适应？如何做到响应式？”，想必大家已经有所了解了。

事实上，所有的响应式布局手段都不是单一的，上述方法搭配使用，效果更明显，也更加简单可行。

下面我们通过分析线上案例（淘宝 + 网易），来了解真实环境下的解决方案。

### 真实线上适配案例分析

在进入分析前，我们先罗列一下其他关于响应式布局的概念：

  * 屏幕分辨率
  * 像素
  * PPI（Pixel Per Inch）：每英寸包括的像素数
  * DPI（Dot Per Inch）：即每英寸包括的点数
  * 设备独立像素
  * 设备像素比（dpr）
  * Meta Viewport

不同设备的物理像素尺寸等信息可以参考：[Device Metrics](https://material.io/tools/devices/)。

这些内容都可以在社区上了解到，这里重点分析移动端页面的处理方案。

首先，淘宝通过设置：

    
    
    <meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover">
    

![enter image description
here](https://images.gitbook.cn/cd1cd750-909f-11e9-afed-87af38460e36)

禁用了用户缩放功能，使页面宽度和设备宽度对齐，一般这种操作也是移动端的响应式适配的标配。

我们观察在页面根节点 HTML 元素上，显式设置了 font-size：

![enter image description
here](https://images.gitbook.cn/eebf6030-909f-11e9-8b34-c732c3ec276d)

并且进行试验，当改变浏览器大小时，html 的 font-size 会动态变化。这样不难理解， 采用 rem 作为相对单位的长宽数值，都会随着 resize
事件进行变化（因为 html 的 font-size 动态变化）。我们在其页面当中，不难找到这样的代码：

![enter image description
here](https://images.gitbook.cn/0c3a3860-90a0-11e9-afed-87af38460e36)

我将其复制并美化出来，得到：

    
    
    !function(e, t) {
        var n = t.documentElement,
            d = e.devicePixelRatio || 1;
    
        function i() {
            var e = n.clientWidth / 3.75;
            n.style.fontSize = e + "px"
        }
        if (function e() {
            t.body ? t.body.style.fontSize = "16px" : t.addEventListener("DOMContentLoaded", e)
        }(), i(), e.addEventListener("resize", i), e.addEventListener("pageshow", function(e) {
            e.persisted && i()
        }), 2 <= d) {
            var o = t.createElement("body"),
                a = t.createElement("div");
            a.style.border = ".5px solid transparent", o.appendChild(a), n.appendChild(o), 1 === a.offsetHeight && n.classList.add("hairlines"), n.removeChild(o)
        }
    }(window, document)
    

核心逻辑不难理解，这是一个 IIFE，在 DOMContentLoaded、resize、pageshow 事件触发时，进行对 html 的 font-
size 值设定，计算方式：

    
    
    font-size = document.documentElement.clientWidth / 3.75
    

为什么这么计算呢？我可以肯定的是：淘宝的工程师是按照设计 375px 的视觉稿完成的。在 375px 视觉稿下，html 的 font-size 为
100，那么如果宽度是 75px 的元素，就可以设置为 0.75rem（100 * 0.75 = 75px）；当设备宽度为 414px（iPhone8
plus）时，我们想让上述元素的宽度等比例自适应到 82.8px（75 * 414 / 375），那么在 CSS 样式为 0.74rem
不变的前提下，想计算得到 82.8px，只需 HTML font-size 变为：110.4px 即可（110.4 * 0.75 =
82.8）。那么反向过来，这个 110.4 的计算公式就是：

    
    
    document.documentElement.clientWidth / 3.75
    

当然淘宝实现响应式布局除了依靠 rem 以外，还大量运用了 flex 布局，比如页面中最复杂的布局区块：

![enter image description
here](https://images.gitbook.cn/2c80dac0-90a0-11e9-9c86-a1bad3faf0f2)

实现较为简单。

整套解决方案淘宝开源出来，叫做 flexible 布局。其实读到这里，你已经理解了这个解决方案的核心原理。

我们再来看看网易的做法，大体类似：

![enter image description
here](https://images.gitbook.cn/52412940-90a0-11e9-9c86-a1bad3faf0f2)

同样采用了 rem 布局，但区别是网易并没有 JavaScript 介入计算 html 的 font-size，而是通过媒体查询和 calc
手段，“枚举”了不同设备下不同的 HTML font-size 值。

在其页面中，较为复杂的头部 slider 组件中：

![enter image description
here](https://images.gitbook.cn/9427bc70-90a0-11e9-9c86-a1bad3faf0f2)

slider 宽度明显是 JavaScript 获取设备宽度后动态赋值的（图中为 414px），而高度采用了 rem 布局： 3.7 rem =
55.3px(calc(13.33333333vw) * 3.7)

总结一下，响应式布局并没有那么困难，我们需要掌握最基本的处理手段，在实际场景中综合运用多种套路即可实现最大限度的灵活。

### Bootstrap 栅格实现思路

Bootrap 栅格化是一个非常“伟大”的实现，我们在使用 Bootrap 布局时，可以通过添加类的方法，轻松实现栅格化，流式布局。

我们选取代表性的 BS4
官网范例，可以[在线参考](http://v4.bootcss.com/examples/dashboard/#)，或者参看以下截图，在宽屏幕下，我们看到：

![](https://images.gitbook.cn/bfe31c10-90a0-11e9-8b34-c732c3ec276d)

当屏幕宽度小于 576px 时候，我们有：

![](https://images.gitbook.cn/dc19b470-90a0-11e9-9c86-a1bad3faf0f2)

对应代码：

    
    
    <div class="col-6 col-sm-3">
        ...
    </div>
    <div class="col-6 col-sm-3">
        ...
    </div>
    <div class="col-6 col-sm-3">
        ...
    </div>
    <div class="col-6 col-sm-3">
        ...
    </div>
    

.col-6 class 样式在源码里面可以简单归纳（不完全）为：

    
    
    .col-6 {
        -webkit-box-flex: 0;
        -webkit-flex: 0 0 50%;
        -ms-flex: 0 0 50%;
        flex: 0 0 50%;
        max-width: 50%;
    }
    

.col-sm-3 class 在源码里面可以归纳为：

    
    
    .col-sm-3 {
        -webkit-box-flex: 0;
        -webkit-flex: 0 0 25%;
            -ms-flex: 0 0 25%;
                flex: 0 0 25%;
        max-width: 25%;
    }
    

我们看到，代码里设置了两个 class：col-6 col-sm-3 进行样式声明。

从上面样式代码里看到类似 `flex: 0 0 25%` 的声明，为了理解它，我们从 flex 属性入手：flex 属性是 flex-grow、flex-
shrink 和 flex-basis 的简写（类似 backgroud 是很多背景属性的简写一样），它的默认值为 0 1
auto，后两个属性可选。语法格式如下：

    
    
    .item {
        flex: none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]
    }
    

  * flex-grow：属性定义项目的放大比例，默认为 0。我们看到 Bootstrap 代码里这个值一直为 0，即如果存在剩余空间，也不放大。
  * flex-shrink：属性定义了项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小。
  * flex-basis：属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。

浏览器根据这个属性，计算主轴是否有多余空间，它可以设为跟 width 或 height 属性一样的值（比如 350px），则项目将占据固定空间。

Bootstrap 这里对 flex 设置为比例值，这也是响应式自然而然实现的基础。

但是我们想，很明显 col-6 col-sm-3 的样式属性是有冲突的，那么他们是如何做到“和平共处”交替发挥作用的呢？

事实上：

  * 在屏幕宽度大于 576px 时候，会发现 .col-sm-3 并没有起作用，这时候起作用的是 .col-6。

我们在源码里发现 .col-sm-* 的样式声明全部在

    
    
     @media (min-width: 576px) {...} 
    

的媒体查询中，这就保证了在 576px 宽度以上的屏幕，只有在媒体查询之外的 .col-* 样式声明发挥了作用。

  * 在屏幕宽度小于 576px 时候，命中媒体查询，命中 .col-sm-3 的样式声明。它的优先级一定大于 .col-6（媒体查询优先级高），这时候就保证了移动端的样式“占上风”。

再结合 col-6 col-sm-3 的样式声明，我们可以简单总结一下：Bootstrap 主要是通过百分比宽度（max-width: 50%; max-
width: 25%;），以及 flex 属性，再加上媒体查询，“三管齐下”实现了栅格化布局的主体。

当然整个过程实现还有很多其他细节，我也一直认为 Bootstrap 的源码是管理大型样式项目的优秀典范，有兴趣的读者可以参阅源码进行了解。

### 横屏适配以及其他细节问题

很多 H5 页面中，我们要区分横屏和竖屏，在不同屏幕下要显示不同的布局，所以我们需要检测在不同的场景下给定不同的样式。通常使用 JavaScript 检查：

    
    
    window.addEventListener("resize", () => {
        if (window.orientation === 180 || window.orientation === 0) { 
            console.log('竖屏')
        };
        if (window.orientation === 90 || window.orientation === -90 ){ 
            console.log('横屏')
        }  
    })
    

我们同样可以使用纯 CSS 来实现不同场景下的布局：

    
    
    @media screen and (orientation: portrait) {
      /*竖屏样式代码*/
    } 
    @media screen and (orientation: landscape) {
      /*横屏样式代码.*/
    }
    

同时这里我们在总结一下其他常见的响应式布局话题：

  * 1px 问题
  * 适配 iPhoneX 齐刘海
  * 图片自适应

这些问题都可以轻松找到解决思路，我们不再详细给出。

### 面试题：% 相对于谁

在之前的课程《前端面试必不可少的“面子工程”》中我们讲解了实现水平垂直居中的几种方式。其中absolute + transform 方案：

    
    
    .wp {
        position: relative;
    }
    .box {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
    }
    

我们用到了不止一处 % 单位。事实上，上述代码中的 % 还真代表着不一样的计算规则。第一处 50% 是指 .wrap 相对定位元素宽度和高度的 50%，而
transform 中的 50% 是指自身元素的宽高的一半。

那么在 CSS 中，这个常见的 % 单位有着什么样的规则呢？这也是一道很好的面试题目，我们在这一部分进行梳理。

  * position: absolute 中的 %

对于设置绝对定位 position absolute 的元素，我们可以使用 left right
表示其偏移量，我们把这个元素的祖先元素中第一个存在定位属性的元素成为参照物元素，其中的 % 是相对于参照物的，left 相对于参照物的 width，top
相对于这个参照物的 height。

  * position: relative 中的 %

对于设置相对定位 position relative 的元素，% 的数值是相对与自身的，left 相对于自己的 width，top 相对于自己的
height。

  * position: fixed 中的 %

对于设置固定定位 position fixed 的元素，% 的数值是相对于视口的，left 相对于视口的 width，top 相对于视口的 height。

  * margin 和 padding 的 %

margin 和 padding 当中的 % 非常特殊，它是相对于父元素的宽度。没错，margin-top: 30%，相当于父元素宽度的 30%

  * border-radius 的 %

想想我们经常对一个正方形元素设置：

    
    
    border-radius: 50%
    

得到一个圆形，因此不难发现这里的 % 也是相对于自身宽高的。

  * background-size 的 %

background-size 的百分比和 border-radius 一样，也是相对于自身的宽高。

  * transform： translate

transform 的 translate 属性 % 是相对于自身的宽高，这也是我们上述代码能够实现居中的原因。

  * text-indent 的 %

text-indent 这个属性可以设置首行缩进，当使用 % 时，它是相对于父元素的 width。

  * font-size 的 %

相对于父元素的字体大小。

  * line-height 的 %

line-height 设置行高时，如果单位为 %，则相对于该元素的 font-size 数值。

这些就是我们常见的使用 % 的情况，还是很灵活多变的，具体细节都可以在 CSS 规范中找到。要求开发者的是了解常见的以及特殊的 % 场景。

### 深入：flex 布局和传统 float 布局性能对比

最后这部分，让我们来深入一个关于性能的话题：

> flex 布局对性能的影响主要体现在哪方面？

这个问题比较“偏门”，很多读者在平时应该没有想过。这里指出来的目的是开拓思路，让我们更加合理地认识 CSS 布局。

我们先思考一下 **flex 布局对性能到底有什么影响，或者有多大影响。**

**首先性能问题一定是一个相对概念** ，flex 布局相比正常的 block layout（non-float）性能开销一定更大。事实上，block
layout 永远都是 **single-pass** ，算法进行布局，而 flex 布局却总会激发 **multi-pass codepaths**
算法布局。比如常用的 flex-align: stretch 通常都是 2-pass，这是无可争议且难以避免的短板，天生基因决定。（关于 single-
pass 和 multi-pass codepaths，图形学算法问题这里不再展开，读者了解 single-pass 成本更低即可）

口说无凭，我们来做一个对比，display: table VS display: flex。

这里重复 1000 次这样的 DOM：

    
    
    <div class="wrap">
        <div class="cell description">Item Description</div>
        <div class="cell add">Add</div>
        <div class="cell remove">Remove</div>
    </div>
    

分别使用 flex 和 table 布局，并采用 [Navigation Timing
API](https://link.zhihu.com/?target=http%3A//www.w3.org/TR/navigation-timing/)
进行布局速度测量。代码如下：

    
    
    <script type="text/javascript">
        ;(function TimeThisMother() {
            window.onload = function(){
                setTimeout(function(){
                var t = performance.timing;
                    alert("Speed of selection is: " + (t.loadEventEnd - t.responseEnd) + " milliseconds");
                }, 0);
            };
        })();
    </script>
    

得到结果：

  * flex 布局：Speed of selection is: 248 milliseconds；
  * table 布局：Speed of selection is: 282 milliseconds。

flex 布局要比 table 布局似乎更快。

曾经一个名叫 Chris Coyier 的开发者，实现了这样一个 flex 布局生成器。

![enter image description
here](https://images.gitbook.cn/16a75430-90a1-11e9-afed-87af38460e36)

注意右上角的滑动条，越向右滑，页面不同颜色区块越多（截图上滚动条已经很短了，证明页面已经很长，布局区块很多），在如此大规模全面使用 flex
布局下，页面丝毫没有任何卡顿。

如上图，打开 Chrome Dev Tools > Timeline，单击 record 按钮，滑动滑块并停止。我们得到瀑布流紫色部分，显示性能效果良好。

当然这样的“模拟”距离真实场景也许较远，不排除如果页面中存在很多图片就会使得性能开销激增，可能使用 flex
某些属性也会付出昂贵的代价。但是一般场景使用，我认为没有必要去担心 flex 布局性能问题，至少它比别的方案靠谱（先不论兼容性）。

**读者可以去 codepen 进行体验：**

[Generate a Crapload of
Flexbox​codepen.io![图标](https://images.gitbook.cn/4107b7b0-90a1-11e9-8b34-c732c3ec276d)](https://link.zhihu.com/?target=https%3A//codepen.io/chriscoyier/pen/LGmkn)

最后，需要格外提出的是： **新版 flex 布局一般比旧版布局模型更快，同样也比基于浮动的布局模型更快。**

这里来特殊对比一下 flex 布局和浮动布局在性能上的表现。

下图显示了在 1,300 个框上使用浮动的布局开销。

![enter image description
here](https://images.gitbook.cn/581b0150-90a1-11e9-8b34-c732c3ec276d)

我们更新此示例以使用 flex，则出现不同的情况：

![enter image description
here](https://images.gitbook.cn/71f58140-90a1-11e9-9c86-a1bad3faf0f2)

很明显，对于相同数量的元素和相同的视觉外观，flex 布局的时间要少得多（本例中分别为 3.5 毫秒和 14
毫秒）。对比来源：[developers.google.com](https://link.zhihu.com/?target=http%3A//developers.google.com/)。

**最后，布局性能的开销，一般直接考虑如下因素：**

  * 需要布局的元素数量
  * 布局的复杂性

相对地， **对于布局性能建议主要有：**

  * 应尽可能避免触发布局（layout／reflow）
  * 避免强制同步布局和布局抖动

这些面就更大了，我们会在页面性能优化课程中继续这个话题。这里通过结论，想告诉大家的是：不论什么样的布局，在性能上一般很难成为瓶颈。同时另一方面，CSS
看似简单，却也和性能息息相关。

### 总结

这一讲我们分析了实现响应式布局的常用手段，并结合实际案例加以剖析；同时讨论了布局方案对于页面性能的影响。到此为止，HTML 和 CSS
相关的内容终于告一段落了，读者应该能有一个清晰的认识：

  * HTML 和 CSS 很重要
  * HTML 和 CSS 如果不花心思，也不好学

但是关于 HTML 和 CSS 我们更应该注重实战，也许可以暂时不用“系统化”地去了解，但是遇见一个案例，就去攻克一个案例，慢慢地，你也能成为 HTML 和
CSS 专家！

### 分享交流

阅读文章过程中有任何疑问随时可以跟其他小伙伴讨论，或者直接向作者 LucasHC 提问（作者看到后抽空回复）。 **你的分享不仅帮助他人，更会提升自己。**

你也可以说说自己最想了解的主题，课程内容会根据部分读者的意见和建议迭代和完善。

此外，我们为本课程付费读者创建了《前端开发核心知识进阶》微信交流群，以方便更有针对性地讨论课程相关问题（入群请到第1-2课末尾添加 GitChat
小助手伽利略的微信，并注明「前端核心」，谢谢~）



## 触类旁通多种框架

框架在任何一种语言编程范畴中都扮演了举足轻重的地位，前端尤是如此。目前流行的前端框架三驾马车：Angular、React 和
Vue，它们各有特点和受众，都值得开发者认真思考和学习。那么我们在精力有限的情况下，如何做到“触类旁通”、如何提取框架共性、提高学习和应用效率呢？

我们这一讲就来剖析这些框架的特点和本质，介绍如何学习并使用这些框架，进而了解前端框架的真谛。

相关知识点如下：

![](https://images.gitbook.cn/ff71bef0-9234-11e9-b195-bf69c03485a0)

我把现代框架的关键词进行提炼，掌握这些关键词，是我们学习的重要环节。这些关键词有：双向绑定、依赖收集、发布订阅模式、MVVM / MVC、虚拟 DOM、虚拟
DOM diff、模版编译等。

### 响应式框架基本原理

我们不再赘述响应式或数据双向绑定的基本概念，这里直接思考其行为：直观上，数据在变化时，不再需要开发者去手动更新视图，而视图会根据变化的数据“自动”进行更新。想完成这个过程，我们需要：

  * 收集视图依赖了哪些数据
  * 感知被依赖数据的变化
  * 数据变化时，自动“通知”需要更新的视图部分，并进行更新

道理很简单，这个思考过程换成对应的技术概念就是：

  * 依赖收集
  * 数据劫持 / 数据代理
  * 发布订阅模式

接下来，我们一步步拆解。

#### 数据劫持与代理

感知数据变化的方法很直接，就是进行数据劫持或数据代理。我们往往通过 Object.defineProperty 实现。这个方法可以定义数据的 getter
和 setter，具体用法不再赘述。下面来看一个场景：

    
    
    let data = {
      stage: 'GitChat',
      course: {
        title: '前端开发进阶',
        author: 'Lucas',
        publishTime: '2018 年 5 月'
      }
    }
    
    Object.keys(data).forEach(key => {
      let currentValue = data[key]
    
      Object.defineProperty(data, key, {
        enumerable: true,
        configurable: false,
        get() {
          console.log(`getting ${key} value now, getting value is:`, currentValue)
          return currentValue
        },
        set(newValue) {
          currentValue = newValue
          console.log(`setting ${key} value now, setting value is`, currentValue)
        }
      })
    }) 
    

这段代码对 data 数据的 getter 和 setter 进行定义拦截，当我们读取或者改变 data 的值时：

    
    
    data.course
    
    // getting course value now, getting value is: {title: "前端开发进阶", author: "Lucas", publishTime: "2018 年 5 月"}
    
    
    
    data.course = '前端开发进阶2'
    // setting course value now, setting value is 前端开发进阶2
    

但是这种实现有一个问题，例如：

    
    
    data.course.title = '前端开发进阶2'
    
    // getting course value now, getting value is: {title: "前端开发进阶", author: "Lucas", publishTime: "2018 年 5 月"}
    

只会有 getting course value now, getting value is: {title: "前端开发进阶", author:
"Lucas", publishTime: "2018 年 5 月"} 的输出，这是因为我们尝试读取了 data.course 信息。但是修改
data.course.title 的信息并没有打印出来。

出现这个问题的原因是因为我们的实现代码只进行了一层 Object.defineProperty，或者说只对 data 的第一层属性进行了
Object.defineProperty，对于嵌套的引用类型数据结构：data.course，我们同样应该进行拦截。

为了达到深层拦截的目的，将 Object.defineProperty 的逻辑抽象为 observe 函数，并改用递归实现：

    
    
    let data = {
      stage: 'GitChat',
      course: {
        title: '前端开发进阶',
        author: 'Lucas',
        publishTime: '2018 年 5 月'
      }
    }
    
    const observe = data => {
      if (!data || typeof data !== 'object') {
          return
      }
      Object.keys(data).forEach(key => {
        let currentValue = data[key]
    
        observe(currentValue)
    
        Object.defineProperty(data, key, {
          enumerable: true,
          configurable: false,
          get() {
            console.log(`getting ${key} value now, getting value is:`, currentValue)
            return currentValue
          },
          set(newValue) {
            currentValue = newValue
            console.log(`setting ${key} value now, setting value is`, currentValue)
          }
        })
      }) 
    }
    
    observe(data)
    

这样一来，就实现了深层数据拦截：

    
    
    data.course.title = '前端开发进阶2'
    
    // getting course value now, getting value is: {// ...}
    // setting title value now, setting value is 前端开发进阶2
    

请注意，我们在 set 代理中，并没有对 newValue 再次递归进行 observe(newValue)。也就是说，如果赋值是一个引用类型：

    
    
    data.course.title = {
        title: '前端开发进阶2'
    }
    

无法实现对 data.course.title 数据的观察。这里为了简化学习成本，默认修改的数值符合语义，都是基本类型。

在尝试对 data.course.title 赋值时，首先会读取 data.course，因此输出：getting course value now,
getting value is: {// ...}，赋值后，触发 data.course.title 的 setter，输出：setting title
value now, setting value is 前端开发进阶2。

因此我们总结出：对数据进行拦截并不复杂，这也是很多框架实现的第一步。

#### 监听数组变化

如果上述数据中某一项变为数组：

    
    
    let data = {
      stage: 'GitChat',
      course: {
        title: '前端开发进阶',
        author: ['Lucas', 'Ronaldo'],
        publishTime: '2018 年 5 月'
      }
    }
    
    const observe = data => {
      if (!data || typeof data !== 'object') {
          return
      }
      Object.keys(data).forEach(key => {
        let currentValue = data[key]
    
        observe(currentValue)
    
        Object.defineProperty(data, key, {
          enumerable: true,
          configurable: false,
          get() {
            console.log(`getting ${key} value now, getting value is:`, currentValue)
            return currentValue
          },
          set(newValue) {
            currentValue = newValue
            console.log(`setting ${key} value now, setting value is`, currentValue)
          }
        })
      }) 
    }
    
    observe(data)
    
    
    data.course.author.push('Messi')
    // getting course value now, getting value is: {//...}
    // getting author value now, getting value is: (2) [(...), (...)]
    

我们只监听到了 data.course 以及 data.course.author 的读取，而数组 push 行为并没有被拦截。这是因为
Array.prototype 上挂载的方法并不能触发 data.course.author 属性值的 setter，由于这并不属于做赋值操作，而是
push API 调用操作。然而对于框架实现来说，这显然是不满足要求的，当数组变化时我们应该也有所感知。

Vue 同样存在这样的问题，它的解决方法是：将数组的常用方法进行重写，进而覆盖掉原生的数组方法，重写之后的数组方法需要能够被拦截。

实现逻辑如下：

    
    
    const arrExtend = Object.create(Array.prototype)
    const arrMethods = [
      'push',
      'pop',
      'shift',
      'unshift',
      'splice',
      'sort',
      'reverse'
    ]
    
    arrMethods.forEach(method => {
      const oldMethod = Array.prototype[method]
      const newMethod = function(...args) {
        oldMethod.apply(this, args)
        console.log(`${method} 方法被执行了`)
      }
      arrExtend[method] = newMethod
    })
    

对于数组原生的 7 个方法：

  * push
  * pop
  * shift
  * unshift
  * splice
  * sort
  * reverse

进行重写，核心操作还是调用原生方法：oldMethod.apply(this, args)，除此之外可以在调用 oldMethod.apply(this,
args) 前后加入我们需要的任何逻辑。示例代码中加入了一行 console.log。使用时：

    
    
    Array.prototype = Object.assign(Array.prototype, arrExtend)
    
    let array = [1, 2, 3]
    array.push(4)
    // push 方法被执行了
    

对应我们的代码：

    
    
    const arrExtend = Object.create(Array.prototype)
    const arrMethods = [
      'push',
      'pop',
      'shift',
      'unshift',
      'splice',
      'sort',
      'reverse'
    ]
    
    arrMethods.forEach(method => {
      const oldMethod = Array.prototype[method]
      const newMethod = function(...args) {
        oldMethod.apply(this, args)
        console.log(`${method} 方法被执行了`)
      }
      arrExtend[method] = newMethod
    })
    
    Array.prototype = Object.assign(Array.prototype, arrExtend)
    
    
    let data = {
      stage: 'GitChat',
      course: {
        title: '前端开发进阶',
        author: ['Lucas', 'Ronaldo'],
        publishTime: '2018 年 5 月'
      }
    }
    
    const observe = data => {
      if (!data || typeof data !== 'object') {
          return
      }
      Object.keys(data).forEach(key => {
        let currentValue = data[key]
    
        observe(currentValue)
    
        Object.defineProperty(data, key, {
          enumerable: true,
          configurable: false,
          get() {
            console.log(`getting ${key} value now, getting value is:`, currentValue)
            return currentValue
          },
          set(newValue) {
            currentValue = newValue
            console.log(`setting ${key} value now, setting value is`, currentValue)
          }
        })
      }) 
    }
    
    observe(data)
    
    data.course.author.push('Messi')
    

将会输出：

    
    
    getting course value now, getting value is: {//...}
    getting author value now, getting value is: (2) [(...), (...)]
    // push 方法被执行了
    

这种 monkey patch 本质是重写原生方法，这天生不是很安全，也很不优雅，能有更好的实现吗？

答案是有的，使用 ES Next 的新特性——Proxy，之前也介绍过，它可以完成对数据的代理。

那么这两种方式有何区别呢？请继续阅读。

#### Object.defineProperty VS Proxy

我们首先尝试使用 Proxy 来完成代码重构：

    
    
    let data = {
      stage: 'GitChat',
      course: {
        title: '前端开发进阶',
        author: ['Lucas'],
        publishTime: '2018 年 5 月'
      }
    }
    
    const observe = data => {
      if (!data || Object.prototype.toString.call(data) !== '[object Object]') {
          return
      }
    
      Object.keys(data).forEach(key => {
        let currentValue = data[key]
        // 事实上 proxy 也可以对函数类型进行代理。这里只对承载数据类型的 object 进行处理，读者了解即可。
        if (typeof currentValue === 'object') {
          observe(currentValue)
          data[key] = new Proxy(currentValue, {
            set(target, property, value, receiver) {
              // 因为数组的 push 会引起 length 属性的变化，所以 push 之后会触发两次 set 操作，我们只需要保留一次即可，property 为 length 时，忽略
              if (property !== 'length') {
                console.log(`setting ${key} value now, setting value is`, currentValue)
              }
              return Reflect.set(target, property, value, receiver)
            }
          })
        }
        else {
          Object.defineProperty(data, key, {
            enumerable: true,
            configurable: false,
            get() {
              console.log(`getting ${key} value now, getting value is:`, currentValue)
              return currentValue
            },
            set(newValue) {
              currentValue = newValue
              console.log(`setting ${key} value now, setting value is`, currentValue)
            }
          })
        }
      }) 
    }
    
    observe(data)
    

此时对数组进行操作：

    
    
    data.course.author.push('messi')
    // setting author value now, setting value is ["Lucas"]
    

已经符合我们的需求了。注意这里在使用 Proxy 进行代理时，并没有对 getter 进行代理，因此上述代码的输出结果并不像之前使用
Object.defineProperty 那样也会有 getting value 输出。

整体实现并不难理解，需要读者了解最基本的 Proxy 知识。简单总结一下，对于数据键值为基本类型的情况，我们使用
Object.defineProperty；对于键值为对象类型的情况，继续递归调用 observe 方法，并通过 Proxy 返回的新对象对
data[key] 重新赋值，这个新值的 getter 和 setter 已经被添加了代理。

了解了 Proxy 实现之后，我们对 Proxy 实现数据代理和 Object.defineProperty 实现数据拦截进行对比，会发现：

  * Object.defineProperty 不能监听数组的变化，需要进行数组方法的重写
  * Object.defineProperty 必须遍历对象的每个属性，且对于嵌套结构需要深层遍历
  * Proxy 的代理是针对整个对象的，而不是对象的某个属性，因此不同于 Object.defineProperty 的必须遍历对象每个属性，Proxy 只需要做一层代理就可以监听同级结构下的所有属性变化，当然对于深层结构，递归还是需要进行的
  * Proxy 支持代理数组的变化
  * Proxy 的第二个参数除了 set 和 get 以外，可以有 13 种拦截方法，比起 Object.defineProperty() 更加强大，这里不再一一列举
  * Proxy 性能将会被底层持续优化，而 Object.defineProperty 已经不再是优化重点

### 模版编译原理介绍

到此，我们了解了如何监听数据的变化，那么下一步呢？以类 Vue 框架为例，我们看看一个典型的用法：

    
    
    <body>
      <div id="app">
        <h1>{{stage}} 平台课程：{{course.title}}</h1>
        <p>{{course.title}} 是 {{course.author}} 发布的课程</p>
        <p>发布时间为 {{course.publishTime}} </p>
      </div>
    
      <script>
        let vue = new Vue({ 
          ele: '#app', 
          data: {
            stage: 'GitChat',
            course: {
              title: '前端开发进阶',
              author: 'Lucas',
              publishTime: '2018 年 5 月'
            },
          }
        })
      </script>
    </body>
    

其中模版变量使用了 {{}} 的表达方式输出模版变量。最终输出的 HTML
内容应该被合适的数据进行填充替换，因此还需要一步编译过程，该过程任何框架或类库中都是相通的，比如 React 中的 JSX，也是编译为
React.createElement，并在生成虚拟 DOM 时进行数据填充。

我们这里简化过程，将模版内容：

    
    
    <div id="app">
        <h1>{{stage}} 平台课程：{{course.title}}</h1>
        <p>{{course.title}} 是 {{course.author}} 发布的课程</p>
        <p>发布时间为 {{course.publishTime}} </p>
    </div>
    

输出为真实 HTML 即可。

#### 模版编译实现

一提到这样的“模版编译”过程，很多开发者都会想到词法分析，也许都会感到头大。其实原理很简单，就是使用正则 +
遍历，有时也需要一些算法知识，我们来看现在的场景，只需要对 #app 节点下内容进行替换，通过正则识别出模版变量，获取对应的数据即可：

    
    
    compile(document.querySelector('#app'), data)
    
    function compile(el, data) {
      let fragment = document.createDocumentFragment()
    
      while (child = el.firstChild) {
        fragment.appendChild(child)
      }
    
      // 对 el 里面的内容进行替换
      function replace(fragment) {
        Array.from(fragment.childNodes).forEach(node => {
          let textContent = node.textContent
          let reg = /\{\{(.*?)\}\}/g
    
          if (node.nodeType === 3 && reg.test(textContent)) {
             const nodeTextContent = node.textContent
            const replaceText = () => {
                node.textContent = nodeTextContent.replace(reg, (matched, placeholder) => {
                    return placeholder.split('.').reduce((prev, key) => {
                        return prev[key]
                    }, data)
    
                })
            }
    
            replaceText()
          }
    
          // 如果还有子节点，继续递归 replace
          if (node.childNodes && node.childNodes.length) {
            replace(node)
          }
        })
      }
    
      replace(fragment)
    
      el.appendChild(fragment)
      return el
    }
    

代码分析：我们使用 fragment 变量储存生成的真实 HTML 节点内容。通过 replace 方法对 {{变量}} 进行数据替换，同时 {{变量}}
的表达只会出现在 nodeType === 3 的文本类型节点中，因此对于符合 `node.nodeType === 3 &&
reg.test(textContent)` 条件的情况，进行数据获取和填充。我们借助字符串 replace 方法第二个参数进行一次性替换，此时对于形如
{{data.course.title}} 的深层数据，通过 reduce 方法，获得正确的值。

因为 DOM 结构可能是多层的，所以对存在子节点的节点，依然使用递归进行 replace 替换。

这个编译过程比较简单，没有考虑到边界情况，只是单纯完成模版变量到真实 DOM 的转换，读者只需体会简单道理即可。

#### 双向绑定实现

上述实现是单向的，数据变化引起了视图变化，那么如果页面中存在一个输入框，如何触发数据变化呢？比如：

    
    
    <input v-model="inputData" type = "text" >
    

我们需要在模版编译中，对于存在 v-model 属性的 node 进行事件监听，在输入框输入时，改变 v-model 属性值对应的数据即可（这里为
inputData），增加 compile 中的 replace 方法逻辑，对于 node.nodeType === 1 的 DOM 类型，伪代码如下：

    
    
    function replace(el, data) {
      // 省略...
      if (node.nodeType === 1) {
    
        let attributesArray = node.attributes
    
        Array.from(attributesArray).forEach(attr => {
          let attributeName = attr.name
          let attributeValue = attr.value
    
          if (name.includes('v-')) {
            node.value = data[attributeValue]
          }
    
          node.addEventListener('input', e => {
            let newVal = e.target.value
            data[attributeValue] = newVal
            // ...
            // 更改数据源，触发 setter
            // ...
          })
        })
    
      }
    
      if (node.childNodes && node.childNodes.length) {
        replace(node)
      }
    }
    

### 发布订阅模式简单应用

作为前端开发人员，我们对于所谓的“事件驱动”理念——即“事件发布订阅模式（Pub/Sub 模式）”一定再熟悉不过了。这种模式在 JavaScript
里面有与生俱来的基因：我们可以认为 JavaScript 本身就是事件驱动型语言，比如，应用中对一个 button
进行了事件绑定，用户点击之后就会触发按钮上面的 click 事件。这是因为此时有特定程序正在监听这个事件，随之触发了相关的处理程序。

这个模式的一个好处之一在于能够解耦，实现“高内聚、低耦合”的理念。这种模式对于我们框架的设计同样也不可或缺。请思考：通过前面内容的学习，我们了解了如何监听数据的变化。如果最终想实现响应式
MVVM，或所谓的双向绑定，那么还需要根据这个数据变化作出相应的视图更新。这个逻辑和我们在页面中对 button 绑定事件处理函数是多么相近。

那么这样一个“熟悉的”模式应该怎么实现呢，又该如何在框架中具体应用呢？看代码：

    
    
    class Notify {
      constructor() {
        this.subscribers = []
      }
      add(handler) {
        this.subscribers.push(handler)
      }
      emit() {
        this.subscribers.forEach(subscriber => subscriber())
      }
    }
    

使用：

    
    
    let notify = new Notify()
    
    notify.add(() => {
        console.log('emit here')
    })
    
    notify.emit()
    // emit here
    

这就是一个简单实现的“事件发布订阅模式”，当然代码只是启发思路，真实应用还比较“粗糙”，没有进行事件名设置，APIs
也并不丰富，但完全能够说明问题了。其实读者翻看 Vue 源码，也能了解 Vue 中的发布订阅模式很简单。

### MVVM 融会贯通

回顾一下前面的基本内容：数据拦截和代理、发布订阅模式、模版编译，那么如何根据这些概念实现一个 MVVM 框架呢？其实不管是 Vue
还是其他类库或框架，其解决思想都是建立在前文所述概念之上的。

我们来进行串联，整个过程是：首先对数据进行深度拦截或代理，对每一个属性的 getter 和 setter
进行“加工”，该“加工”具体做些什么后面马上会有说明。在模版初次编译时，解析指令（如 v-model），并进行依赖收集（{{变量}}），订阅数据的变化。

这里的依赖收集过程具体指：当调用 compiler 中的 replace
方法时，我们会读取数据进行模版变量的替换，这时候“读取数据时”需要做一个标记，用来表示“我依赖这一项数据”，因此我要订阅这个属性值的变化。Vue 中定义一个
Watcher 类来表示观察订阅依赖。这就实现了整套流程，换个思路再复述一遍：我们知道模版编译过程中会读取数据，进而触发数据源属性值的
getter，因此上面所说的数据代理的“加工”就是在数据监听的 getter 中记录这个依赖，同时在 setter
触发数据变化时，执行依赖对应的相关操作，最终触发模版中数据的变化。

我们抽象成流程图来理解：

![enter image description
here](https://images.gitbook.cn/02926aa0-925b-11e9-a0f8-2d0a45937cae)

这也是 Vue 框架（类库）的基本架构图。由此看出，Vue 的实现，或者大部分 MVVM 的实现，就是我们本节课程介绍的概念组合应用。

关于框架的对比剖析，更多话题我们留在《第 4-7 课：从框架和类库，我们该学到什么》一课中介绍。

### 揭秘虚拟 DOM

我们来看现代框架中另一个重头戏——虚拟 DOM。虚拟 DOM 这个概念其实并没有那么新，甚至在前端三大框架问世之前，虚拟 DOM 就已经存在了，只不过
React 创造性的应用了虚拟 DOM，为前端发展带来了变革。Vue 2.0 也很快跟进，使得虚拟 DOM 彻底成为现代框架的重要基因。简单来说，虚拟
DOM 就是用数据结构表示 DOM 结构，它并没有真实 append 到 DOM 上，因此称之为“虚拟”。

应用虚拟 DOM 的收益也很直观：操作数据结构远比和浏览器交互去操作 DOM 快很多。请读者准确理解这句话：操作数据结构是指改变对象（虚拟
DOM），这个过程比修改真实 DOM 快很多。但虚拟 DOM 也最终是要挂载到浏览器上成为真实 DOM 节点，因此使用虚拟 DOM 并不能使得操作 DOM
的数量减少，但能够精确地获取最小的、最必要的操作 DOM 的集合。

这样一来，我们抽象表示 DOM，每次通过 DOM diff 计算出视图前后更新的最小差异，再去把最小差异应用到真实 DOM
上的做法，无疑更为可靠，性能更有保障。

那我们该如何表示虚拟 DOM 呢？又该如何产出虚拟 DOM 呢？

直观上我们看这样一段 DOM 结构：

    
    
    <ul id="chapterList">
      <li class="chapter">chapter1</li>
      <li class="chapter">chapter2</li>
      <li class="chapter">chapter3</li>
    </ul>
    

如果用 JavaScript 来表示，我们采用对象结构：

    
    
    const chapterListVirtualDom = {
      tagName: 'ul',
      attributes: {
        id: 'chapterList'
      },
      children: [
        { tagName: 'li', attributes: { class: 'chapter' }, children: ['chapter1'] },
        { tagName: 'li', attributes: { class: 'chapter' }, children: ['chapter2'] },
        { tagName: 'li', attributes: { class: 'chapter' }, children: ['chapter3'] },
      ]
    }
    

很好理解：tagName 表示虚拟 DOM 对应的真实 DOM 标签类型；attributes 是一个对象，表示真实 DOM
节点上所有的属性；children 对应真实 DOM 的 childNodes，其中 childNodes 每一项又是类似的结构。

我们来实现一个虚拟 DOM 生成类，用于生产虚拟 DOM：

    
    
    class Element {
      constructor(tagName, attributes = {}, children = []) {
        this.tagName = tagName
        this.attributes = attributes
        this.children = children
      }
    }
    
    function element(tagName, attributes, children) {
      return new Element(tagName, attributes, children)
    }
    

上述虚拟 DOM 就可以这样生成：

    
    
    const chapterListVirtualDom = element('ul', { id: 'list' }, [
      element('li', { class: 'chapter' }, ['chapter1']),
      element('li', { class: 'chapter' }, ['chapter2']),
      element('li', { class: 'chapter' }, ['chapter3'])
    ])
    

如图：

![enter image description
here](https://images.gitbook.cn/23d3e7c0-925b-11e9-a0f8-2d0a45937cae)

是不是很简单？我们继续完成虚拟 DOM 向真实 DOM 节点的生成。首先实现一个 setAttribute 方法，后续的代码都将使用
setAttribute 方法来对 DOM 节点进行属性设置。

    
    
    const setAttribute = (node, key, value) => {
      switch (key) {
        case 'style':
          node.style.cssText = value
          break
        case 'value':
          let tagName = node.tagName || ''
          tagName = tagName.toLowerCase()
          if (
            tagName === 'input' || tagName === 'textarea'
          ) {
            node.value = value
          } else {
            // 如果节点不是 input 或者 textarea, 则使用 setAttribute 去设置属性
            node.setAttribute(key, value)
          }
          break
        default:
          node.setAttribute(key, value)
          break
      }
    }
    

Element 类中加入 render 原型方法，该方法的目的是根据虚拟 DOM 生成真实 DOM 片段：

    
    
    class Element {
      constructor(tagName, attributes = {}, children = []) {
        this.tagName = tagName
        this.attributes = attributes
        this.children = children
      }
    
      render () {
        let element = document.createElement(this.tagName)
        let attributes = this.attributes
    
         for (let key in attributes) {
            setAttribute(element, key, attributes[key])
         }
    
        let children = this.children
    
        children.forEach(child => {
          let childElement = child instanceof Element
            ? child.render() // 若 child 也是虚拟节点，递归进行
            : document.createTextNode(child)  // 若是字符串，直接创建文本节点
          element.appendChild(childElement)
        })
    
        return element
      }
    }
    
    function element (tagName, attributes, children) {
      return new Element(tagName, attributes, children)
    }
    

实现也不困难，我们借助工具方法：setAttribute 进行属性的创建；对 children 每一项类型进行判断，如果是 Element
实例，进行递归调用 child 的 render 方法；直到遇见文本节点类型，进行内容渲染。

有了真实的 DOM 节点片段，我们趁热打铁，将真实的 DOM 节点渲染到浏览器上，实现 renderDOM 方法：

    
    
    const renderDom = (element, target) => {
      target.appendChild(element)
    }
    

执行代码：

    
    
    const setAttribute = (node, key, value) => {
      switch (key) {
        case 'style':
          node.style.cssText = value
          break
        case 'value':
          let tagName = node.tagName || ''
          tagName = tagName.toLowerCase()
          if (
            tagName === 'input' || tagName === 'textarea'
          ) {
            node.value = value
          } else {
            // 如果节点不是 input 或者 textarea，则使用 setAttribute 去设置属性
            node.setAttribute(key, value)
          }
          break
        default:
          node.setAttribute(key, value)
          break
      }
    }
    
    class Element {
      constructor(tagName, attributes = {}, children = []) {
        this.tagName = tagName
        this.attributes = attributes
        this.children = children
      }
    
      render () {
        let element = document.createElement(this.tagName)
        let attributes = this.attributes
    
         for (let key in attributes) {
            setAttribute(element, key, attributes[key])
         }
    
        let children = this.children
    
        children.forEach(child => {
          let childElement = child instanceof Element
            ? child.render() // 若 child 也是虚拟节点，递归进行
            : document.createTextNode(child)  // 若是字符串，直接创建文本节点
          element.appendChild(childElement)
        })
    
        return element
      }
    }
    
    function element (tagName, attributes, children) {
      return new Element(tagName, attributes, children)
    }
    
    const renderDom = (element, target) => {
      target.appendChild(element)
    }
    
    const chapterListVirtualDom = element('ul', { id: 'list' }, [
      element('li', { class: 'chapter' }, ['chapter1']),
      element('li', { class: 'chapter' }, ['chapter2']),
      element('li', { class: 'chapter' }, ['chapter3'])
    ])
    
    const dom = chapterListVirtualDom.render()
    
    renderDom(dom, document.body)
    

得到如图：

![enter image description
here](https://images.gitbook.cn/43b5d4e0-925b-11e9-a8e5-21b5567b38f4)

#### 虚拟 DOM diff

有了上述基础，我们可以产出一份虚拟 DOM，并渲染在浏览器中。当用户在特定操作后，会产出新的一份虚拟 DOM，如何得出前后两份虚拟 DOM
的差异，并交给浏览器需要更新的结果呢？这就涉及到 DOM diff 的过程。

直观上，因为虚拟 DOM 是个树形结构，所以我们需要对两份虚拟 DOM 进行递归比较，将变化存储在一个变量 patches 中：

    
    
    const diff = (oldVirtualDom, newVirtualDom) => {
        let patches = {}
    
        // 递归树，比较后的结果放到 patches
        walkToDiff(oldVirtualDom, newVirtualDom, 0, patches)
    
         // 返回 diff 结果 
        return patches
    }
    

walkToDiff 前两个参数是两个需要比较的虚拟 DOM 对象；第三个参数记录 nodeIndex，在删除节点时使用，初始为
0；第四个参数是一个闭包变量，记录 diff 结果：

    
    
    let initialIndex = 0
    
    const walkToDiff = (oldVirtualDom, newVirtualDom, index, patches) => {
      let diffResult = []
    
      // 如果 newVirtualDom 不存在，说明该节点被移除，我们将 type 为 REMOVE 的对象推进 diffResult 变量，并记录 index
      if (!newVirtualDom) {
        diffResult.push({
          type: 'REMOVE',
          index
        })
      }
      // 如果新旧节点都是文本节点，是字符串
      else if (typeof oldVirtualDom === 'string' && typeof newVirtualDom === 'string') {
        // 比较文本是否相同，如果不同则记录新的结果
        if (oldVirtualDom !== newVirtualDom) {
          diffResult.push({
            type: 'MODIFY_TEXT',
            data: newVirtualDom,
            index
          })
        }
      }
      // 如果新旧节点类型相同
      else if (oldVirtualDom.tagName === newVirtualDom.tagName) {
        // 比较属性是否相同
        let diffAttributeResult = {}
    
        for (let key in oldVirtualDom) {
          if (oldVirtualDom[key] !== newVirtualDom[key]) {
            diffAttributeResult[key] = newVirtualDom[key]
          }
        }
    
        for (let key in newVirtualDom) {
          // 旧节点不存在的新属性
          if (!oldVirtualDom.hasOwnProperty(key)) {
              diffAttributeResult[key] = newVirtualDom[key]
          }
        }
    
        if (Object.keys(diffAttributeResult).length > 0) {
            diffResult.push({ 
              type: 'MODIFY_ATTRIBUTES', 
              diffAttributeResult 
            })
        }
    
        // 如果有子节点，遍历子节点
        oldVirtualDom.children.forEach((child, index) => {
          walkToDiff(child, newVirtualDom.children[index], ++initialIndex, patches)
        })
      }
      // else 说明节点类型不同，被直接替换了，我们直接将新的结果 push
      else {
        diffResult.push({ 
          type: 'REPLACE', 
          newVirtualDom
        })
      }
    
      if (!oldVirtualDom) {
        diffResult.push({ 
          type: 'REPLACE', 
          newVirtualDom
        })
      }
    
      if (diffResult.length) {
        patches[index] = diffResult
      }
    }
    

我们最后将所有代码放在一起：

    
    
    const setAttribute = (node, key, value) => {
      switch (key) {
        case 'style':
          node.style.cssText = value
          break
        case 'value':
          let tagName = node.tagName || ''
          tagName = tagName.toLowerCase()
          if (
            tagName === 'input' || tagName === 'textarea'
          ) {
            node.value = value
          } else {
            // 如果节点不是 input 或者 textarea，则使用 setAttribute 去设置属性
            node.setAttribute(key, value)
          }
          break
        default:
          node.setAttribute(key, value)
          break
      }
    }
    
    class Element {
      constructor(tagName, attributes = {}, children = []) {
        this.tagName = tagName
        this.attributes = attributes
        this.children = children
      }
    
      render () {
        let element = document.createElement(this.tagName)
        let attributes = this.attributes
    
         for (let key in attributes) {
            setAttribute(element, key, attributes[key])
         }
    
        let children = this.children
    
        children.forEach(child => {
          let childElement = child instanceof Element
            ? child.render() // 若 child 也是虚拟节点，递归进行
            : document.createTextNode(child)  // 若是字符串，直接创建文本节点
          element.appendChild(childElement)
        })
    
        return element
      }
    }
    
    function element (tagName, attributes, children) {
      return new Element(tagName, attributes, children)
    }
    
    const renderDom = (element, target) => {
      target.appendChild(element)
    }
    
    const diff = (oldVirtualDom, newVirtualDom) => {
      let patches = {}
    
      // 递归树 比较后的结果放到 patches
      walkToDiff(oldVirtualDom, newVirtualDom, 0, patches)
    
      return patches
    }
    
    let initialIndex = 0
    
    const walkToDiff = (oldVirtualDom, newVirtualDom, index, patches) => {
      let diffResult = []
    
      // 如果 newVirtualDom 不存在，说明该节点被移除，我们将 type 为 REMOVE 的对象推进 diffResult 变量，并记录 index
      if (!newVirtualDom) {
        diffResult.push({
          type: 'REMOVE',
          index
        })
      }
      // 如果新旧节点都是文本节点，是字符串
      else if (typeof oldVirtualDom === 'string' && typeof newVirtualDom === 'string') {
        // 比较文本是否相同，如果不同则记录新的结果
        if (oldVirtualDom !== newVirtualDom) {
          diffResult.push({
            type: 'MODIFY_TEXT',
            data: newVirtualDom,
            index
          })
        }
      }
      // 如果新旧节点类型相同
      else if (oldVirtualDom.tagName === newVirtualDom.tagName) {
        // 比较属性是否相同
        let diffAttributeResult = {}
    
        for (let key in oldVirtualDom) {
          if (oldVirtualDom[key] !== newVirtualDom[key]) {
            diffAttributeResult[key] = newVirtualDom[key]
          }
        }
    
        for (let key in newVirtualDom) {
          // 旧节点不存在的新属性
          if (!oldVirtualDom.hasOwnProperty(key)) {
              diffAttributeResult[key] = newVirtualDom[key]
          }
        }
    
        if (Object.keys(diffAttributeResult).length > 0) {
            diffResult.push({ 
              type: 'MODIFY_ATTRIBUTES', 
              diffAttributeResult 
            })
        }
    
        // 如果有子节点，遍历子节点
        oldVirtualDom.children.forEach((child, index) => {
          walkToDiff(child, newVirtualDom.children[index], ++initialIndex, patches)
        })
      }
      // else 说明节点类型不同，被直接替换了，我们直接将新的结果 push
      else {
        diffResult.push({ 
          type: 'REPLACE', 
          newVirtualDom
        })
      }
    
      if (!oldVirtualDom) {
        diffResult.push({ 
          type: 'REPLACE', 
          newVirtualDom
        })
      }
    
      if (diffResult.length) {
        patches[index] = diffResult
      }
    }
    

我们对 diff 进行测试：

    
    
    const chapterListVirtualDom = element('ul', { id: 'list' }, [
      element('li', { class: 'chapter' }, ['chapter1']),
      element('li', { class: 'chapter' }, ['chapter2']),
      element('li', { class: 'chapter' }, ['chapter3'])
    ])
    
    const chapterListVirtualDom1 = element('ul', { id: 'list2' }, [
      element('li', { class: 'chapter2' }, ['chapter4']),
      element('li', { class: 'chapter2' }, ['chapter5']),
      element('li', { class: 'chapter2' }, ['chapter6'])
    ])
    
    diff(chapterListVirtualDom, chapterListVirtualDom1)
    

得到如图 diff 数组：

![](https://images.gitbook.cn/6f1e0b70-925b-11e9-a0f8-2d0a45937cae)

#### 最小化差异应用

大功告成之前，我们来看看都做了哪些事情：通过 Element class 生成了虚拟 DOM，通过 diff 方法对任意两个虚拟 DOM
进行比对，得到差异。那么这个差异如何更新到现有的 DOM 节点中呢？看上去需要一个 patch 方法来完成：

    
    
    const patch = (node, patches) => {
      let walker = { index: 0 }
      walk(node, walker, patches)
    }
    

patch 方法接受一个真实的 DOM 节点，它是现有的浏览器中需要进行更新的 DOM 节点，同时接受一个最小化差异集合，该集合对接 diff
方法返回的结果。在 patch 方法内部，我们调用了 walk 函数：

    
    
    const walk = (node, walker, patches) => {
      let currentPatch = patches[walker.index]
    
      let childNodes = node.childNodes
    
      childNodes.forEach(child => {
        walker.index++
        walk(child, walker, patches)
      })
    
      if (currentPatch) {
        doPatch(node, currentPatch)
      }
    }
    

walk 进行自身递归，对于当前节点的差异调用 doPatch 方法进行更新：

    
    
    const doPatch = (node, patches) => {
      patches.forEach(patch => {
        switch (patch.type) {
          case 'MODIFY_ATTRIBUTES':
            const attributes = patch.diffAttributeResult.attributes
            for (let key in attributes) {
                if (node.nodeType !== 1) return
                const value = attributes[key]
                if (value) {
                  setAttribute(node, key, value)
                } else {
                  node.removeAttribute(key)
                }
            }
            break
          case 'MODIFY_TEXT':
            node.textContent = patch.data
            break
          case 'REPLACE':
            let newNode = (patch.newNode instanceof Element) ? render(patch.newNode) : document.createTextNode(patch.newNode)
            node.parentNode.replaceChild(newNode, node)
            break
          case 'REMOVE':
            node.parentNode.removeChild(node)
            break
          default:
            break
        }
      })
    }
    

doPatch 对四种类型的 diff 进行处理，最终进行测试：

    
    
    var element = chapterListVirtualDom.render()
    renderDom(element, document.body)
    
    const patches = diff(chapterListVirtualDom, chapterListVirtualDom1)
    
    patch(element, patches)
    

全部代码放在一起：

    
    
    const setAttribute = (node, key, value) => {
      switch (key) {
        case 'style':
          node.style.cssText = value
          break
        case 'value':
          let tagName = node.tagName || ''
          tagName = tagName.toLowerCase()
          if (
            tagName === 'input' || tagName === 'textarea'
          ) {
            node.value = value
          } else {
            // 如果节点不是 input 或者 textarea, 则使用 setAttribute 去设置属性
            node.setAttribute(key, value)
          }
          break
        default:
          node.setAttribute(key, value)
          break
      }
    }
    
    class Element {
      constructor(tagName, attributes = {}, children = []) {
        this.tagName = tagName
        this.attributes = attributes
        this.children = children
      }
    
      render () {
        let element = document.createElement(this.tagName)
        let attributes = this.attributes
    
         for (let key in attributes) {
            setAttribute(element, key, attributes[key])
         }
    
        let children = this.children
    
        children.forEach(child => {
          let childElement = child instanceof Element
            ? child.render() // 若 child 也是虚拟节点，递归进行
            : document.createTextNode(child)  // 若是字符串，直接创建文本节点
          element.appendChild(childElement)
        })
    
        return element
      }
    }
    
    function element (tagName, attributes, children) {
      return new Element(tagName, attributes, children)
    }
    
    const renderDom = (element, target) => {
      target.appendChild(element)
    }
    
    const diff = (oldVirtualDom, newVirtualDom) => {
      let patches = {}
    
      // 递归树 比较后的结果放到 patches
      walkToDiff(oldVirtualDom, newVirtualDom, 0, patches)
    
      return patches
    }
    
    let initialIndex = 0
    
    const walkToDiff = (oldVirtualDom, newVirtualDom, index, patches) => {
      let diffResult = []
    
      // 如果 newVirtualDom 不存在，说明该节点被移除，我们将 type 为 REMOVE 的对象推进 diffResult 变量，并记录 index
      if (!newVirtualDom) {
        diffResult.push({
          type: 'REMOVE',
          index
        })
      }
      // 如果新旧节点都是文本节点，是字符串
      else if (typeof oldVirtualDom === 'string' && typeof newVirtualDom === 'string') {
        // 比较文本是否相同，如果不同则记录新的结果
        if (oldVirtualDom !== newVirtualDom) {
          diffResult.push({
            type: 'MODIFY_TEXT',
            data: newVirtualDom,
            index
          })
        }
      }
      // 如果新旧节点类型相同
      else if (oldVirtualDom.tagName === newVirtualDom.tagName) {
        // 比较属性是否相同
        let diffAttributeResult = {}
    
        for (let key in oldVirtualDom) {
          if (oldVirtualDom[key] !== newVirtualDom[key]) {
            diffAttributeResult[key] = newVirtualDom[key]
          }
        }
    
        for (let key in newVirtualDom) {
          // 旧节点不存在的新属性
          if (!oldVirtualDom.hasOwnProperty(key)) {
              diffAttributeResult[key] = newVirtualDom[key]
          }
        }
    
        if (Object.keys(diffAttributeResult).length > 0) {
            diffResult.push({ 
              type: 'MODIFY_ATTRIBUTES', 
              diffAttributeResult 
            })
        }
    
        // 如果有子节点，遍历子节点
        oldVirtualDom.children.forEach((child, index) => {
          walkToDiff(child, newVirtualDom.children[index], ++initialIndex, patches)
        })
      }
      // else 说明节点类型不同，被直接替换了，我们直接将新的结果 push
      else {
        diffResult.push({ 
          type: 'REPLACE', 
          newVirtualDom
        })
      }
    
      if (!oldVirtualDom) {
        diffResult.push({ 
          type: 'REPLACE', 
          newVirtualDom
        })
      }
    
      if (diffResult.length) {
        patches[index] = diffResult
      }
    }
    
    const chapterListVirtualDom = element('ul', { id: 'list' }, [
      element('li', { class: 'chapter' }, ['chapter1']),
      element('li', { class: 'chapter' }, ['chapter2']),
      element('li', { class: 'chapter' }, ['chapter3'])
    ])
    
    const chapterListVirtualDom1 = element('ul', { id: 'list2' }, [
      element('li', { class: 'chapter2' }, ['chapter4']),
      element('li', { class: 'chapter2' }, ['chapter5']),
      element('li', { class: 'chapter2' }, ['chapter6'])
    ])
    
    const patch = (node, patches) => {
      let walker = { index: 0 }
      walk(node, walker, patches)
    }
    
    const walk = (node, walker, patches) => {
      let currentPatch = patches[walker.index]
    
      let childNodes = node.childNodes
    
      childNodes.forEach(child => {
        walker.index++
        walk(child, walker, patches)
      })
    
      if (currentPatch) {
        doPatch(node, currentPatch)
      }
    }
    
    const doPatch = (node, patches) => {
      patches.forEach(patch => {
        switch (patch.type) {
          case 'MODIFY_ATTRIBUTES':
            const attributes = patch.diffAttributeResult.attributes
            for (let key in attributes) {
                if (node.nodeType !== 1) return
                const value = attributes[key]
                if (value) {
                  setAttribute(node, key, value)
                } else {
                  node.removeAttribute(key)
                }
            }
            break
          case 'MODIFY_TEXT':
            node.textContent = patch.data
            break
          case 'REPLACE':
            let newNode = (patch.newNode instanceof Element) ? render(patch.newNode) : document.createTextNode(patch.newNode)
            node.parentNode.replaceChild(newNode, node)
            break
          case 'REMOVE':
            node.parentNode.removeChild(node)
            break
          default:
            break
        }
      })
    }
    

先执行：

    
    
    var element = chapterListVirtualDom.render()
    renderDom(element, document.body)
    

再执行：

    
    
    const patches = diff(chapterListVirtualDom, chapterListVirtualDom1)
    
    patch(element, patches)
    

生成结果符合预期。

短短不到两百行代码，就实现了虚拟 DOM 思想的全部流程。当然其中还有一些优化手段，一些边界情况并没有进行特别处理，但是我们去翻看一些著名的虚拟 DOM
库：snabbdom、etch 等，其实现思想和上述教例完全一致。

### 总结

现代框架无疑极大程度上解放了前端生产力，其设计思想相互借鉴，存在非常多的共性。本讲我们通过分析前端框架中的共性，梳理概念原理，希望达到“任何一种框架变得不再神秘”的目的。掌握了这些基本思想，我们不仅能触类旁通，更快地上手框架，更能学习进阶，吸取优秀框架的精华。

### 分享交流

阅读文章过程中有任何疑问可随时跟其他小伙伴讨论，或者直接向作者 LucasHC 提问（作者看到后抽空回复）。 **你的分享不仅帮助他人，更会提升自己。**

你也可以说说自己最想了解的主题，课程内容会根据部分读者的意见和建议迭代和完善。

此外，我们为本课程付费读者创建了《前端开发核心知识进阶》微信交流群，以方便更有针对性地讨论课程相关问题（入群请到第1-2课末尾添加 GitChat
小助手伽利略的微信，并注明「前端核心」，谢谢~）



## 你真的懂 React 吗

这一讲我们来重点解析一下 React，说 React 是前端中最受瞩目的框架其实并不夸张。React 推出之后，很快风靡业界，并且 React
倡导的多种思想也对其他框架（比如 Vue）有着广泛影响。

据我观察，很多 React 开发者停留在“会使用”的阶段，而并没有在细节之处把握 React 精髓；我们可能对各种生命周期“了如指掌”，可能对“React
虚拟 DOM diff 算法”“对答如流”，可能对“单向数据流”“如数家珍”，可是你真的了解 React 吗？

同时，现在 React 面试越来越“范式化”，除了实际动手写码的题目之外，其他相关面试题毫无新意，很容易被应试，很难考察开发者的 React 功底。

对此，下面挑选出 React 中一些“不为人知”却又非常重要的点，为大家进行解析。在此过程中，通过剖析实现，读者可以更好、更深入地理解
React，掌握了这些内容，有可能在某些方向上比你的 React 面试官更有深度。

相关知识点如下：

![enter image description
here](https://images.gitbook.cn/bfd2b840-97ba-11e9-af96-558c6e89b52c)

### 神奇的 JSX

其实 React 的“专利发明”并不多，比如虚拟 DOM、组件化思想并不是 Facebook 原创。但 JSX 是 React 真正的创造，我认为这是
React 最“伟大”的发明。

JSX 是 React 的骨骼，它搭起了 React 应用的组件，是整个项目的组件框架基础。

“不就是 HTML in JS”吗？有什么神奇之处呢？请继续阅读。

#### JSX 就是丑陋的模版

直观上看，JSX 是将 HTML 直接嵌入在了 JS 代码里面，这是刚开始接触 React
时，很多人最不能接受的设定。因为前端开发者被“表现和逻辑层分离”这种思想“洗脑”太久了：表现和逻辑耦合在一起，在某种程度上是一种混乱和困扰。

但是从现在发展来看，JSX 完全符合“真香定律”：JSX 让前端实现真正意义上的组件化成为了可能。

可能有读者认为 JSX 很简单，但是你真的理解它了吗？试着回答这么几个问题：

> 如何在 JSX 中调试代码？

>

> 为什么 JSX 中不能直接使用 if...else

在回答这些问题之前，先来看看 JSX 是如何实现条件渲染的。

#### JSX 多种姿势实现条件渲染

很常见的一个场景：渲染一个列表。但是需要满足：列表为空数组时，显示空文案“Sorry，the list is
empty”。同时列表数据可能通过网络获取，存在列表没有初始值为 null 的情况。

JSX 实现这种条件渲染最简洁的手段就是三目运算符：

    
    
    const list = ({list}) => {
      const isNull = !list
      const isEmpty = !isNull && !list.length
    
      return (
        <div>
        {
          isNull
          ? null
          : (
              isEmpty 
              ? <p>Sorry, the list is empty </p>
              : <div>
                  {
                    list.map(item => <ListItem item={item} />)
                  }
                </div>
            )
        }
        </div>
      )
    }
    

但是我们多加了几个状态：加上出现错误时，正在加载时的逻辑，三目运算符嵌套地狱可能就要出现了：

    
    
    const list = ({isLoading, list. error}) => {
      return (
        <div>
        {
          condition1
          ? <Component1 />
          : (
              condition2 
              ? <Component2 />
              : (
                condition3
                ? <Component3 />
                : <Component4 />
              )
            )
        }
        </div>
      )
    }
    

如何破解这种嵌套呢？我们常用的手段是抽离出 render function：

    
    
    const getListContent = (isLoading, list, error) => {
        console.log(list)
        console.log(isLoading)
        console.log(error)
       // ...
       return ...
    }
    
    const list = ({isLoading, list, error}) => {
      return (
        <div>
          {
            getListContent(isLoading, list, error)
          }
        </div>
      )
    }
    

甚至使用 IIFE：

    
    
    const list = ({isLoading, list, error}) => {
      return (
        <div>
          {
            (() => {
              console.log(list)
              console.log(isLoading)
              console.log(error)
    
              if (error) {
                return <span>Something is wrong!</span>
              }
              if (!error && isLoading) {
                return <span>Loading...</span>
              }
              if (!error && !isLoading && !list.length) {
                return <p>Sorry, the list is empty </p>
              }
              if (!error && !isLoading && list.length > 0) {
                return <div>
                  {
                    list.map(item => <ListItem item={item} />)
                  }
                </div>
              }
            })()
          }
        </div>
      )
    }
    

这样一来就可以使用 console.log 进行简单调试了，也可以使用 if...else 进行条件渲染。

再回到问题的本源：“为什么不能直接在 JSX 中使用 if...else，只能借用函数逻辑实现呢”？实际上，我们都知道 JSX 会被编译为
React.createElement。直白来说，React.createElement 的底层逻辑是无法运行 JavaScript
代码的，而它只能渲染一个结果。因此 JSX 中除了 JS 表达式，不能直接写 JavaScript 语法。准确来讲，JSX 只是函数调用和表达式的语法糖。

React 程序员天天都在使用 JSX，但并不是所有人都明白其背后原理的。

#### JSX 的强大和灵活

虽然 JSX 只是函数调用和表达式的语法糖，但是 JSX 仍然具有强大而灵活的能力。React 组件复用最流行的方式都是在 JSX 能力基础之上的，比如
HoC，比如 render prop 模式：

    
    
    class WindowWidth extends React.Component {
      constructor() {
        super()
        this.state = {
          width: 0
        }
      }
    
      componentDidMount() {
        this.setState(
          {
            width: window.innerWidth
          },
          window.addEventListener('resize', ({target}) => {
            this.setState({
              width: target.innerWidth
            })
          })
        )
      }
    
      render() {
        return this.props.children(this.state.width)
      }
    }
    
    <WindowWidth>
      {
        width => (width > 800 ? <div>show</div> : null)
      }
    <WindowWidth>
    

甚至，我们还可以让 JSX 具有 Vue template 的能力：

    
    
    render() {
      const visible = true
    
      return (
        <div>
          <div v-if={visible}>
           content 
          </div>
        </div>
      )
    }
    
    render() {
      const list = [1, 2, 3, 4]
    
      return (
        <div>
          <div v-for={item in list}>
            {item}
          </div>
        </div>
      )
    }
    

因为 JSX 总要进行一步编译，在这个编译过程中我们借助 AST（抽象语法树）对 v-if、v-for 进行处理即可。

### 你真的了解异步的 this.setState 吗？

绝大多数 React 开发者都知道 this.setState 是异步执行的，但是我会说“你这个结论是错误的！”，那么 this.setState
到底是异步执行还是同步执行？这是一个问题......

#### this.setState 全是异步执行吗？

this.setSate 这个 API，官方描述为：

> setState() does not always immediately update the component. It may batch or
defer the update until later. This makes reading this.state right after
calling setState() a potential pitfall.

既然用词是 may，那么说明 this.setState 一定不全是异步执行，也不全是同步执行的。所谓的“延迟更新”并不是针对所有情况。

实际上， React 控制的事件处理过程，setState 不会同步更新 this.state。而在 React 控制之外的情况， setState
会同步更新 this.state。

什么是 React 控制内外呢？举个例子：

    
    
    onClick() {
      this.setState({
        count: this.state.count + 1
      })
    }
    
    componentDidMount() {
      document.querySelectorAll('#btn-raw')
        .addEventListener('click', this.onClick)
    }
    
    render() {
      return (
        <React.Fragment>
          <button id="btn-raw">
            click out React
          </button>
    
          <button onClick={this.onClick}>
            click in React
          </button>
        </React.Fragment>
      )
    }
    

id 为 btn-raw 的 button 上绑定的事件，是在 componentDidMount 方法中通过 addEventListener
完成的，这是脱离于 React 事件之外的，因此它是同步更新的。反之，代码中第二个 button 所绑定的事件处理函数对应的 setState
是异步更新的。

这样的设计也不难理解，通过“延迟更新”，可以达到更好的性能。

#### this.setState promise 化

官方提供了这种处理异步更新的方法。其中之一就是 setState 接受第二个参数，作为状态更新后的回调。但这无疑又带来了我们熟悉的 callback
hell 问题。

举一个场景，我们在开发一个 tabel，这个 table 类似 excel，当用户敲下回车键时，需要将光标移动到下一行，这是一个 setState
操作，然后马上进行聚焦，这又是一个 setState 操作。如果当前行就是最后一行，那用户敲下回车时，需要先创建一个新行，这是第一个 setState
操作，同时将光标移动到新的“最后一行”，这是第二个 setState 操作；在这个新行中进行聚焦，这是第三个 setState 操作。这些 setState
操作依赖于前一个 setState 的完成。

面对这种场景，如果我们不想出现回调地狱的场景。常见的处理方式是利用生命周期方法，在 componentDidUpdate 中进行相关操作。第一次
setState 进行完后，在其触发的 componentDidUpdate 中进行第二次 setState，依此类推。

但是这样存在的问题也很明显：逻辑过于分散。生命周期方法中有很多很难维护的“莫名其妙操作”，出现“面向生命周期编程”的情况。

回到刚才问题，解决回调地狱其实是我们前端工程师的拿手好戏了，最直接的方案就是将 setState Promise 化：

    
    
    const setStatePromise = (me, state) => {
      new Promise(resolve => {
        me.setState(state, () => {
          resolve()
        })
      })
    }
    

这只是 patch 做法，如果修改 React 源码的话，也不困难：

![enter image description
here](https://images.gitbook.cn/81a2a920-97d5-11e9-949b-a35e3e200084)

### 原生事件 VS React 合成事件

对 React 熟悉的读者可能知道：

  * React 中的事件机制并不是原生的那一套，事件没有绑定在原生 DOM 上 ，大多数事件绑定在 document 上（除了少数不会冒泡到 document 的事件，如 video 等)
  * 同时，触发的事件也是对原生事件的包装，并不是原生 event
  * 出于性能因素考虑，合成事件（syntheticEvent）是被池化的。这意味着合成事件对象将会被重用，在调用事件回调之后所有属性将会被废弃。这样做可以大大节省内存，而不会频繁的创建和销毁事件对象。

这样的事件系统设计，无疑性能更加友好，但同时也带来了几个潜在现象。

#### 现象1：异步访问事件对象

我们不能以异步的方式访问合成事件对象：

    
    
    function handleClick(e) {
      console.log(e)
    
      setTimeout(() => {
        console.log(e)
      }, 0)
    }
    

上述代码第二个 console.log 总将会输出 undefined。

为此 React 也贴心的为我们准备了持久化合成事件的方法：

    
    
    function handleClick(e) {
      console.log(e)
    
      e.persist()
    
      setTimeout(() => {
        console.log(e)
      }, 0)
    }
    

#### 现象2：如何阻止冒泡

在 React 中，直接使用 e.stopPropagation 不能阻止原生事件冒泡，因为事件早已经冒泡到了 document 上，React
此时才能够处理事件句柄。

如代码：

    
    
    componentDidMount() {
      document.addEventListener('click', () => {
        console.log('document click')
      })
    }
    
    handleClick = e => {
      console.log('div click')
      e.stopPropagation()
    }
    
    render() {
      return (
        <div onClick={this.handleClick}>
          click
        </div>
      )
    }
    

执行后会打印出 div click，之后是 document click。e.stopPropagation 是没有用的。

但是 React 的合成事件还给使用原生事件留了一个口子，通过合成事件上的 nativeEvent 属性，我们还是可以访问原生事件。原生事件上的
stopImmediatePropagation 方法：除了能做到像 stopPropagation
一样阻止事件向父级冒泡之外，也能阻止当前元素剩余的、同类型事件的执行（第一个 click 触发时，调用 e.stopImmediatePropagtion
阻止当前元素第二个 click 事件的触发）。因此这一段代码：

    
    
    componentDidMount() {
      document.addEventListener('click', () => {
        console.log('document click')
      })
    }
    
    handleClick = e => {
      console.log('div click')
      e.nativeEvent.stopImmediatePropagation()
    }
    
    render() {
      return (
        <div onClick={this.handleClick}>
          click
        </div>
      )
    }
    

只会打印出 div click。

### 请不要再背诵 Diff 算法了

很多开发者在面试中能“背诵”出 React DOM diff 算法的方式，熟悉那著名的“三个假设”（不了解的读者可先自行学习），可是你真的懂 Diff
算法吗？如果我是面试官，我问几个简单的问题，你是否还能招架得住？

我们通过一个侧面来剖析 Diff 算法的细节。

#### Element diff 的那些事儿

我们都知道 React 把对比两个树的时间复杂度从 On 立方降低到大 On，三个假设也都老生常谈了。但是关于兄弟列表的 diff 细节，React 叫做
element diff，我们可以展开一下。

React 三个假设在对比 element 时，存在短板，于是需要开发者给每一个 element 通过提供 key ，这样 react
可以准确地发现新旧集合中的节点中相同节点，对于相同节点无需进行节点删除和创建，只需要将旧集合中节点的位置进行移动，更新为新集合中节点的位置。

![enter image description
here](https://images.gitbook.cn/c7a69520-97c7-11e9-ae77-f7748cb4d629)

组件 1234，变为 2143，此时 React 给出的 diff 结果为 2，4 不做任何操作；1，3 进行移动操作即可。

也就是元素在旧集合中的位置，相比新集合中的位置更靠后的话，那么它就不需要移动。当然这种 diff 听上去就并非完美无缺的。

我们来看这么一种情况：

![enter image description
here](https://images.gitbook.cn/e69325c0-97c7-11e9-9465-a7e3d006cf60)

实际只需对 4 执行移动操作，然而由于 4 在旧集合中的位置是最大的，导致其他节点全部移动，移动到 4 节点后面。

这无疑是很愚蠢的，性能较差。针对这种情况，官方建议：

> “在开发过程中，尽量减少类似将最后一个节点移动到列表首部的操作。”

实际上很多类 React 类库（Inferno.js，Preact.js）都有了更优的 element diff 移动策略。

#### 有 key 就一定“性能最优”吗？

刚才提到，在进行 element diff 时：由于 key 的存在，react 可以准确地判断出该节点在新集合中是否存在，这极大地提高了element
diff 效率。

但是加了 key 一定要比没加 key 的性能更高吗？

我们来看这个场景，集合 [1,2,3,4] 渲染成 4 组数字，注意仅仅是数字这么简单：

    
    
    <div id="1">1</div>
    <div id="2">2</div>
    <div id="3">3</div>
    <div id="4">4</div>
    

当它变为 [2，1，4，5]：删除了 3，增加了 5，按照之前的算法，我们把 1 放到 2 后面，删除 3，再新增 5。整个操作移动了一次 dom
节点，删除和新增一共 2 处节点。

由于 dom 节点的移动操作开销是比较昂贵的，其实对于这种简单的 node text 更改情况，我们不需要再进行类似的 element diff
过程，只需要更改 dom.textContent 即可。

    
    
    const startTime = performance.now()
    
    $('#1').textContent = 2
    $('#2').textContent = 1
    $('#3').textContent = 4
    $('#4').textContent = 5
    
    console.log('time consumed:' performance.now() - startTime)
    

这么看，也许没有 key 的情况下要比有 key 的性能更好。

### 总结

这一讲，我们聚焦 React 当中那些“不为人知”的设计细节，这些设计细节却从不同角度体现了 React 的理念和思想。仔细想来，也许“我之前理解的
React
还是很肤浅”！实际上，任何一个类库或者框架，我们都不能停留在初级使用上，而更应该从使用的经验出发，深入细节，这样才能更好地理解框架，也能更快地自我提升。

### 分享交流

阅读文章过程中有任何疑问可随时跟其他小伙伴讨论，或者直接向作者 LucasHC 提问（作者看到后抽空回复）。 **你的分享不仅帮助他人，更会提升自己。**

你也可以说说自己最想了解的主题，课程内容会根据部分读者的意见和建议迭代和完善。

此外，我们为本课程付费读者创建了《前端开发核心知识进阶》微信交流群，以方便更有针对性地讨论课程相关问题（入群请到第1-2课末尾添加 GitChat
小助手伽利略的微信，并注明「前端核心」，谢谢~）



## 揭秘 React 真谛：组件设计

组件不是 React 特有的概念，但是 React
将组件化的思想发扬光大，可谓用到了极致。良好的组件设计会是良好的应用开发基础，这一讲就让我们谈一谈组件设计的奥秘。

相关知识点如下：

![](https://images.gitbook.cn/684bbbb0-9983-11e9-ae98-dfdddc232198)

我们将以 React 组件为例，但是其中的设计思想具有共性，不管是其他框架还是原生 Web component 都将适用。

### 单一职责没那么简单

单一职责我们并不陌生，原则上讲，组件只应该做一件事情。但是对于应用来说，全部组件都拆散，只有单一职责并没有必要，反而增加了编写的繁琐程度。那什么时候需要拆分组件，保证单一职责呢？我认为如果一个功能集合有可能发生变化，那么就需要最大程度地保证单一职责。

单一职责带来的最大好处就是在修改组件时，能够做到全在掌控下，不必担心对其他组件造成影响。举个例子：我们的组件需要通过网络请求获取数据并展示数据内容，这样一来潜在的功能集合改变就有：

  * 请求 API 地址发生变化
  * 请求返回数据格式变化
  * 开发者想更换网络请求第三方库，比如 jQuery.ajax 改成 axios
  * 更改请求数据逻辑

再看一个例子：我们需要一个 table 组件，渲染一个 list，那么潜在更改的可能有：

  * 限制一次性渲染的 item 个数（只渲染前 10 个，剩下的懒加载）
  * 当数据列表为空时显示 “This list is empty”
  * 任何渲染逻辑的更改

这个图很好地说明了问题：

![](https://images.gitbook.cn/49f0c740-9984-11e9-9465-a7e3d006cf60)

我们来实际看一个场景：

    
    
    import axios from 'axios'
    
    class Weather extends Component {  
      constructor(props) {
        super(props)
        this.state = { temperature: 'N/A', windSpeed: 'N/A' }
      }
    
      componentDidMount() {
        axios.get('http://weather.com/api').then(response => {
          const { current } = response.data
          this.setState({
            temperature: current.temperature,
            windSpeed: current.windSpeed
          })
        })
      }
    
      render() {
        const { temperature, windSpeed } = this.state
        return (
          <div className="weather">
            <div>Temperature: {temperature} °C</div>
            <div>Wind: {windSpeed} km/h</div>
          </div>
        )
      }
    }
    

这个组件很容易理解，并且看上去没什么大问题，但是并不符合单一职责。比如这个 Weather 组件将数据获取与渲染逻辑耦合在一起，如果数据请求有变化，就需要在
componentDidMount 生命周期中进行改动；如果展示天气的逻辑有变化，render 方法又需要变动。

如果我们将这个组件拆分成：WeatherFetch 和 WeatherInfo 两个组件，这两个组件各自只做一件事情，保持单一职责：

    
    
    import axios from 'axios'
    import WeatherInfo from './weatherInfo'
    
    class WeatherFetch extends Component {  
      constructor(props) {
        super(props)
        this.state = { temperature: 'N/A', windSpeed: 'N/A' }
      }
    
      componentDidMount() {
        axios.get('http://weather.com/api').then(response => {
          const { current } = response.data
          this.setState({
            temperature: current.temperature,
            windSpeed: current.windSpeed
            })
          })
      }
    
      render() {
        const { temperature, windSpeed } = this.state
        return (
          <WeatherInfo temperature={temperature} windSpeed={windSpeed} />
        )
      }
    }
    

另一个文件中：

    
    
    const WeatherInfo = ({ temperature, windSpeed }) => 
      (
        <div className="weather">
          <div>Temperature: {temperature} °C</div>
          <div>Wind: {windSpeed} km/h</div>
        </div>
      )
    

如果我们想进行重构，使用 async/await 代替 Promise，只需要直接更改 WeatherFetch 组件：

    
    
    class WeatherFetch extends Component {  
      // ...
    
      async componentDidMount() {
        const response = await axios.get('http://weather.com/api')
        const { current } = response.data
    
        this.setState({
          temperature: current.temperature,
          windSpeed: current.windSpeed
          })
        })
      }
    
      // ...
    }
    

而不会对 WeatherInfo 组件有任何影响。

或者显示风速的逻辑从 Wind: 0 km/h 改为文字描述 Wind: 风平浪静，也只需要改动 WeatherInfo：

    
    
    const WeatherInfo = ({ temperature, windSpeed }) => {
      const windInfo = windSpeed === 0 ? 'calm' : `${windSpeed} km/h`
      return (
        <div className="weather">
          <div>Temperature: {temperature} °C</div>
          <div>Wind: {windSpeed} km/h</div>
        </div>
      )
    }
    

这只是一个简单的例子，在真实项目中，保持组件的单一职责将会非常重要，甚至我们可以使用 HoC 强制组件的单一职责性。

来思考这样的代码：

    
    
    class PersistentForm extends Component {  
      constructor(props) {
        super(props)
        this.state = { inputValue: localStorage.getItem('inputValue') }
        this.handleChange = this.handleChange.bind(this)
        this.handleClick = this.handleClick.bind(this)
      }
    
      handleChange(event) {
        this.setState({
          inputValue: event.target.value
        })
      }
    
      handleClick() {
        localStorage.setItem('inputValue', this.state.inputValue)
      }
    
      render() {
        const { inputValue } = this.state
        return (
          <div className="persistent-form">
            <input type="text" value={inputValue} 
              onChange={this.handleChange}
            /> 
            <button onClick={this.handleClick}>
              Save to storage
            </button>
          </div>
        )
      }
    }
    

这是一个持久化存储的表单，我们将表单字段内容存储在 localStorage 中，这样不管是刷新页面还是重新进入页面，都会保存上一次点击提交时的内容。可惜
PersistentForm 组件也是包含了两部分职责：存储内容和渲染内容。

这次我们的重构不再是简单的拆分组件，而是使用 HoC 来完成职责单一的实现：

    
    
    class PersistentForm extends Component {  
      constructor(props) {
        super(props)
        this.state = { inputValue: props.initialValue }
        this.handleChange = this.handleChange.bind(this)
        this.handleClick = this.handleClick.bind(this)
      }
    
      handleChange(event) {
        this.setState({
          inputValue: event.target.value
        })
      }
    
      handleClick() {
        this.props.saveValue(this.state.inputValue)
      }
    
      render() {
        const { inputValue } = this.state
        return (
          <div className="persistent-form">
            <input type="text" value={inputValue} 
              onChange={this.handleChange}
            /> 
            <button onClick={this.handleClick}>
              Save to storage
            </button>
          </div>
        )
      }
    }
    

我们只是改变了两行代码，初始 state 不再直接读取 localStorage，而是由 this.props.initialValue
提供；handleClick 逻辑调用 this.props.saveValue，而不再直接操作
localStorage，this.props.saveValue 将会由 withPersistence 这个 HoC 提供：

    
    
    function withPersistence(storageKey, storage) {  
      return function(WrappedComponent) {
        return class PersistentComponent extends Component {
          constructor(props) {
            super(props)
            this.state = { initialValue: storage.getItem(storageKey) }
          }
    
          render() {
             return (
               <WrappedComponent
                 initialValue={this.state.initialValue}
                 saveValue={this.saveValue}
                 {...this.props}
               />
             );
          }
    
          saveValue(value) {
            storage.setItem(storageKey, value)
          }
        }
      }
    }
    

使用方式：

    
    
    const LocalStoragePersistentForm  
      = withPersistence('key', localStorage)(PersistentForm)
    

这种方式是组件单一职责和组件复用的结合体现，其他组件当然也可以使用这个 HoC:

    
    
    const LocalStorageMyOtherForm  
      = withPersistence('key', localStorage)(MyOtherForm)
    

存储和渲染职责解耦，我们便可以随时切换存储方式，比如切换为 sessionStorage 代替 localStorage：

    
    
    const SessionStoragePersistentForm  
      = withPersistence('key', sessionStorage)(PersistentForm)
    

### 组件通信和封装

另一个和组件职责单一相关的话题是组件的封装，封装又涉及到组件间的通信。因为我们知道，组件再封装，还是要和其他组件去交互通信的，那么当我们说封装时在说些什么呢？

组件关联有紧耦合和松耦合之分，紧耦合是指两个或多个组件之间需要了解彼此的组件内设计，这样的情况是我们不想看到的，这破坏了组件的独立性，“牵一发动全身”。这么看来，松耦合带来的好处是很直接的：

  * 一处组件的改动完全独立，不影响其他组件
  * 更好的复用设计
  * 更好的可测试性

我们直接来看场景代码，一个简单的计数器足以说明问题：

    
    
    class App extends Component {  
      constructor(props) {
        super(props)
        this.state = { number: 0 }
      }
    
      render() {
        return (
          <div className="app"> 
            <span className="number">{this.state.number}</span>
            <Controls parent={this} />
          </div>
        )
      }
    }
    
    class Controls extends Component {
      updateNumber(toAdd) {
        this.props.parent.setState(prevState => ({
          number: prevState.number + toAdd       
        }))
      }
    
      render() {
        return (
          <div className="controls">
            <button onClick={() => this.updateNumber(+1)}>
              Increase
            </button> 
            <button onClick={() => this.updateNumber(-1)}>
              Decrease
            </button>
          </div>
        )
      }
    }
    

这样的组件实现问题很明显：App 组件不具有封装性，它将实例传给 Controls 组件，Controls 组件可以直接更改 App state
的内容。事实上，我们并不是不允许 Controls 组件修改 App 组件，只是 Controls 组件直接调用 App 组件的 setState
方法是不被建议的，因为 Controls 组件如果要调用 App 的 setState，就得需要知道 App 组件 state 的结构，需要感知
this.props.parent.state.number 等详情。

同时上述代码也不利于测试，这个我们将在后面进行说明。那么该如何重构呢？我们应该用更加“含蓄”或者更加“粗暴、直接地”方式修改 number
值。秉承封装性：“只有组件自己知道自己的 state 结构”，将 updateNumber 迁移至 App 组件内：

    
    
    class App extends Component {  
      constructor(props) {
        super(props)
        this.state = { number: 0 }
      }
    
      updateNumber(toAdd) {
        this.setState(prevState => ({
          number: prevState.number + toAdd       
        }))
      }
    
      render() {
        return (
          <div className="app"> 
            <span className="number">{this.state.number}</span>
            <Controls 
              onIncrease={() => this.updateNumber(+1)}
              onDecrease={() => this.updateNumber(-1)} 
            />
          </div>
        )
      }
    }
    
    
    const Controls = ({ onIncrease, onDecrease }) => {  
      return (
        <div className="controls">
          <button onClick={onIncrease}>Increase</button> 
          <button onClick={onDecrease}>Decrease</button>
        </div>
      )
    }
    

这样一来，Controls 组件就不需要再知道 App 组件的内部情况，实现了更好的复用性和可测试性，App 组件因此也具有了更好的封装性。

### 组合性是灵魂

如果说组件单一职责确定了如何拆分组件，封装性明确了组件如何组织，那么组合性就完成了整个应用的拼接。

React 具有天生的组合基因：

![](https://images.gitbook.cn/85431690-9984-11e9-ae98-dfdddc232198)

对应声明式代码：

    
    
    const app = (  
      <Application>
        <Header />
        <Sidebar>
          <Menu />
        </Sidebar>
        <Content>
          <Article />
        </Content>
        <Footer />
      </Application>
    )
    

如果两个组件 Composed1 和 Composed2 具有相同的逻辑，我们可以使用组合性进行拆分重组：

    
    
    const instance1 = (  
      <Composed1>
          // Composed1 逻辑
          // 重复逻辑
      </Composed1>
    )
    const instance2 = (  
      <Composed2>
          // 重复逻辑
          // Composed2 逻辑
      </Composed2>
    )
    

重复逻辑提取为 Common 组件：

    
    
    const instance1 = (  
      <Composed1>
        <Logic1 />
        <Common />
      </Composed1>
    )
    const instance2 = (  
      <Composed2>
        <Common />
        <Logic2 />
      </Composed2>
    )
    

另外一个典型应用就是 render prop 模式，这个我们前面已经介绍过，这里给出一个很简单的示例，具体不再展开：

    
    
    const ByDevice = ({ children: { mobile, other } }) => {  
      return Utils.isMobile() ? mobile : other
    }
    
    <ByDevice>
        {{  
          mobile: <div>Mobile detected!</div>,
          other:  <div>Not a mobile device</div>
        }}
    </ByDevice>
    

### 副作用和（准）纯组件

纯函数和非纯函数概念大家并不陌生，简单来说，通过函数参数能够唯一确定函数返回值的函数，我们称之为纯函数，反之就是有副作用的非纯函数。纯/非纯函数延伸到组件中，就是纯/非纯组件。

在理想主义者眼中，最好的情况是应用组件全部由纯组件组成，这样对于组件的调试和强健性非常重要。但这只能是理想情况，在真实环境中，我们需要发送网络请求以获取数据（副作用，因为数据不固定，需要从网络获取），进行条件渲染等操作，如何最大限度地保证纯组件或者（准）纯组件呢？我们先来下一个定义：

> （准）纯组件是渲染数据全部来自于 props，但是会产生副作用的组件

从非纯组件中提取纯组件部分，是一个很常见有效的做法。

    
    
    const globalConfig = {  
      siteName: 'Animals in Zoo'
    }
    
    const Header = ({ children }) => {  
      const heading = 
        globalConfig.siteName ? <h1>{globalConfig.siteName}</h1> : null
      return (
         <div>
           {heading}
           {children}
         </div>
      );
    }
    

这个组件是典型的非纯组件，因为它依赖全局变量 siteName，可能渲染出：

    
    
    <div>  
      <h1>Animals in Zoo</h1>
      Some content
    </div
    

或者：

    
    
    <div>  
      Some content
    </div>
    

在编写测试用例时，还需要考虑 globalConfig.siteName，使得逻辑更加复杂：

    
    
    import assert from 'assert'
    import { shallow } from 'enzyme'
    import { globalConfig } from './config'
    import Header from './Header'
    
    describe('<Header />', function() {  
      it('should render the heading', function() {
        const wrapper = shallow(
          <Header>Some content</Header>
        )
        assert(wrapper.contains(<h1>Animals in Zoo</h1>))
      })
    
      it('should not render the heading', function() {
        // 改动全局变量
        globalConfig.siteName = null
        const wrapper = shallow(
          <Header>Some content</Header>
        )
        assert(appWithHeading.find('h1').length === 0)
      })
    })
    

在测试 Header 组件时，多了一种 case 不说，我们还需要手动改写全局变量的值。

一个常用的优化方式是使全局变量作为 Header 的 props 出现，而不再是一个外部变量，那么函数式组件 Header 就完全依赖其参数：

    
    
    const Header = ({ children, siteName }) => {  
      const heading = siteName ? <h1>{siteName}</h1> : null;
      return (
         <div className="header">
           {heading}
           {children}
         </div>
      );
    }
    
    Header.defaultProps = {  
      siteName: globalConfig.siteName
    }
    

这样一来 Header 就成了纯组件，测试用例便可以简化为：

    
    
    import assert from 'assert'
    import { shallow } from 'enzyme' 
    import { Header } from './Header';
    
    describe('<Header />', function() {  
      it('should render the heading', function() {
        const wrapper = shallow(
          <Header siteName="Animals in Zoo">Some content</Header>
        )
        assert(wrapper.contains(<h1>Animals in Zoo</h1>))
      });
    
      it('should not render the heading', function() {
        const wrapper = shallow(
          <Header siteName={null}>Some content</Header>
        )
        assert(appWithHeading.find('h1').length === 0)
      })
    })
    

且不需再手动改动变量的值，以完成测试逻辑。

另一个重构非纯组件的典型案例就是针对有网络请求的副作用情况，重放我们在组件单一职责中的代码：

    
    
    import axios from 'axios'
    import WeatherInfo from './weatherInfo'
    
    class WeatherFetch extends Component {  
      constructor(props) {
        super(props)
        this.state = { temperature: 'N/A', windSpeed: 'N/A' }
      }
    
      componentDidMount() {
        axios.get('http://weather.com/api').then(response => {
          const { current } = response.data
          this.setState({
            temperature: current.temperature,
            windSpeed: current.windSpeed
            })
          })
      }
    
      render() {
        const { temperature, windSpeed } = this.state
        return (
          <WeatherInfo temperature={temperature} windSpeed={windSpeed} />
        )
      }
    }
    

从表面上看，WeatherFetch
组件不得不“非纯”，因为网络请求不可避免，但是我们可以将请求的主体逻辑分离出组件，而组件只负责调用请求，这样的操作我称之为“（准）纯组件”：

    
    
    import { connect } from 'react-redux' 
    import { fetch } from './action'
    
    export class WeatherFetch extends Component {  
       render() {
         const { temperature, windSpeed } = this.props
         return (
           <WeatherInfo temperature={temperature} windSpeed={windSpeed} />
         )
       }
    
       componentDidMount() {
         this.props.fetch()
       }
    }
    
    function mapStateToProps(state) {  
      return {
        temperature: state.temperate,
        windSpeed: state.windSpeed
      }
    }
    
    export default connect(mapStateToProps, { fetch })
    

我们使用 Redux 来完成，这样一来 WeatherFetch 组件至少可以保证“相同的 props，会渲染相同的结果”。测试也就变得可行：

    
    
    import assert from 'assert'
    import { shallow, mount } from 'enzyme'
    import { spy } from 'sinon'
    
    import { WeatherFetch } from './WeatherFetch';  
    import WeatherInfo from './WeatherInfo'
    
    describe('<WeatherFetch />', function() {  
      it('should render the weather info', function() {
        function noop() {}
        const wrapper = shallow(
          <WeatherFetch temperature="30" windSpeed="10" fetch={noop} />
        )
        assert(wrapper.contains(
          <WeatherInfo temperature="30" windSpeed="10" />
        ))
      });
    
      it('should fetch weather when mounted', function() {
        const fetchSpy = spy()
        const wrapper = mount(
         <WeatherFetch temperature="30" windSpeed="10" fetch={fetchSpy}/>
        )
        assert(fetchSpy.calledOnce)
      })
    })
    

### 组件可测试性

我们一直在提“可测试性”，上面也出现了测试用例代码，我认为是否具有测试意识，是区别高级和一般程序员的考证之一。

还记得我们在上面提到的 Controls 组件吗？最初实现：

    
    
    class App extends Component {  
      constructor(props) {
        super(props)
        this.state = { number: 0 }
      }
    
      render() {
        return (
          <div className="app"> 
            <span className="number">{this.state.number}</span>
            <Controls parent={this} />
          </div>
        )
      }
    }
    
    class Controls extends Component {
      updateNumber(toAdd) {
        this.props.parent.setState(prevState => ({
          number: prevState.number + toAdd       
        }))
      }
    
      render() {
        return (
          <div className="controls">
            <button onClick={() => this.updateNumber(+1)}>
              Increase
            </button> 
            <button onClick={() => this.updateNumber(-1)}>
              Decrease
            </button>
          </div>
        )
      }
    }
    

因为 Controls 组件的行为完全依赖其父组件，因此为了测试，我们需要临时构造一个父组件 Temp 来完成：

    
    
    class Temp extends Component {  
      constructor(props) {
        super(props)
        this.state = { number: 0 }
      }
      render() {
        return null
      }
    }
    
    describe('<Controls />', function() {  
      it('should update parent state', function() {
        const parent = shallow(<Temp/>)
        const wrapper = shallow(<Controls parent={parent} />)
    
        assert(parent.state('number') === 0)
    
        wrapper.find('button').at(0).simulate('click')
        assert(parent.state('number') === 1)
    
        wrapper.find('button').at(1).simulate('click')
        assert(parent.state('number') === 0)
      });
    });
    

测试编写的非常痛苦，而经过我们重构之后，变的就非常简单了：

    
    
    class App extends Component {  
      constructor(props) {
        super(props)
        this.state = { number: 0 }
      }
    
      updateNumber(toAdd) {
        this.setState(prevState => ({
          number: prevState.number + toAdd       
        }))
      }
    
      render() {
        return (
          <div className="app"> 
            <span className="number">{this.state.number}</span>
            <Controls 
              onIncrease={() => this.updateNumber(+1)}
              onDecrease={() => this.updateNumber(-1)} 
            />
          </div>
        )
      }
    }
    
    
    const Controls = ({ onIncrease, onDecrease }) => {  
      return (
        <div className="controls">
          <button onClick={onIncrease}>Increase</button> 
          <button onClick={onDecrease}>Decrease</button>
        </div>
      )
    }
    
    describe('<Controls />', function() {  
      it('should execute callback on buttons click', function() {
        const increase = sinon.spy()
        const descrease = sinon.spy()
        const wrapper = shallow(
          <Controls onIncrease={increase} onDecrease={descrease} />
        )
    
        wrapper.find('button').at(0).simulate('click')
        assert(increase.calledOnce)
        wrapper.find('button').at(1).simulate('click')
        assert(descrease.calledOnce)
      })
    })
    

有的开发者觉得“测试不重要”，因此也不用关心组件编写的可测试性。其实我认为，之所以会有程序员认为“测试不重要”，是因为他不具有看待项目的更高视野和角度，也没有编写稳定可靠组件库或其他库的经验。我们要端正态度，想要进阶，就要从态度入手，从掌握一门测试用例的使用入手。

### 组件命名是意识和态度问题

我为什么要把组件命名放在最后一部分呢？因为组件命名太简单了，任何一个开发者只要有意识，能用心，都能完成很好的命名；同时组件命名又太重要了，良好的组件命名就是“行走着的注释”。但意识是一个很虚的概念，有的程序员也许天生就不具备，有的程序员即便具备了，也懒得去琢磨。这里，我不赘述太多道理，读者只需观察两段代码即可，其中第一段，我加了大量的注释辅助：

    
    
    // <Games> 返回一组 game 信息
    // data 是一个数组，包含了所有 game 信息
    function Games({ data }) {  
      // 选出前 10 条 games
      const data1 = data.slice(0, 10)
      // list 是包含了 10 条 games 的 Game 组件集合
      const list = data1.map(function(v) {
        // v 代码当前 game
        return <Game key={v.id} name={v.name} />
      })
      return <ul>{list}</ul>
    }
    
    <Games  
       data=[{ id: 1, name: 'Mario' }, { id: 2, name: 'Doom' }] 
    />
    

第二段代码不需要一行注释：

    
    
    const GAMES_LIMIT = 10
    
    const GamesList = ({ items }) => {  
      const itemsSlice = items.slice(0, GAMES_LIMIT)
      const games = itemsSlice.map(gameItem => 
        <Game key={gameItem.id} name={gameItem.name} />
      )
      return <ul>{games}</ul>
    }
    
    <GamesList  
      items=[{ id: 1, name: 'Mario' }, { id: 2, name: 'Doom' }]
    />
    

组件设计功力，其实一个命名就能看出来；在做 code review 时，一个命名也能出卖你的深浅。

### 总结

本讲我们剖析了组件设计的基本原则，在原则范畴内，展现了组件的灵活性，并将组件复用性融汇在课程中。其实不光 React
组件如此，任何框架的组件也都是如此，超脱于组件范畴之外，API
设计也应用着相同的原则。这是编程最本质的思想，甚至从某种程度上，在编程之外，原子组建成大千世界的哲学道理都是异曲同工的。

### 分享交流

在阅读文章过程中有任何疑问可随时跟其他小伙伴讨论，或者直接向作者 LucasHC 提问（作者看到后抽空回复）。 **你的分享不仅帮助他人，更会提升自己。**

你也可以说说自己最想了解的主题，课程内容会根据部分读者的意见和建议迭代和完善。

此外，我们为本课程付费读者创建了《前端开发核心知识进阶》微信交流群，以方便更有针对性地讨论课程相关问题（入群请到第1-2课末尾添加 GitChat
小助手伽利略的微信，并注明「前端核心」，谢谢~）



## 揭秘 React 真谛：数据状态管理

如果说组件是 React 应用的骨骼，那么数据就是 React
应用的血液。单向数据流就像血液在应用体中穿梭。处理数据向来不是一件简单的事情，良好的数据状态管理不仅需要经验的积累，更是设计能力的反应。目前来看 Redux
无疑能够将数据状态理清，与此同时 Vue 阵营模仿 Redux 的 Vuex 也起到了相同的效果。这一讲我们就来谈谈数据状态管理，了解 Redux
的真谛，并分析其利弊和上层解决方案。

相关知识点如下：

![](https://images.gitbook.cn/9e6ec5b0-9b41-11e9-a438-01dafdf3f255)

### 数据状态管理之痛

我们先思考一个问题，为什么需要数据状态管理，数据状态管理到底在解决什么样的问题。这其实是框架、组件化带来的概念，让我们回到最初的起点，还是那个简单的案例：

![](https://images.gitbook.cn/c3fabdc0-9b41-11e9-9fc2-2d8a42344276)

点击页面中一处“收藏”之后，页面里其他“收藏”按钮也需要切换为“已收藏”状态：

![](https://images.gitbook.cn/3e2c7ac0-9b42-11e9-a438-01dafdf3f255)

如果没有数据状态，也许我们需要：

    
    
    const btnEle1 = $('#btn1')
    const btnEle2 = $('#btn2')
    
    btnEle1.on('click', () => {
        if (btnEle.textContent === '已收藏') {
            return
        }
        btnEle1.textContent = '已收藏'
        btnEle2.textContent = '已收藏'
    })
    
    btnEle2.on('click', () => {
        if (btnEle2.textContent === '已收藏') {
            return
        }
        btnEle1.textContent = '已收藏'
        btnEle2.textContent = '已收藏'
    })
    

这只是两个按钮的情况，处理起来就非常混乱难以维护了，这种情况非常容易滋生 bugs。

现代化的框架解决这个问题的思路是组件化，组件依赖数据，对应这个场景数据状态就是简单的：

    
    
    hasMarked: false / true
    

根据这个数据，所有的收藏组件都可以响应正确的视图操作。我们把面条式的代码转换成可维护的代码，重中之重就成了数据的管理，这就是数据状态的雏形。但是数据一旦庞大起来，如何和组件形成良好的交互就是一门学问了。比如我们要思考：

  * 一个组件需要和另一个组件共享状态
  * 一个组件需要改变另一个组件的状态

以 React 为例，其他框架类似，如果 React 或者 Vue 自己来维护这些数据，数据状态就是一个对象，并且这个对象在组件之间要互相修改，及其混乱。

接着我们衍生出这样的问题：hasMarked 这类数据到底是应该放在 state 中维护，还是借助数据状态管理类库，比如在 Redux
中维护呢？至少这样一来，数据源是单一的，数据状态和组件是解耦的，也更加方便开发者进行调试和扩展数据。

#### 数据谁来维护？

我们以 React state 和 Redux 为例，继续分析上面抛出的“数据谁来维护？”问题：

  * React 中 state 维护数据在组件内部，这样当某项 state 需要与其他组件共享时，我们可以通过 props 来完成组件间通讯。实践上来看，这就需要相对顶层的组件维护共享的 state 并提供修改此项 state 的方法，state 本身和修改方法都需要通过 props 传递给子孙组件。

  * 使用 Redux 的时候，state 维护在 Redux store 当中。任何需要访问并更新 state 的组件都需要感知或订阅 Redux store，这通常借助容器组件来完成。Redux 对于数据采用集中管理的方式。

我尝试从数据持久度、数据消费范围上来回答这个问题。

首先，数据持久度上，不同状态数据在持久度上大体可以分为三类：

  * 快速变更型
  * 中等持续型
  * 长远稳定型

**快速变更型，**
这类数据在应用中代表了某些原子级别的信息，且显著特点是变更频率最快。比如一个文本输入框数据值，可能随着用户输入在短时间内持续发生变化。这类数据显然更适合维护在
React 组件之内。

**中等持续型数据，** 在用户浏览或使用应用时，这类数据往往会在页面刷新前保持稳定。比如从异步请求接口通过 Ajax
方式得来的数据；又或者用户在个人中心页，编辑信息提交的数据。这类数据较为通用，也许会被不同组件所需求。在 Redux store 中维护，并通过
connect 方法进行连接，是不错的选择。

**长远稳定型数据，** 指在页面多次刷新或者多次访问期间都保持不变的数据。因为 Redux store
会在每次页面挂载后都重新生成一份，因此这种类型的数据显然应该存储在 Redux 以外其他地方，比如服务端数据库或者 local storage。

下面，我们从另一维度：数据消费范围来分析。数据特性体现在消费层面，即有多少组件需要使用。我们以此来区分 React 和 Redux 的不同分工。
**广义上，越多组件需要消费同一种数据，那么这种数据维护在 Redux store
当中就越合理；反之，如果某种数据隔离于其他数据，只服务于应用中某单一部分，那么由 React 维护更加合理。**

具体来看，共享的数据在 React 当中，应该存在于高层组件，由此组件进行一层层传递。如果在 props
传递深度上，只需要一两个层级就能满足消费数据的组件需求，这样的跨度是可以接受的；反之，如果跨越层级很多，那么关联到的所有中间层级组件都需要进行接力赛式的传递，这样显然会增加很多乏味的传递代码，也破坏了中间组件的复用性。这个时候，使用
Redux 维护共享状态，合理设置容器组件，通过 connect 来打通数据，就是一种更好的方式。

一些完全不存在父子关系的组件，如果需要共享数据，比如前面提到过的一个页面需要多处展示用户头像。这往往会造成数据辐射分散的问题，对于 React
模式的状态管理十分不利。在这种场景下，使用 Redux 同样是更好的选择。

最后一点，如果你的应用有跟踪状态的功能，比如需要完成“重放”，“返回”或者“Redo/Undo”类似需求，那么 Redux 无疑是最佳选择。因为 Redux
天生擅长于此：每一个 action 都描述了数据状态的改变和更新，数据的集中管理非常方便进行记录。

最后，什么情况下该使用哪种数据管理方式，是 React 维护 state 还是 Redux 集中管理，这个讨论不会有唯一定论。这需要开发者对于
React、Redux 有深入理解，并结合场景需求完成选择。

上面的 Redux 可以被任何一个数据管理类库所取代，也就是说，适合放在 Redux 中的数据，如果开发者没有使用 Redux，而使用了
Mobx，那么也应该放在 Mobx store 中。

#### 数据管理场景

我们来看一个场景来加深理解。

### Redux 到底怎么用

某电商网站，应用页面骨架如下：

![](https://images.gitbook.cn/2bbef600-9b43-11e9-9465-a7e3d006cf60)

对应代码：

    
    
    <ShoppingApp>
       <Header />
       <SideMenu />
       <ProductsContainer>
           // 遍历渲染每一个商品
       </ProductsContainer>
    </ShoppingApp>
    

其中，ProductsContainer 组件负责渲染每一个商品条目：

    
    
    import Product from './Product'
    
    export default class ProductsContainer extends Component {
      constructor(props) {
        super(props);
        this.state = {
          products: [
            '商品1',
            '商品2',
            '商品3'
          ]
        }
      }
      renderProducts() {
        return this.state.products.map((product) => {
          return <Product name={product} />
        })
      }
      render() {
        return (
          <div className='products-container'>
            {this.renderProducts()}
          </div>
        )
      }
    }
    

Product 组件作为 UI 组件／展示组件，负责接受数据、展现数据，Product 即可以用函数式／无状态组件完成：

    
    
    import React, { Component } from 'react'
    
    export default class Product extends Component {
      render() {
        return (
          <div className='product'>
            {this.props.name}
          </div>
        )
      }
    }
    

这样的设计，完全使用 React state 就可以完成，且合理高效。

但是，如果商品有“立即购买”按钮，点击购买之后加入商品到购物车（对应上面 Cart Info
部分）。这时候需要注意，购物车的商品信息会在更多页面被消费。比如：

  * 当前页面右上角需要展示购物车里的商品数目
  * 购物车页面本身
  * 支付前 checkout 页面
  * 支付页面

这就是单页面应用需要对数据状态进行管理的信号：我们维护一个 cartList 数组，供应用消费使用，这个数组放在 Redux 或者 Mobx，或者 Vuex
当中都是可行的。

#### 合理 connect 场景

在使用 Redux 时，我们搭配 React-redux 来对组件和数据进行联通（connect），一个常陷入的误区就是滥用
connect，而没有进行更合理的设计分析。也可能只在顶层进行了 connect 设计，然后再一层层进行数据传递。

比如在一个页面中存在 Profile、Feeds（信息流）、Images（图片）区域，如图所示。

![](https://images.gitbook.cn/3fe04fd0-9b43-11e9-9fc2-2d8a42344276)

这些区域构成了页面的主体，它们分别对应于 Profile、Feeds、Images 组件，共同作为 Page 组件的子组件而存在。

    
    
    <Page>
        <Profile/>
        <Feeds/>
        <Images/>
    </Page>
    

如果只对 Page 这个顶层组件进行 connect 设计，其他组件的数据依靠 Page 组件进行分发，则设计如图所示：

![](https://images.gitbook.cn/693a18c0-9b43-11e9-a438-01dafdf3f255)

这样做存在的问题如下：

  * 当改动 Profile 组件中的用户头像时，由于数据变动整个 Page 组件都会重新渲染；
  * 当删除 Feeds 组件中的一条信息时，整个 Page 组件也都会重新渲染；
  * 当在 Images 组件中添加一张图片时，整个 Page 组件同样都会重新渲染。

因此，更好的做法是对 Profile、Feeds、Images 这三个组件分别进行 connect 设计，在 connect 方法中使用
mapStateToProps 筛选出不同组件关心的 state 部分，如图所示：

![](https://images.gitbook.cn/893fa890-9b45-11e9-9465-a7e3d006cf60)

这样做的好处很明显：

  * 当改动 Profile 组件中的用户头像时，只有 Profile 组件重新渲染；
  * 当删除 Feeds 组件中的一条信息时，只有 Feed 组件重新渲染；
  * 当在 Images 组件中添加一张图片时，只有 Images 组件重新渲染。

#### 扁平化数据状态

扁平化的数据结构是一个很有意义的概念，它不仅能够合理引导开发逻辑，同时也是性能优化的一种体现。请看这样的数据结构：

    
    
    {
      articles: [{
        comments: [{
          authors: [{
          }]
        }]
      }],
      ...
    }
    

不难想象这是一个文章列表加文章评论互动的场景，其对应于三个组件：Article、Comment 和 Author。这样的页面设计比比皆是，如图所示：

![](https://images.gitbook.cn/b17c8fd0-9b45-11e9-9465-a7e3d006cf60)

相关 reducer 的处理很棘手，如果 articles[2].comments[4].authors1
发生了变化，想要返回更新后的状态，并保证不可变性，操作起来不是那么简单的，我们需要对深层对象结构进行拷贝或递归。

因此，更好的数据结构设计一定是扁平化的，我们对 articles、comments、authors 进行扁平化处理。例如 comments 数组不再存储
authors 数据，而是记录 userId，需要时在 users 数组中进行提取即可：

    
    
    {
      articles: [{
        ...
      }],
      comments: [{
        articleId: ..,
        userId: ...,
        ...
      }],
      users: [{
        ...
      }]
    }
    

不同组件只需要关心不同的数据片段，比如 Comment 组件只关心 comments 数组；Author 组件只关心 users
数组。这样不仅操作更合理，而且有效减少了渲染压力。

### Redux 的罪与罚

前文终点提到了 Redux，其实现原理较为简单，核心代码也不过几行，简要来说：Redux
是我们之前提到的发布订阅模式结合函数式编程的体现。这里不再过多赘述，我们主要来看看以 Redux 为首的数据状态管理类库的“缺陷”和发展点。

其实，Dan Abramov 很早就提到过 “You might not need Redux”，文中提到了 Redux 的限制。他也说过 “Try
Mobx” 这种“打脸”行为。归纳一下，Redux 的限制主要体现在：

  * Redux 带来了函数式编程、不可变性思想等，为了配合这些理念，开发者必须要写很多“模式代码（boilerplate）”，繁琐以及重复是开发者不愿意容忍的。当然也有很多 hack 旨在减少 boilerplate，但目前阶段，可以说 Redux 天生就附着繁琐。
  * 使用 Redux，那么你的应用就要用 objects 或者 arrays 描述状态。
  * 使用 Redux，那么你的应用就要使用 plain objects 即 actions 来描述变化。
  * 使用 Redux，那么你的应用就要使用纯函数去处理变化。
  * 应用中，状态很多都要抽象到 store，不能痛痛快快地写业务，一个变化就要对应编写 action（action creator）、reducer 等。

这些“缺点”和响应式结合函数式的 Mobx 相比，编程体验被“打了折扣”。

#### Redux 上层解决方案

为了弥补这些缺点，社区开启了一轮又一轮的尝试，其中一个努力方向是基于 Redux 封装一整套上层解决方案，这个方向以 Redux-
sage、dva、rematch 类库或框架为主。

我总结一下这些解决方案的特点和思路：

  * 简化初始化过程

传统的 Redux 初始化充满了 hack，过于函数式，且较为繁琐：

    
    
    import { createStore, applyMiddleware, compose } from 'redux'
    import thunk from 'redux-thunk'
    import rootReducer from './reducers'
    
    
    const initialState = {
        // ...
    }
    
    const store = initialState => createStore(
        rootReducer,
        initialState,
        compose(
            applyMiddleware(thunk),
            // ...
        )
    )
    

这其中我们只应用了一个中间件，还没有涉及到 devtool 的配置。而不论是 Dva 还是其他方案，都采用面向对象式的配置化初始。

  * 简化 reducers

传统的 reducers 可能需要写恼人的 switch...case 或很多样板代码，而更上层的解决方案进行封装后，类似：

    
    
    const reducer = {
        ACTIONTYPE1: (state, action) => newState,
        ACTIONTYPE2: (state, action) => newState,
    }
    

更加清爽。

  * 带请求的副作用

处理网络请求，Redux 一般需要 thunk 中间件，它的原理是：首先 dispatch 一个 action，但是这个 action 不是 plain
object 类型，而是一个函数；thunk 中间件发现 action type 为函数类型时，把 dispatch 和 getState
等方法作为参数，传递给函数进行副作用逻辑。

如果读者不是 React、Redux 开发者，也许很难看懂上一段描述，这也是 Redux 处理异步副作用的晦涩体现。更上层的解决方案 Redux-saga
采用 generator 的思想，或 async/await 处理副作用，无疑更加友好合理。

为了更好地配合生成器方案，上层方案将 action 分为普通 action 和副作用 action，开发者使用起来也更加清晰。

  * reducer 和 action 合并

为了进一步减少模版代码，一个通用的做法是在 Redux 之上，将 reducer 和 action 声明合并，类似：

    
    
    const store = {
        state: {
            count: 0,
            state1: {}
        },
        reduers: {
            action1: (state, action) => newState,
            action2: (state, action) => newState,
        }
    }
    

这样的声明一步到位，我们定义了两个 action：

  * action1
  * action2

它们出自于 store.reducers 的键名，而对应键值即为 reducer 逻辑。

这些都是基于 Redux 封装上层解决方案的基本思想，了解了这些，Dva、Redux-saga 原理已经对读者不再陌生！

当然，理清了数据状态管理的意义，简化了数据管理的操作，我们还要分析到底应该如何组织数据。

### 我们到底需要怎样的数据状态管理

关于 Redux，这里不再过多讨论。我们试图脱离开 Redux
本身，思考到底需要什么样的数据状态管理方案。整理我们的核心诉求就是：方便地修改数据，方便地获取数据。

#### 新的发展趋势：Mobx

从核心诉求出发，我们有两种做法：修改数据，Redux 提倡函数式、提倡不可变性、提倡数据扁平化，获取数据说到底是依赖发布订阅模式。相对地，Mobx
是面向对象和响应式的结合，它的数据源是可变的，对数据的观察是响应式的：

    
    
    const foo = observable({
        a: 1,
        b: 2
    })
    
    autoRun(() => {
        console.log(foo.a)
    })
    
    foo.b = 3 // 没有任何输出
    foo.a = 2 // 输出：2
    

这像不像我们前面课程提到的数据拦截/代理？没错，它们的原理都是完全一致的。尝试对上面的代码改为：

    
    
    const state = observable({
        state1: {}
    })
    
    autoRun(() => {
        return (<Component state1={state1} />)
    })
    
    state.state1 = {} 
    

当我们改动 state.state1 时，autoRun 的回调将会触发，引起了组件的重新渲染。不同于 Redux，这就是另一种流派 Mobx 的核心理念。

不管是 Redux 还是 Mobx，它们都做到了：组件可以读取 state，修改 state；有新 state 时更新。这个 state
是单一数据源，只不过修改 state 方式不同。更近一步地说，Mobx 通过包装对象和数组为可观察对象，隐藏了大部分的样板代码，比 Redux
更加简洁，也更加“魔幻”，更像是“双向绑定”。

对此我的建议是：在数据状态不太复杂的情况下，Mobx 也许更加简洁高效；如果数据状态非常复杂，或者你是函数式编程的粉丝，可以考虑 Redux，但是在
Redux 层上进行封装，使用类似 Dva 方案，是一个明智的选择。

#### 如何做到 Redux free（context 和 hooks）

做到 Redux free，有两种选择：一个是拥抱 Mobx 或者 GraphQL，但还是没有脱离框架或者类库；另一个选择就是选择原生 React
方案，其中之一就是 context API，React 16.3 介绍了稳定版的 context
特性，它从某种程度上可以更方便地实现组件间通信，尤其是对于跨越多层父子组件的情况，更加高效。我们知道 Redux-react 就是基于 context
实现的，那么在一些简单的情况下，完全可以使用稳定的 context，而抛弃 Redux。

在 ReactConf 2018 会议中，React 团队发布了 React hooks。简单来看，hooks
给予了函数式组件像类组件工作的能力，函数式组件可以使用 state，并且在一些副作用后进行 update。useReducer hooks 搭配
context API 以及 useContext hook，完全可以模仿一个简单的 Redux。useReducer hooks 使我们可以像
reducer 的方式一样更新 state，useContext 可以隔层级传递数据，原生 React 似乎有了内置 Redux
的能力。当然这种能力是不全面的，比如对网络请求副作用的管理、时间旅行和调试等。

这不是一篇讲解 React 的课程，具体代码细节我们不再展开，感兴趣的读者可以参考：

  * [react hooks VS redux](https://www.reddit.com/r/reactjs/comments/bqf5ot/can_anyone_tell_me_why_hooks_have_exploded/eo6fe6e/?context=10000)
  * [from-redux-to-hooks-case-study](https://staleclosures.dev/from-redux-to-hooks-case-study/)

### 总结

其实数据状态管理没有永恒的“最佳实践”。随着应用业务的发展，数据的复杂程度是不断扩张的，数据和组件是绑定在一起的概念，我们如何梳理好数据，如何对于特定的行为修改特定的数据，给予特定组件特定的数据，是一个非常有趣的话题，也是进阶路上的“必修课”。

### 分享交流

阅读文章过程中有任何疑问可随时跟其他小伙伴讨论，或者直接向作者 LucasHC 提问（作者看到后抽空回复）。 **你的分享不仅帮助他人，更会提升自己。**

你也可以说说自己最想了解的主题，课程内容会根据部分读者的意见和建议迭代和完善。

此外，我们为本课程付费读者创建了《前端开发核心知识进阶》微信交流群，以方便更有针对性地讨论课程相关问题（入群请到第1-2课末尾添加 GitChat
小助手伽利略的微信，并注明「前端核心」，谢谢~）



## React 的现状与未来

React 自推出以来，一直进行着自身完善和演进。作为 React
开发者或前端开发者，有幸见证着一个伟大“框架”的成长，是非常幸运的。那么在这个过程中，我们应该学些什么？React 现在处于什么发展阶段？React
未来又将有哪些规划？

高级前端工程师不能只停留在使用框架上，我们自然要思考上述这些问题。这一讲我们就来聊聊 React 的现状与未来，如果不熟悉 React，也并不妨碍大家阅读。

相关知识点如下：

![](https://images.gitbook.cn/3acdade0-9d3b-11e9-9eee-292fd7e6afca)

### React 现状分析

React 经过几年的打磨，目前维持了一个稳定的迭代周期，并不断给开发者带来惊喜。其中难能可贵的是在 breaking changes
不多的前提下，仍在持续输出具有变革精神的特性，保持着旺盛的生命力。不管是什么平台的调查，都显示 React 受众仍然最多，可以预见的是，React
未来仍将会统领前端发展。

关于 React 现状，我总结出以下几个特点：

  * 开发模式已经定型，有利于开发者持续学习
  * 仍然有强大的开发团队维护，不断带来改变，这些改变一方面使 React 更好，另一方面甚至推动了 JavaScript 语言的发展
  * 社区生态强大，有一系列解决方案，数据状态管理、组件库、服务端渲染生态群百花齐放

在这些特点的背后，也有一些让开发者担忧的地方：

  * 概念越来越多。一定程度上，新老概念并存，学习曲线激增
  * 存在较多 unsafe_ 标记的 APIs，始终担忧彻底废弃相关 APIs 那一天的到来
  * 新特性带来了较多“魔法”，也带来了一些困惑

当然，这些让开发者担忧的地方并不足以和 React
的强大相提并论，这些“问题”甚至在任何一个框架中都会存在。因此，我建议不管是工作需要，还是自身学习需要，前端开发者都可以使用并研究 React。

### 从 React Component 看 React 发展史

回顾 React 发展历史，很多 APIs 和特性的演进都很有意思，比如
refs、context，其中任何一点都值得单拎出来深入分析。但是我挑选了一个开发者一定会使用的 React Component
话题：从组件的创建和声明方式，我们来看一个框架的变革，并由此引出 React 目前最受关注的的 hooks 新特性。

React Component 的发展主要经历了三个阶段：

  * createClass 创建组件时期
  * ES class 声明组件时期
  * 无状态（函数式）组件 + React hooks 时期

这一路，也是 React 从一个纯粹的视图层类库走向成熟完善的解决方案的过程。我们逐一来看。

#### createClass 创建组件时期

相信很多新的开发者都没有使用过 createClass API 创建组件，createClass 是一个函数，接受参数并返回组件实例，用起来并不复杂：

    
    
    import React from 'react'
    
    const component1 = React.createClass({
      propTypes: {
        foo: React.PropTypes.string
      },
    
      getDefaultProps() {
        return {
            foo: 'bar'
        }
      },
    
    
      getInitialState() { 
          return {
          state1: 'lucas'
        }
      },
    
      handleClick() {
    
      },
    
      render() {
        return (
          <p onClick={this.handleClick}></p>
        )
      }
    })
    

看起来很好理解，但是编写还是有些违背直觉。从 React 15.5 版本开始，官方就不再开始推荐，到了 React 16 版本，已经彻底废弃。

#### Class 声明组件时期

createClass 退出历史舞台的原因是被强势的 class 声明组件方式所取代。当时 ES6 正在如火如荼地发展，新增了 class
这一语法糖，React 团队很快赶时髦，支持了使用 class 声明组件的方式：

    
    
    class Component1 extends React.Component {
      state = { name: 'Lucas' }
    
      handleClick = e => {
        console.log(e)
        this.setState({
          name: 'Messi',
        })
      }
    
      render() {
        return (
          <div onClick={this.handleClick}>
            {{this.state.name}}
          </div>
        )
      }
    }
    

代码非常直观清爽，但是 class 声明方式和早期的 createClass 相比，有非常重要的两点差别：

  * React.createClass 支持在事件处理函数中自动绑定 this，而 class 声明的组件需要开发者手动绑定
  * React.Component 不能使用 React mixins 来实现复用

这两个显著不同点决定了 React 生态社区发展的方向。

其中第一点不同，决定了 React 放弃了“多管闲事”地绑定 this，虽然这个行为在很多人看来毫无必要，很多类 React
框架都会帮助开发者对事件处理函数绑定 this，Vue 也是如此。

但是我们一般进行绑定 this 的方案多种多样，上述代码采用了 ES Next 的属性初始化方法，对 handleClick 进行了绑定。

第二点不同，决定了 React 实现复用的方式发展方向。首先肯定的是官方认为 mixin 是弊大于利的，已经被彻底放弃。那么社区跟进复用方案主要有两种：

  * 高阶组件
  * render prop 模式

其中高阶组件很好地体现了 React 函数式思想，是 React 精华之体现。而 render prop 目前也非常流行，并最终推动了 React
自身的发展：新的 context 特性，其 API 也变革为 render prop 模式，这是社区反哺 React 的例证：

    
    
    <ContextComponent.Consumer>
      {value => (
        <Component value={value}>
      )}
    </ContextComponent.Consumer>
    

但是使用 class 声明组件不是完美无懈可击的。React 官方团队认为，这种方式“已经背离了 React 的初衷”。我总结下来，class
声明组件的问题有以下两个。

  * 带来了“面向生命周期编程”的困扰，随着逻辑变复杂，组件的生命周期函数随之变得很难维护和理解。我们想理清楚 componentDidMount、componentDidUpdate、componentWillUnmount、componentWillRecieveProps 这些钩子的逻辑并不困难。但是这些生命周期函数中的代码和 render 中的 state 以及 props 有什么关系？这些问题将会随着应用的复杂被无限放大，
  * React 是函数式的，而 class 声明组件这种面向对象的行为显得不伦不类。

基于这两点，React 很快推出了函数式组件，或无状态组件（下面统称函数式组件，因为无状态组件在 hooks 特性下也会有状态）。

#### 函数式组件

函数式组件非常简单，我们用函数定义一个组件，该函数接受 props 作为参数，只负责渲染：

    
    
    const component = props => <div> { props.name } </div>
    

这样的实现看上去棒极了，组件只负责接收数据并渲染，难得如此清爽和直接。然而它是完全无法取代 class
组件的，因为它不存在生命周期，完全的无状态让我们无法处理必要的逻辑。

因此，class 声明组件结合函数式组件的方案，类似容器组件结合木偶组件，成为现在的主流方式。

从 React component 的发展，我们能够管中窥豹：从中可以发现 React 绑定 this 的设计、React
实现复用的方案等一系列知识点，它无疑是 React 类库的主干。不过我们继续设想，能不能赋予函数式组件以类似生命周期的能力，完美解决 class
组件的问题？这就是 React 近期带来的 React hooks 特性。请继续阅读。

### 颠覆性的 React hooks

说起 React hooks，想必大家已经了解了它出现的背景，那么它是如何解决问题的呢？

简单来说，它使得开发者可以按业务逻辑拆分代码，而不是生命周期。这样如果想实现复用，直接在任何组件中引入相关 hooks 即可。Hooks
把代码按照业务逻辑的相关性进行拆分，把同一业务的代码集中在一起，不同业务的代码独立开来，维护起来就清楚很多。

这里我们不会科普 hooks 的使用方案，因为官网上介绍的一定最好、最详尽，我们从原理和设计的角度来进行分析。

#### 轻量级 useState

事实上，setState API 并没有什么问题，它也足够轻量，真正笨重的是 class 组件结合 setState。而使用 useState
hook，使得函数式组件也具备了操作 state 的能力，且不需要引入生命周期函数。

useState 是一个函数，入参是 initialState；它返回一个数组，第一值是 state，第二个值是改变 state 的函数。

这里我来插播一个细节，为什么 useState 返回一个数组呢（其实返回的是 tuple，但是 JavaScript 还没有这个概念）？

    
    
    let [name, setName]= useState('lucas')
    

如果返回的是一个对象是否更合适呢？

    
    
    let { state: name, setState: setName } = useState('lucas')
    

这样表意更加清晰，而简单。也支持我们自动设置别名。事实上 React RFC 确实有相关讨论：[RFC: React Hooks
](https://github.com/reactjs/rfcs/pull/68#issuecomment-433135283)。

useState 其实很好实现：

    
    
    const React = (function() {
      let stateValue
    
      return Object.assign(React, {
        useState(initialStateValue) {
          stateValue = stateValue || initialStateValue
    
          function setState(value) {
            stateValue = value
          }
    
          return [stateValue, setState]
        }
      })
    })()
    

我们使用 stateValue 闭包变量储存 state，并提供修改 stateValue 的方法 setState，一并作为数组返回。

#### useEffect 和生命周期那些事儿

函数式组件通过 useState 具备了操控 state 的能力，修改 state 需要在适当的场景进行：class 声明的组件在组件生命周期中进行
state 更迭，那么在函数式组件中呢？我们需要用 useEffect 模拟生命周期，目前 useEffect 相当于 class Component 中的
componentDidMount、componentDidUpdate、componentWillUnmount 三个生命周期的综合。

也就是说：useEffect 声明的回调函数会在组件挂载、更新、卸载的时候执行。为了避免每次渲染都执行所有的 useEffect 回调，useEffect
提供了第二个参数，该参数是数组类型。只有在渲染时数组中的值发生了变化，才会执行该 useEffect
回调。如果传的是个空数组，也就是说并不依赖任何其它值，因此这样只会在组件第一次 Mount 后和 Unmount 前调用。

我们尝试实现 useEffect：

    
    
    const React = (function() {
      let deps
    
      return Object.assign(React, {
        useEffect(callback, depsArray) {
          const shouldUpdate = !depsArray
    
          const depsChange = deps ? !deps.every((depItem, index) => depItem === depsArray[index]) : true
    
          if (shouldUpdate || depsChange) {
              callback()
    
              deps = depsArray || []
          }
        }
      })
    })()
    

我们看闭包变量 deps 存储前一刻 useEffect 的依赖数组值。在每次调用 useEffect 时，我们都会遍历 deps 数组和当前
depsArray 数组值，如果其中的任何一项有变化，depsChange 将为 true，进而执行 useEffect 的回调。

有读者可能会想到，那么生命周期 shouldComponentUpdate 如何模拟呢？事实上，我们不需要用 useEffect 来实现
shouldComponentUpdate。React 新特性中专门提供了 React.memo 来帮助开发者进行性能优化。另外，useEffect
是无法模拟 getSnapshotBeforeUpdate 和 componentDidCatch 这两个生命周期函数的。

上述两种实现都是简易版的，旨在剖析这两个 hooks 的工作原理，更多细节都没有实现。最重要的一点是：如果组件内多次调用 useState 或
useEffect，我们的实现为了区分每次 useState 调用之前不同的 state 值及
setter，需要额外使用一个数组来存储每次调用的配对值，比如：

    
    
    const React = (function() {
      let hooks = []
      let currentHook = 0
    
      return Object.assign(React, {
        useState(initialStateValue) {
          hooks[currentHook] = hooks[currentHook] || initialStateValue
    
          function setState(value) {
            hooks[currentHook] = value
          }
    
          return [hooks[currentHook++], setState]
        },
    
        useEffect(callback, depsArray) {
          const shouldUpdate = !depsArray
    
          const depsChange = hooks[currentHook] ? !hooks[currentHook].every((depItem, index) => depItem === depsArray[index]) : true
    
          if (shouldUpdate || depsChange) {
              callback()
    
              hooks[currentHook++] = depsArray || []
          }
        }
    
      })
    })()
    

这也是为什么 hooks 只可以在顶层使用，不能写在循环体、条件渲染，或者嵌套 function 里。因为 React 内部实现需要按调用顺序来记录每个
useState 的调用，以做区分。

#### useReducer 和 Redux

我们知道，如果 State 的变化有比较复杂的状态流转，可以使用新的 hooks：useReducer 让应用更加 Redux
化，使得逻辑更加清晰。那么首先思考一个问题：到底是该用 useState 还是 useReducer 呢？

为此，我总结如下。

使用 useState 的情况：

  * state 为基本类型（也要看情况）
  * state 转换逻辑简单的场景
  * state 转换只会在当前组件中出现，其他组件不需要感知这个 state
  * 多个 useState hooks 之间的 state 并没有关联关系

使用 useReducer 的情况：

  * state 为引用类型（也要看情况）
  * state 转换逻辑比较复杂的场景
  * 不同 state 之间存在较强的关联关系，应该作为一个 object，用一个 state 来表示的场景
  * 如果需要更好的可维护性和可测试性

其实翻看 React 源码 useState 实现，useState 本质是 useReducer 的一个语法糖。

第二个问题：useReducer 是否代表着 React 内置了 Redux，我们就可以脱离 Redux 了呢？事实上，确实可以用简单的 React
代码，借助 context API 实现全局 Redux 或者局部 Redux：

store.js 文件：

    
    
    import React from 'react'
    const store = React.createContext(null)
    
    export const initialState = { 
        // ...
    }
    
    export const reducer = (state, action) => {
      switch (action.type) {
        // ...
      }
    }
    export default store
    

Provider 根组件挂载：

    
    
    import React, { useReducer } from 'react'
    import store, { reducer, initialState } from './store'
    
    function App() {
      const [state, dispatch] = useReducer(reducer, initialState)
      return (
         <store.Provider value={{ state, dispatch }}>
          <div/>
         </store>
      )
    }
    

业务组件就可以直接使用：

    
    
    import React, { useContext } from 'react'
    import store from './store'
    
    cosnt Child = props => {
      const { state, dispatch } = useContext(store)
      // ...
    }
    

但是这样的行为尚不足以完全取代 Redux，我们这里不做展开。

#### React hooks 之 Hooks 之所以可以设计为 Hooks 的原因

我们现在了解了：

  * useState 让函数式组件能够使用 state
  * useEffect 让函数式组件可以模拟生命周期方法，并进行副作用操作
  * useReducer 让我们能够更清晰地处理状态数据
  * useContext 可以获取 context 值

那么为什么其他的一些 APIs，比如 React.memo 并没有成为一个 hook 呢？事实上 React 认为能够成为 hooks 的条件有两个特定：

  * composition：这个新特性需要具有组合能力，也就是说需要有复用价值，因为 hooks 的一大目标就是完成组件的复用。针对于此，开发者可以自定义 hooks，而不必官方束缚指定的 hooks，这样反倒可能会发成冲突；

  * debugging：hooks 一大特性就是能够调试，如果应用出现差错，我们能够从错误的 props 和 state 当中找到错误的组件或逻辑，能够具有这样调试功能的特性，才应该成为一个 hooks。

为此 Dan abramov 专门写了篇文章来讲述：[Why Isn’t X a Hook?](https://overreacted.io/why-
isnt-x-a-hook/)，这里我们不再赘述。

### 值得关注的其他 React 特性

我认为在众多新特性中，还有一个可能会对社区带来较大影响的是 React v16.6 发布的 React.Suspense 和
React.lazy。具体用法我们不再讲解，读者可自行补充基础知识。React.Suspens 给了 React 组件异步（中断）渲染的能力，打破了
React 组件之前“一鼓作气”渲染的格局。而 React.lazy 带来了延迟加载的能力，可以很好地取代社区上的一些轮子实现。

我们来看一个场景，React.Suspense 结合 React.lazy，实现代码分割和按需加载。

目前按需加载一般都采用 react-lodable，这个库稳定优雅且支持服务端渲染：

    
    
    const Loading = ({ delay }) => {
      if (delay) {
        return <Spinner />
      }
      return null
    }
    
    export const AsyncComponent = Loadable({
      loader: () => import(/* webpackChunkName: "Component1" */ './component1'),
      loading: Loading,
      delay: 500
    })
    

这段代码定义了一个 Loading 组件，在请求返回之前进行渲染；delay 参数表示时间超过 500 毫秒才显示 Loading，防止闪烁 Loading
的出现。

如果换成 React.Suspense + React.lazy：

    
    
    const Component = React.lazy(() => import(/* webpackChunkName: "Component1" */ './component1'))
    
    export const AsyncComponent = props => (
      <React.Suspense fallback={<Loading />}>
        <Component {...props} />
      </React.Suspense>
    );
    

React.lazy 封装动态 import 的 React 组件，它要求 import() 必须返回一个会 Promise 对象，并且这个 Promise
对象会 resolve 为一个 ES 模块，模块中 export default 必须是一个合法的 React 组件。

React.Suspense 组件设置 fallback prop，当发现我们的 Component 是一个 Promise 类型时，且这个 Promise
没有被 resolved，那么就启用 fallback prop 所提供的组件，以便在我们等待网络返回结果时进行渲染。

我们可以结合 Error Boundary 特性，对于网络或者其他错误时，进行错误处理：

    
    
    <MyCustomErrorBoundary>
      <AsyncComponent />
    </MyCustomErrorBoundary>
    

这样一来我们就实现了简单的 react-loadable 库。当然在 React.suspense 正式发布之前，我们当然可以自己手动实现一个
React.Suspense 组件，这里提供一个简单的版本，未考虑边界情况：

    
    
    export class Suspense extends React.Component {
        state = {
          isLoading: false
        }
    
        componentDidCatch(error) {
          if (typeof error.then === 'function') {
            this.setState({ isLoading: true })
            error.then(() => {
              this.setState({ isLoading: false })
            })
          }
        }
    
        render() {
          const { children, fallback } = this.props
          const { isLoading } = this.state
    
          return isLoading ? fallback : children
        }
    }
    

核心思路就是在首次渲染 Promise 出错时，使用 componentDidCatch 进行捕获，转而通过状态切换渲染 fallback 组件；在
Promise resolve 之后，通过状态切换渲染目标组件。

### 总结

这一讲我们梳理了 React 发展史上重要的里程碑，并展望了 React
未来发展。任何一门框架其实都免不了从问世到巅峰、再到逐步退出的过程。一个框架的兴衰，印证着技术潮流的更迭，作为开发者，合理分析框架发展背后的技术趋势，就非常重要了。

### 分享交流

阅读文章过程中有任何疑问可随时跟其他小伙伴讨论，或者直接向作者 LucasHC 提问（作者看到后抽空回复）。 **你的分享不仅帮助他人，更会提升自己。**

你也可以说说自己最想了解的主题，课程内容会根据部分读者的意见和建议迭代和完善。

此外，我们为本课程付费读者创建了《前端开发核心知识进阶》微信交流群，以方便更有针对性地讨论课程相关问题（入群请到第1-2课末尾添加 GitChat
小助手伽利略的微信，并注明「前端核心」，谢谢~）



## 同构应用中你所忽略的细节

不管是服务端渲染还是服务端渲染衍生出的同构应用，现在来看已经并不新鲜了，实现起来也并不困难。可是有的开发者认为：同构应用不就是调用一个
renderToString（React 中）类似的 API 吗？

讲道理确实是这样的，但是讲道理你也许并没有真正在实战中领会同构应用的精髓。

同构应用能够完成的本质条件是虚拟 DOM，基于虚拟 DOM 我们可以生成真实的 DOM，并由浏览器渲染；也可以调用不同框架的不同 APIs，将虚拟 DOM
生成字符串，由服务端传输给客户端。

但是同构应用也不只是这么简单。拿面试来说，同构应用的考察点不是“纸上谈兵”的理论，而是实际实施时的细节。这一讲我们就来聊一聊“同构应用中往往被忽略的细节”，需要读者提前了解服务端渲染和同构应用的概念。

相关知识点如下：

![](https://images.gitbook.cn/d5314df0-9d55-11e9-8a2c-e9ea8cc9b822)

### 打包环境区分

第一个细节：我们知道同构应用实现了客户端代码和服务端代码的基本统一，我们只需要编写一种组件，就能生成适用于服务端和客户端的组件案例。可是你是否知道，服务端代码和客户端代码大多数情况下还是需要单独处理？比如：

  * 路由代码差别：服务端需要根据请求路径，匹配页面组件；客户端需要通过浏览器中的地址，匹配页面组件。

客户端代码：

    
    
    const App = () => {
      return (
        <Provider store={store}>
          <BrowserRouter>
            <div>
              <Route path='/' component={Home}>
              <Route path='/product' component={Product}>
            </div>
          </BrowserRouter>
        </Provider>
      )
    }
    ReactDom.render(<App/>, document.querySelector('#root'))
    

BrowserRouter 组件根据 window.location 以及 history API 实现页面切换，而服务端肯定是无法获取
window.location 的，服务端代码如下：

    
    
    const App = () => {
      return 
        <Provider store={store}>
          <StaticRouter location={req.path} context={context}>
            <div>
              <Route path='/' component={Home}>
            </div>
          </StaticRouter>
        </Provider>
    }
    Return ReactDom.renderToString(<App/>)
    

需要使用 StaticRouter 组件，并将请求地址和上下文信息作为 location 和 context 这两个 props 传入
StaticRouter 中。

  * 打包差别：服务端运行的代码如果需要依赖 Node 核心模块或者第三方模块，就不再需要把这些模块代码打包到最终代码中了。因为环境已经安装这些依赖，可以直接引用。这样一来，就需要我们在 webpack 中配置：target：node，并借助 webpack-node-externals 插件，解决第三方依赖打包的问题。

  * 对于图片等静态资源，url-loader 会在服务端代码和客户端代码打包过程中分别被引用，因此会在资源目录中生成了重复的文件。当然后打包出来的因为重名，会覆盖前一次打包出来的结果，并不影响使用，但是整个构建过程并不优雅。

  * 由于路由在服务端和客户端的差别，因此 webpack 配置文件的 entry 会不相同：

    
    
    {
        entry: './src/client/index.js',
    }
    
    {
        entry: './src/server/index.js',
    }
    

### 注水和脱水

什么叫做注水和脱水呢？这个和同构应用中数据的获取有关：在服务器端渲染时，首先服务端请求接口拿到数据，并处理准备好数据状态（如果使用 Redux，就是进行
store 的更新），为了减少客户端的请求，我们需要保留住这个状态。一般做法是在服务器端返回 HTML 字符串的时候，将数据 JSON.stringify
一并返回，这个过程，叫做脱水（dehydrate）；在客户端，就不再需要进行数据的请求了，可以直接使用服务端下发下来的数据，这个过程叫注水（hydrate）。用代码来表示：

服务端：

    
    
    ctx.body = `
      <!DOCTYPE html>
      <html lang="en">
        <head>
          <meta charset="UTF-8">
        </head>
        <body>
            <script>
            window.context = {
              initialState: ${JSON.stringify(store.getState())}
            }
          </script>
          <div id="app">
              // ...
          </div>
        </body>
      </html>
    `
    

客户端：

    
    
    export const getClientStore = () => {
      const defaultState = JSON.parse(window.context.state)
      return createStore(reducer, defaultState, applyMiddleware(thunk))
    }
    

这一系列过程非常典型，但是也会有几个细节值得探讨： **在服务端渲染时，服务端如何能够请求所有的 APIs，保障数据全部已经请求呢？**

一般有两种方法：

  * react-router 的解决方案是配置路由 route-config，结合 matchRoutes，找到页面上相关组件所需的请求接口的方法并执行请求。这就要求开发者通过路由配置信息，显式地告知服务端请求内容。

我们首先配置路由：

    
    
    const routes = [
      {
        path: "/",
        component: Root,
        loadData: () => getSomeData()
      }
      // etc.
    ]
    
    import { routes } from "./routes"
    
    function App() {
      return (
        <Switch>
          {routes.map(route => (
            <Route {...route} />
          ))}
        </Switch>
      )
    }
    

在服务端代码中：

    
    
    import { matchPath } from "react-router-dom"
    
    const promises = []
    routes.some(route => {
      const match = matchPath(req.path, route)
      if (match) promises.push(route.loadData(match))
      return match
    })
    
    Promise.all(promises).then(data => {
      putTheDataSomewhereTheClientCanFindIt(data)
    })
    

  * 另外一种思路类似 Next.js，我们需要在 React 组件上定义静态方法。 比如定义静态 loadData 方法，在服务端渲染时，我们可以遍历所有组件的 loadData，获取需要请求的接口。这样的方式借鉴了早期 React-apollo 的解决方案，我个人很喜欢这种设计。这里贴出我为 Facebook 团队 react-apollo 开源项目贡献的改动代码，其目的就是遍历组件，获取请求接口：

    
    
    function getPromisesFromTree({
      rootElement,
      rootContext = {},
    }: PromiseTreeArgument): PromiseTreeResult[] {
      const promises: PromiseTreeResult[] = [];
    
      walkTree(rootElement, rootContext, (_, instance, context, childContext) => {
        if (instance && hasFetchDataFunction(instance)) {
          const promise = instance.fetchData();
          if (isPromise<Object>(promise)) {
            promises.push({ promise, context: childContext || context, instance });
            return false;
          }
        }
      });
    
      return promises;
    }
    
    // Recurse a React Element tree, running visitor on each element.
    // If visitor returns `false`, don't call the element's render function
    // or recurse into its child elements.
    export function walkTree(
      element: React.ReactNode,
      context: Context,
      visitor: (
        element: React.ReactNode,
        instance: React.Component<any> | null,
        context: Context,
        childContext?: Context,
      ) => boolean | void,
    ) {
      if (Array.isArray(element)) {
        element.forEach(item => walkTree(item, context, visitor));
        return;
      }
    
      if (!element) {
        return;
      }
    
      // A stateless functional component or a class
      if (isReactElement(element)) {
        if (typeof element.type === 'function') {
          const Comp = element.type;
          const props = Object.assign({}, Comp.defaultProps, getProps(element));
          let childContext = context;
          let child;
    
          // Are we are a react class?
          if (isComponentClass(Comp)) {
            const instance = new Comp(props, context);
            // In case the user doesn't pass these to super in the constructor.
            // Note: `Component.props` are now readonly in `@types/react`, so
            // we're using `defineProperty` as a workaround (for now).
            Object.defineProperty(instance, 'props', {
              value: instance.props || props,
            });
            instance.context = instance.context || context;
    
            // Set the instance state to null (not undefined) if not set, to match React behaviour
            instance.state = instance.state || null;
    
            // Override setState to just change the state, not queue up an update
            // (we can't do the default React thing as we aren't mounted
            // "properly", however we don't need to re-render as we only support
            // setState in componentWillMount, which happens *before* render).
            instance.setState = newState => {
              if (typeof newState === 'function') {
                // React's TS type definitions don't contain context as a third parameter for
                // setState's updater function.
                // Remove this cast to `any` when that is fixed.
                newState = (newState as any)(instance.state, instance.props, instance.context);
              }
              instance.state = Object.assign({}, instance.state, newState);
            };
    
            if (Comp.getDerivedStateFromProps) {
              const result = Comp.getDerivedStateFromProps(instance.props, instance.state);
              if (result !== null) {
                instance.state = Object.assign({}, instance.state, result);
              }
            } else if (instance.UNSAFE_componentWillMount) {
              instance.UNSAFE_componentWillMount();
            } else if (instance.componentWillMount) {
              instance.componentWillMount();
            }
    
            if (providesChildContext(instance)) {
              childContext = Object.assign({}, context, instance.getChildContext());
            }
    
            if (visitor(element, instance, context, childContext) === false) {
              return;
            }
    
            child = instance.render();
          } else {
            // Just a stateless functional
            if (visitor(element, null, context) === false) {
              return;
            }
    
            child = Comp(props, context);
          }
    
          if (child) {
            if (Array.isArray(child)) {
              child.forEach(item => walkTree(item, childContext, visitor));
            } else {
              walkTree(child, childContext, visitor);
            }
          }
        } else if ((element.type as any)._context || (element.type as any).Consumer) {
          // A React context provider or consumer
          if (visitor(element, null, context) === false) {
            return;
          }
    
          let child;
          if ((element.type as any)._context) {
            // A provider - sets the context value before rendering children
            ((element.type as any)._context as any)._currentValue = element.props.value;
            child = element.props.children;
          } else {
            // A consumer
            child = element.props.children((element.type as any)._currentValue);
          }
    
          if (child) {
            if (Array.isArray(child)) {
              child.forEach(item => walkTree(item, context, visitor));
            } else {
              walkTree(child, context, visitor);
            }
          }
        } else {
          // A basic string or dom element, just get children
          if (visitor(element, null, context) === false) {
            return;
          }
    
          if (element.props && element.props.children) {
            React.Children.forEach(element.props.children, (child: any) => {
              if (child) {
                walkTree(child, context, visitor);
              }
            });
          }
        }
      } else if (typeof element === 'string' || typeof element === 'number') {
        // Just visit these, they are leaves so we don't keep traversing.
        visitor(element, null, context);
      }
    }
    

注水和脱水，是同构应用最为核心和关键的细节点。

### 请求认证处理

上面讲到服务端预先请求数据，那么思考这样的场景：某个请求依赖 cookie
表明的用户信息，比如请求“我的学习计划列表”。这种情况下服务端请求是不同于客户端的，不会有浏览器添加 cookie 以及不含有其他相关的 header
信息。这个请求在服务端发送时，一定不会拿到预期的结果。

为了解决这个问题，我们来看看 React-apollo 的解决方法：

    
    
    import { ApolloProvider } from 'react-apollo'
    import { ApolloClient } from 'apollo-client'
    import { createHttpLink } from 'apollo-link-http'
    import Express from 'express'
    import { StaticRouter } from 'react-router'
    import { InMemoryCache } from "apollo-cache-inmemory"
    
    import Layout from './routes/Layout'
    
    // Note you don't have to use any particular http server, but
    // we're using Express in this example
    const app = new Express();
    app.use((req, res) => {
    
      const client = new ApolloClient({
        ssrMode: true,
        // Remember that this is the interface the SSR server will use to connect to the
        // API server, so we need to ensure it isn't firewalled, etc
        link: createHttpLink({
          uri: 'http://localhost:3010',
          credentials: 'same-origin',
          headers: {
            cookie: req.header('Cookie'),
          },
        }),
        cache: new InMemoryCache(),
      });
    
      const context = {}
    
      // The client-side App will instead use <BrowserRouter>
      const App = (
        <ApolloProvider client={client}>
          <StaticRouter location={req.url} context={context}>
            <Layout />
          </StaticRouter>
        </ApolloProvider>
      );
    
      // rendering code (see below)
    })
    

这个做法也非常简单，原理是：服务端请求时需要保留客户端页面请求的信息，并在 API 请求时携带并透传这个信息。上述代码中，createHttpLink
方法调用时：

    
    
    headers: {
        cookie: req.header('Cookie'),
    },
    

这个配置项就是关键，它使得服务端的请求完整地还原了客户端信息，因此验证类接口也不再会有问题。

事实上，很多早期 React 完成服务端渲染的轮子都借鉴了 React-apollo 众多优秀思想，对这个话题感兴趣的读者可以抽空去了解 React-
apollo。

### 样式问题处理

同构应用的样式处理容易被开发者所忽视，而一旦忽略，就会掉到坑里。比如，正常的服务端渲染只是返回了 HTML 字符串，样式需要浏览器加载完 CSS
后才会加上，这个样式添加的过程就会造成页面的闪动。

再比如，我们不能再使用 style-loader 了，因为这个 webpack loader 会在编译时将样式模块载入到 HTML header
中。但是在服务端渲染环境下，没有 window 对象，style-loader 进而会报错。一般我们换用 isomorphic-style-loader
来实现：

    
    
    {
        test: /\.css$/,
        use: [
            'isomorphic-style-loader',
            'css-loader',
            'postcss-loader'
        ],
    }
    

同时 isomorphic-style-loader 也会解决页面样式闪动的问题。它的原理也不难理解：在服务器端输出 html 字符串的同时，也将样式插入到
html 字符串当中，将结果一同传送到客户端。

isomorphic-style-loader 的原理是什么呢？

我们知道对于 webpack 来说，所有的资源都是模块，webpack loader 在编译过程中可以将导入的 CSS 文件转换成对象，拿到样式信息。因此
isomorphic-style-loader 可以获取页面中所有组件样式。为了实现的更加通用化，isomorphic-style-loader 利用
context API，在渲染页面组件时获取所有 React 组件的样式信息，最终插入到 HTML 字符串中。

在服务端渲染时，我们需要加入这样的逻辑：

    
    
    import express from 'express'
    import React from 'react'
    import ReactDOM from 'react-dom'
    import StyleContext from 'isomorphic-style-loader/StyleContext'
    import App from './App.js'
    
    const server = express()
    const port = process.env.PORT || 3000
    
    // Server-side rendering of the React app
    server.get('*', (req, res, next) => {
    
      const css = new Set() // CSS for all rendered React components
    
      const insertCss = (...styles) => styles.forEach(style => css.add(style._getCss()))
    
      const body = ReactDOM.renderToString(
        <StyleContext.Provider value={{ insertCss }}>
          <App />
        </StyleContext.Provider>
      )
      const html = `<!doctype html>
        <html>
          <head>
            <script src="client.js" defer></script>
            <style>${[...css].join('')}</style>
          </head>
          <body>
            <div id="root">${body}</div>
          </body>
        </html>`
      res.status(200).send(html)
    })
    
    server.listen(port, () => {
      console.log(`Node.js app is running at http://localhost:${port}/`)
    })
    

我们定义了 css Set 类型来存储页面所有的样式，并定义了 insertCss 方法，该方法通过 context 传给每个 React
组件，这样每个组件就可以调用 insertCss 方法。该方法调用时，会将组件样式加入到 css Set 当中。

最后我们用 [...css].join('') 就可以获取页面的所有样式字符串。

强调一下，isomorphic-style-loader 的源码目前已经更新，采用了最新的 React hooks API，我推荐给 React
开发者阅读，相信一定收获很多！

### meta tags 渲染

React 应用中，骨架往往类似：

    
    
    const App = () => {
      return (
        <div>
           <Component1 />
           <Component2 />
        </div>
      )
    }
    ReactDom.render(<App/>, document.querySelector('#root'))
    

App 组件嵌入到 document.querySelector('#root') 节点当中，一般是不包含 head
标签的。但是单页应用在切换路由时，可能也会需要动态修改 head 标签信息，比如 title
内容。也就是说：在单页面应用切换页面，不会经过服务端渲染，但是我们仍然需要更改 document 的 title 内容。

那么服务端如何渲染 meta tags head 标签就是一个常被忽略但是至关重要的话题，我们往往使用 React-helmet 库来解决问题。

Home 组件：

    
    
    import Helmet from "react-helmet";
    
    <div>
        <Helmet>
            <title>Home page</title>
            <meta name="description" content="Home page description" />
        </Helmet>
        <h1>Home component</h1>
    

Users 组件：

    
    
    <Helmet>
        <title>Users page</title>
        <meta name="description" content="Users page description" />
    </Helmet>
    

React-helmet 这个库会在 Home 组件和 Users 组件渲染时，检测到 Helmet，并自动执行副作用逻辑。

### 404 处理

当服务端渲染时，我们还需要留心对 404 的情况进行处理，有 layout.js 文件如下：

    
    
    <Switch>
        <Route path="/" exact component={Home} />
        <Route path="/users" exact component={Users} />
    </Switch>
    

当访问：`/home` 时，会得到一个空白页面，浏览器也没有得到 404 的状态码。为了处理这种情况，我们加入：

    
    
    <Switch>
        <Route path="/" exact component={Home} />
        <Route path="/users" exact component={Users} />
        <Route component={NotFound} />
    </Switch>
    

并创建 NotFound.js 文件：

    
    
    import React from 'react'
    
    export default function NotFound({ staticContext }) {
        if (staticContext) {
            staticContext.notFound = true
        }
        return (
            <div>Not found</div>
        )
    }
    

注意，在访问一个不存在的地址时，我们要返回 404 状态码。一般 React router 类库已经帮我们进行了较好的封装，Static Router
会注入一个 context prop，并将 context.notFound 赋值为 true，在 server/index.js 加入：

    
    
    const context = {}
    const html = renderer(data, req.path, context);
    if (context.notFound) {
        res.status(404)
    }
    res.send(html)
    

即可。这一系列处理过程没有什么难点，但是这种处理意识，还是需要具备的。

### 安全问题

安全问题非常关键，尤其是涉及到服务端渲染，开发者要格外小心。这里提出一个点：我们前面提到了注水和脱水过程，其中的代码：

    
    
    ctx.body = `
      <!DOCTYPE html>
      <html lang="en">
        <head>
          <meta charset="UTF-8">
        </head>
        <body>
            <script>
            window.context = {
              initialState: ${JSON.stringify(store.getState())}
            }
          </script>
          <div id="app">
              // ...
          </div>
        </body>
      </html>
    `
    

非常容易遭受 XSS 攻击，JSON.stringify 可能会造成 script 注入。因此，我们需要严格清洗 JSON 字符串中的 HTML
标签和其他危险的字符。我习惯使用 serialize-javascript 库进行处理，这也是同构应用中最容易被忽视的细节。

这里给大家留一个思考题，React dangerouslySetInnerHTML API 也有类似风险，React 是怎么处理这个安全隐患的呢？

### 性能优化

我们将数据请求移到了服务端，但是依然要格外重视性能优化。目前针对于此，业界普遍做法包括以下几点。

  * 使用缓存：服务端优化一个最重要的手段就是缓存，不同于传统服务端缓存措施，我们甚至可以实现组件级缓存，业界 walmartlabs 在这方面的实践非常多，且收获了较大的性能提升。感兴趣的读者可以找到相关技术信息。
  * 采用 HSF 代替 HTTP，HSF 是 High-Speed Service Framework 的缩写，译为分布式的远程服务调用框架，对外提供服务上，HSF 性能远超过 HTTP。
  * 对于服务端压力过大的场景，动态切换为客户端渲染。
  * NodeJS 升级。
  * React 升级。

如图所示，React 16 在服务端渲染上的性能对比提升：

![enter image description
here](https://images.gitbook.cn/62d9e840-9ee8-11e9-ac5c-d5048fafc34b)

> 备注：图片来自 [hacker noon](https://hackernoon.com/whats-new-with-server-side-
rendering-in-react-16-9b0d78585d67)

### 总结

本讲没有“手把手”教你实现服务端渲染的同构应用，因为这些知识并不困难，社区上资料也很多。我们从更高的角度出发，剖析同构应用中那些关键的细节点和疑难问题的解决方案，这些经验来源于真刀真枪的线上案例，如果读者没有开发过同构应用，也能从中全方位地了解关键信息，一旦掌握了这些细节，同构应用的实现就会更稳、更可靠。

同构应用其实远比理论复杂，绝对不是几个 APIs 和几台服务器就能完成的，希望大家多思考、多动手，一定会更有体会。

另外，同构应用各种细节也不止于此，坑也不止于此，欢迎大家和我讨论。

### 分享交流

阅读文章过程中有任何疑问可随时跟其他小伙伴讨论，或者直接向作者 LucasHC 提问（作者看到后抽空回复）。 **你的分享不仅帮助他人，更会提升自己。**

你也可以说说自己最想了解的主题，课程内容会根据部分读者的意见和建议迭代和完善。

此外，我们为本课程付费读者创建了《前端开发核心知识进阶》微信交流群，以方便更有针对性地讨论课程相关问题（入群请到第1-2课末尾添加 GitChat
小助手伽利略的微信，并注明「前端核心」，谢谢~）



## 从框架和类库，我们该学到什么

我记得作为实习生时，第一个独立前端项目是为欧洲天然气石油系统做一个计费应用：在地图上，用户可以和地图交互，从欧亚大陆任何一个石油气点为起点，到任何一个石油气点作为终点，计算出沿途所有的路径运输方案以及计费详情，还要支持各种终端的查询以及打印，这是一个纯
JavaScript 单页面应用 + Severless 的项目。

实习期满离职前我进行复盘：繁多的原生 JavaScript APIs 让我无语，兼容性让我崩溃，“如果我一开始就选用 jQuery 做该多好！” ，too
young too simple。这时候再让我复盘，“jQuery 也不适用那样一个单页应用，我为什么不用 React 或者 Vue？”果然
sometimes naive。

前端框架确实一直在演进、发展，那么框架除了简化我们的操作外，我们还能从中学到什么？这一讲，我就对这个开放性话题进行展开。本节课内容比较轻松，没有大量的代码案例，让我们来舒缓一下，但请读者在阅读时始终思考——“从框架和类库，我们该学到什么”这一问题。

Vue 和 React 加其生态方案使得 Vue 和 React 不再是单纯的视图层类库，因此下面我们将 Vue 和 React
统称“框架”，表示其全家桶。

相关知识点如下：

![](https://images.gitbook.cn/60120df0-a383-11e9-95a5-cd4900ba781e)

### React VS Vue：神仙打架

React 和 Vue 这两个极其优秀的前端“框架”基本上占据了前端开发的半壁江山甚至更多。作为开发者，你可以首选 React 或者 Vue
其中一个，但是如若尝试将两者进行对比，那么一定会收获很多。

这里我们将从以下五大方面进行比较：

  * 数据绑定
  * 组件化和数据流
  * 数据状态管理
  * 渲染和更新
  * 社区

#### 数据绑定

Vue 在数据绑定上，采取了双向绑定策略，依靠 Object.defineProperty （Vue 3.0 已迁移到 Proxy）以及监听 DOM
事件实现。具体实现方法在先前课程中我们已经剖析过了，简单来说数据改变，依赖对数据进行拦截 / 代理；视图改变，依赖 DOM 事件（如
onInput、onChange 等）。Vue 实例中的 data 和 模版展现是一条线，无论谁被修改，另一方也会发生变动。

值得一提的是 Vue 也支持计算属性，即 computed 属性，这个策略和 React-redux 当中的 mapStateToProps
有异曲同工之妙，都是通过计算，将所需要的数据注入给组件使用。

需要区分清楚的是：双向绑定和单向数据流并没有直接关联，双向绑定是指数据和视图之间的绑定关系，而单向数据流是指组件之间数据的传递。

React
并没有数据和视图之间的双向绑定，它的策略是“局部刷新”。当数据发生变化时，直接重新渲染组件，以得到最新的视图。这种“无脑”刷新的做法看似粗暴，但是换来的简单直观，并且
React 本身在性能上也提供了一定保障。

#### 组件化和数据流

Vue 中组件不像 React 组件，它不是完全以组件功能和 UI 为维度划分的，而 Vue 组件本质是一个 Vue 实例。每个 Vue
实例在创建时都需要经过：设置数据监听、编译模版、应用模版到 DOM，在更新时根据数据变化更新 DOM 的过程。在这个过程中，类似 React
也提供了生命周期方法。

Vue 组件间通信或者说组件间数据流如同 React，也是单向的。数据流向也很类似：props 实现父组件向下传递数据，events
实现子组件向上发送消息给父组件，React 中是基于 props 的回调实现子组件向父组件传递数据（Vue 也支持）。

当然，这两种框架也分别通过 context 和 provide/inject 实现了跨层级数据通信，它们的实现也是非常类似的。

#### 数据状态管理

对于较为复杂的数据状态，Redux 是 React 应用最常用的解决方案。这里需要说明的是：Redux 和视图无关，它只是提供了数据管理的流程，因此 Vue
使用 Redux 也是完全没有问题的。

当然，Vue 中更常用的是 Vuex，其借鉴了 Redux（Flux），也具有和 Redux 相同的 store 概念，组件不允许直接修改 store
state，而是需要 dispatch action 来通知 store 的变化。但是这个过程不同于 Redux 的函数式思想，Vuex 改变 store
的方法支持提交一个 mutation。mutation 类似于事件发布订阅系统：每个 mutation
都有一个字符串来表示事件类型（type）和一个回调函数（handler）以进行对应的修改。

另一个显著区别是：在 Vuex 中，store 是被直接注入到组件实例中的，因此用起来更加方便。而 Redux 需要 connect 方法，把 props
和 dispatch 注入给组件。

**造成这些不同的本质原因是：**

  * Redux 提倡不可变性，而 Vuex 的数据是可变的，Redux 中 reducer 每次都会生成新的 state 以替代旧的 state，而 Vuex 是直接修改；
  * Redux 在检测数据变化的时候，是通过浅比较的方式比较差异的，而 Vuex 其实和 Vue 的原理一样，是通过遍历数据的 getter / setter 来比较。

#### 渲染和更新

就像上面所提到的，React 和 Redux 倡导不可变性，更新需要维持不可变原则；而 Vue
对数据进行了拦截/代理，因此它不要求不可变性，而允许开发者修改数据，以引起响应式更新。

React 更像 MVC 或者 MVVM 模式中的 view 层，但是搭配 Redux 等，它也是一个完整的 MVVM 类库。Vue 直接是一个典型
MVVM 模式的体现，虽然它一直标榜自己也只是 View 层，但是毫无疑问它本身包含了对数据的操作。比如，Vue 文档中经常会使用 VM（ViewModel
简称），这个变量名表示 Vue 实例，其命名让人想到 MVVM，这是 MVVM 模式的体现。

React 所有组件的渲染都依靠灵活而强大的 JSX。JSX 并不是一种模版语言，而是 JavaScript 表达式和函数调用的语法糖。在编译之后，JSX
被转化为普通的 JavaScript 对象，用来表示虚拟 DOM。

Vue templates 是典型的模版，这相比于 JSX，表达更加自然。在底层实现上，Vue 模版被编译成 DOM
渲染函数，结合响应系统，进行数据依赖的收集。Vue 渲染的过程如下：

  * new Vue，进行实例化
  * 挂载 $mount 方法，通过自定义 Render 方法、template、el 等生成 Render 函数，准备渲染内容
  * 通过 Watcher 进行依赖收集
  * 当数据发生变化时，Render 函数执行生成 VNode 对象
  * 通过 patch 方法，对比新旧 VNode 对象，通过 DOM Diff 算法，添加、修改、删除真正的 DOM 元素

当然 Vue 也可以支持 JSX。

关于更新性能问题，简单来说，在 React 应用中，当某个组件的状态发生变化时，它会以该组件为根，重新渲染整个组件子树。当然我们可以使用
PureComponent，或是手动实现 shouldComponentUpdate
方法，来规避不必要的渲染。但是这个实现过程要知悉数据状态结构，也需要一定的额外负担。

在 Vue 应用中，组件的依赖是在渲染过程中自动追踪的，因此系统能精确知晓哪个组件需要被重渲染。从理论上看，Vue 的渲染更新机制更加细粒度，也更加精确。

#### 社区

这两个框架都具有非常强大的社区，但是对于社区的理念，Vue 和 React 稍有不同。举个例子：路由系统的实现。

Vue 的路由库和状态管理库都是由官方维护的，并且与核心库是同步更新的。而 React 把这件事情交给了社区，比如 React 应用中，需要引入
react-router 库来实现路由系统。

### 新版本发布的思考

我一直认为开发者可以从框架新版本的迭代 changelog 里汲取非常多的养分。因为每次发版，都是经过开源框架的维护团队精心设计的，更新点或涉及 bug
fix 或涉及新的 features，我们便可以思考“为什么会有这些变动”?，“为什么这样解决 bug”?

除此之外，我还建议开发者从更高的层次“开启上帝视角”，抓着某一话题，某一次变更进行研究、学习。这里我就举个例子：Vue3.0 带来的一些思考。

本讲在编写之时，恰逢尤雨溪在上海 Vue Conf 进行分享，演讲主题：State of Vue，其中涉及到新版本发布。从这次新版本发布对 Vue
的改动，结合我们的课程，我能找到很多切入点进行分析，比如虚拟 DOM、Proxy 实现数据代理。

其中尤雨溪表示 Vue3.0 相比以往版本更加快速。那么“更加迅速”是如何做到更快的呢？我们在《第 4-1 课：触类旁通多种框架》一课中对比过
Object.defineProperty 和 Proxy 实现的数据拦截和代理。那么在 Vue3.0，Vue 团队就是用 Proxy 来代替
Object.defineProperty，达到了更好的性能保障。

除此之外，Vue 新版本还重构了虚拟 DOM，正好在《第 4-1 课：触类旁通多种框架》一课中也简单实现了一个粗糙的虚拟 DOM，我们可以展开谈谈：传统虚拟
DOM 的性能瓶颈在于虚拟 DOM 的 diff，也许某次更新只有一个很小的变动，但还是需要对比整棵虚拟 DOM 树，这显然是非常不划算的。

Vue 新版本将虚拟 DOM 的节点分为动态节点和静态节点。静态节点是指不会发生改变的节点，这些节点在进行 diff
时是应该进行规避的，而我们只需要对比动态节点。

比如这样的内容：

    
    
    <template>
        <div>
            <div id="1">
                <p> 前端进阶 </p>
                <p> 前端进阶 </p>
                <p> 前端进阶 </p>
                <p> {{data.foo}} </p>
                <p> 前端进阶 </p>
                <p> 前端进阶 </p>
            </div>
        </div>
    </template>
    

最理想的情况是只需要对比可能会发生变化的 p 标签。再看这种情况：

    
    
    <template>
        <div>
            前端进阶
        </div>
        <div v-if="XXX">
            <span>前端进阶</span>
            <span>{{data.foo}}</span>
        </div>
    </template>
    

最理想的情况是只需要对比 `<div v-if="XXX">` 以及 `<span>{{data.foo}}</span>`，因为前者可能会根据判断条件消失
/ 出现，后者直接取决于模版变量的值，都属于动态节点。

这样一来，我们便可以根据模版，将动态节点切割为区块，在进行 diff 操作时，递归进行区块中的动态节点比对即可。因此， **新的 diff
策略更新性能不再取决于模版整体节点数量的多少，而和动态内容的数量正相关。**

当然，这次 Vue 新版本的发布还有很多有意思的点，将其和 React 相比，和 React hooks 相比也非常有趣。这里不再展开。

### 从框架再谈基础

这一环节我们不需要详细展开，每一个开发者都应该认识到基础的重要性。从框架上来看，如果基础薄弱，你可能就不会明白为什么：

  * “React 事件处理函数还需要手动绑定 this”，“而 React 生命周期函数中却不需要手动绑定 this”
  * “为什么 Vue 可以实现双向绑定”等问题。

研究框架也不一定非要等到基础很扎实的时候。因为我们在学习框架之时，也是对自己基础查漏补缺的很好时机。

### 总结

这一讲比较轻松，我们重点分析了框架对比、框架发展。从中每一个开发者都应该能体会到“从框架和类库，我们该学到什么”。也许通过这种形式，我们不仅能够从更高层面理解框架，更能对框架的学习、今后的学习有所启发。

到此，框架大章节到此结束了，我们调整一下心情，进入下一大章节的学习。

### 分享交流

阅读文章过程中有任何疑问可随时跟其他小伙伴讨论，或者直接向作者 LucasHC 提问（作者看到后抽空回复）。 **你的分享不仅帮助他人，更会提升自己。**

你也可以说说自己最想了解的主题，课程内容会根据部分读者的意见和建议迭代和完善。

此外，我们为本课程付费读者创建了《前端开发核心知识进阶》微信交流群，以方便更有针对性地讨论课程相关问题（入群请到第1-2课末尾添加 GitChat
小助手伽利略的微信，并注明「前端核心」，谢谢~）



## 深入浅出模块化（含 tree shaking）（上）

 **模块化是工程化的基础** ：只有能将代码模块化，拆分为合理单元，才具备调度整合的能力，才有架构和工程一说。早期，JavaScript
只是作为浏览器端脚本语言出现，只负责简单的页面交互，并不具备先天的模块化能力。

随着 Node.js 的发展和 ES
的演进，模块化如今在前端领域早已经不新鲜。但是，对于模块化我们不应该只停留在了解、会用的基础上，还要深入其中，认识在这个演进过程中：

  * 模块化经历了怎样的发展历程，从中我们能学习到哪些知识？
  * 跟其他早已发展成熟的语言相比，JavaScript 语言的模块化又有哪些特点？
  * 新的模块化 feature 又有哪些？dynamic import 现在停留在哪个阶段？

让我们通过本节课程达成这一目标。 **不同于社区上常见的文章，我们并不会把焦点放在介绍各种模块化方案的使用方法上，而是直接剖析其实现，分析标准的制定。**

这个主题的知识点如下：

![](https://images.gitbook.cn/863babe0-4edc-11e9-8044-3de24c2bc492)

**接下来，我们通过 2 节内容来学习这个主题。**

###  模块化简单概念

到底什么是模块化？简单来说就是：
**对于一个复杂的应用程序，与其将所有代码一股脑地放在一个文件当中，不如按照一定的语法，遵循确定的规则（规范）拆分成几个互相独立的文件。这些文件应该具有原子特性，也就是说，其内部完成共同的或者类似的逻辑，通过对外暴露一些数据或调用方法，与外部完成整合。**

这样一来，每个文件彼此独立，开发者更容易开发和维护代码，模块之间又能够互相调用和通信，这是现代化开发的基本模式。

其实，不论在我们的日常生活还是其他科学领域，都离不开模块化的概念，它主要体现了以下原则：

  * 可复用性
  * 可组合型
  * 中心化
  * 独立性

**在模块化的基础上，结合工程化，又可以衍生出很多概念和话题。比如基于模块化的 tree shaking
技术，模块循环加载的处理等。不过不要着急，我们先来看看前端模块化的发展历程。**

###  模块化发展历程

我认为前端模块化发展主要经历了三个阶段：

  * 早期“假”模块化时代
  * 规范标准时代
  * ES 原生时代

**这些阶段逐次递进，每一种新方案的诞生，都离不开老方案的启示。**

#### 早期“假”模块化时代

在早期，JavaScript
属于运行在浏览器端的玩具脚本，它只负责实现一些简单的交互。随着互联网技术的演进，这样的设计逐渐不能满足业务的需求。这时候开发者往往从代码可读性上，借助函数作用域来模拟实现“假”的模块化，我称其为
**函数模式** ，即将不同功能封装成不同的函数：

    
    
    function f1(){
        //...
    }
    function f2(){
        //...
    }
    

这样的方式其实根本不算模块化，各个函数在同一个文件中，混乱地互相调用，而且存在命名冲突的风险。这没有在根本上解决问题，只是从代码编写的角度，拆分成了更小的函数单元而已。

于是，聪明的开发者很快就想出了第二种方式，姑且称它为 **对象模式** ，即利用对象，实现命名空间的概念：

    
    
    const module1 = {
        foo: 'bar',
        f11: function f11 () { //... },
        f12: function f12 () { //... },
    }
    
    const module2 = {
        data: 'data',
        f21: function f21 () { //... },
        f22: function f22 () { //... },
    }
    

这样我们模拟了简单的 module1、module2 命名空间，在函数主体中可以调用：

    
    
    module1.f11()
    console.log(module2.data)
    

可是这样问题也很明显，module1 和 module2 中的数据并不安全，任何开发者都可以修改：

    
    
    module2.data = 'modified data'
    

对象内部成员可以随意被改写，极易出现 bug。那么有什么手段能弥补这个不足呢？

想一想之前关于闭包的课程，从某种角度上看，闭包简直就是一个天生解决数据访问性问题的方案。通过立即执行函数（IIFE），我们构造一个私有的作用域，再通过闭包，将需要对外暴露的数据和接口输出，我们称此为
**IIFE 模式** 。立即执行函数结合闭包实现的代码如下：

    
    
    const module = (function(){
        var foo = 'bar'
        var fn1 = function (){
            // ...
        }
        var fn2 = function fn2(){
            // ...
        }
        return {
            fn1: fn1,
            fn2: fn2
        }
    })()
    

我们在调用时：

    
    
    module.fn1()
    

如果想要访问变量 foo：

    
    
    module.foo
    // undefined
    

是访问不到具体数据的。 ​  
了解了这种模式，我们可以在此基础上“玩出另外一个花”来，该方式的变种：结合顶层 window 对象，我们再来看：

    
    
    (function(window) {
        var data = 'data'
    
        function foo() {
            console.log(`foo executing, data is ${data}`)
        }
        function bar() {
            data = 'modified data'
            console.log(`bar executing, data is now ${data} `)
        }
        window.module1 = { foo, bar }
    })(window)
    

这样的实现，数据 data 完全做到了私有，外界无法修改 data 值。那么如何访问 data
呢？这时候需要模块内部设计并暴露相关接口。上述代码中，只需要调用模块 module1 暴露给外界（window）的函数即可:

    
    
    module1.foo()
    // foo executing, data is data
    

修改 data 值的途径，也只能由模块 module1 提供：

    
    
    module1.bar()
    // bar executing, data is now modified data 
    

如此一来，已经初具“模块化”的实质，实现了模块化所应该具备的初级功能。

我们再进一步思考，如果 module1 依赖外部模块 module2，该怎么办？请参考代码：

    
    
    (function(window, $) {
        var data = 'data'
    
        function foo() {
            console.log(`foo executing, data is ${data}`)
            console.log($)
        }
        function bar() {
            data = 'modified data'
            console.log(`bar executing, data is now ${data} `)
        }
        window.module1 = { foo, bar }
    })(window, jQuery)
    

**事实上，这就是现代模块化方案的基石。到此为止，我们经历了模块化的第一阶段：“假”模块化时代。** 这种实现极具阿 Q
精神，它并不是语言原生层面上的实现，而是开发者利用语言，借助 JavaScript 特性，模拟了类似的功能，为后续方案打开了大门。请继续阅读。

#### 规范标准时代 CommonJS

Node.js 无疑对前端的发展具有极大的促进作用，它带来的 CommonJS 模块化规范像一股“改革春风”：在 Node.js
中，每一个文件就是一个模块，具有单独的作用域，对其他文件是不可见的。关于 CommonJS
的规范，我们这里不做过多介绍，基础内容读者可自行理解，我们只来看看它的 **几个容易被忽略的特点。**

  * 文件即模块，文件内所有代码都运行在独立的作用域，因此不会污染全局空间。
  * 模块可以被多次引用、加载。在第一次被加载时， **会被缓存** ，之后都从缓存中直接读取结果。
  * 加载某个模块，就是引入该模块的 module.exports 属性。
  * module.exports 属性 **输出的是值的拷贝** ，一旦这个值被输出，模块内再发生变化不会影响到输出的值。
  * 模块加载顺序按照代码引入的顺序。
  * 注意 module.exports 和 exports 的区别

CommonJS 规范用代码如何在浏览器端实现呢？其实就是实现 module.exports 和 require 方法。

实现思路：根据 require 的文件路径，加载文件内容并执行，同时将对外接口进行缓存。因此我们需要定义：

    
    
    let module = {}
    module.exports = {}
    

借助立即执行函数，将 module 和 module.exports 对象进行赋值：

    
    
    (function(module, exports) {
        // ...  
    }(module, module.exports))
    

社区上对 CommonJS
实现的模拟很多，这里我不在浪费笔墨重复，给大家推荐[浅谈前端模块化](https://juejin.im/post/5c1619b8e51d4530e8357c86)，以及
[browserify](https://github.com/browserify/browserify)。

#### 规范标准时代 AMD

由于 Node.js 运行于服务器上，所有的文件一般都已经存在了本地硬盘中，不需要额外的网络请求去异步加载，因而 CommonJS
规范加载模块是同步的。只有加载完成，才执行后续操作。但是，如果放在浏览器环境中，我们都需要从服务器端获取模块文件，此时再采用同步的方式，显然就不合适了。这时候，社区上推出了
AMD 规范。

AMD 规范，全称为：Asynchronous Module Definition，看到 “Asynchronous”，我们就能够反映到它的模块化标准不同于
CommonJS，是异步的，完全贴合浏览器的。

它规定了如何定义模块，如何对外输出，如何引入依赖。这一切都需要代码去实现，因此一个著名的库 —— require.js 应运而生，require.js
实现很简单：通过 define 方法，将代码定义为模块；通过 require 方法，实现代码的模块加载。

define 和 require 就是 require.js 在全局注入的函数。

在熟练使用的基础上，建议读者参考 [require.js 源码](https://github.com/requirejs/requirejs)。

    
    
    var require, define;
    (function (global, setTimeout) {
        // ...
    }(this, (typeof setTimeout === 'undefined' ? undefined : setTimeout)));
    

我们看到，require.js 在全局定义了 require 和 define 两个方法，也是利用立即执行函数，将全局对象（this）和
setTimeout 传入函数体内。其中：

    
    
    define = function (name, deps, callback) {
        // ...
        if (context) {
            context.defQueue.push([name, deps, callback]);
            context.defQueueMap[name] = true;
        } else {
            globalDefQueue.push([name, deps, callback]);
        }
    }
    

这里主要是将依赖注入到依赖队列。而 require 的主要作用是完成创建 script 标签去请求相应的模块，对模块进行加载和执行：

    
    
    req.load = function (context, moduleName, url) {
        var config = (context && context.config) || {},
        node;
        if (isBrowser) {
            //create a async script element
            node = req.createNode(config, moduleName, url);
    
            //add Events [onreadystatechange,load,error]
            .....
    
            //set url for loading
            node.src = url;
    
            //insert script element to head and start load
            currentlyAddingScript = node;
            if (baseElement) {
                head.insertBefore(node, baseElement);
            } else {
                head.appendChild(node);
            }
            currentlyAddingScript = null;
    
            return node;
        } else if (isWebWorker) {
            .........
        }
    };
    
    req.createNode = function (config, moduleName, url) {
        var node = config.xhtml ?
            document.createElementNS('http://www.w3.org/1999/xhtml', 'html:script') :
            document.createElement('script');
        node.type = config.scriptType || 'text/javascript';
        node.charset = 'utf-8';
        node.async = true;
        return node;
    };
    

细心的读者可能会有疑问：在我们使用 require.js 之后，并没有发现额外多出来的 script 标签，这个秘密就在于 checkLoaded
方法会把已经加载完毕的脚本删除，因为我们需要的是模块内容，一旦加载之后，没有必要保留有 script 标签了：

    
    
    function removeScript(name) {
        if (isBrowser) {
            each(scripts(), function (scriptNode) {
                if (scriptNode.getAttribute('data-requiremodule') === name &&
                        scriptNode.getAttribute('data-requirecontext') === context.contextName) {
                    scriptNode.parentNode.removeChild(scriptNode);
                    return true;
                }
            });
        }
    }
    

更多源码内容，感兴趣的读者可以在评论区讨论交流，或者直接向我提问。

#### 规范标准时代 CMD

CMD 规范整合了 CommonJS 和 AMD 规范的特点。它的全称为：Common Module Definition，类似
require.js，CMD 规范的实现为 sea.js。

AMD 和 CMD 的两个主要区别如下。

  * AMD 需要异步加载模块，而 CMD 在 require 依赖的时候，可以通过同步的形式（require），也可以通过异步的形式（require.async）。
  * CMD 遵循依赖就近原则，AMD 遵循依赖前置原则。也就是说，在 AMD 中，我们需要把模块所需要的依赖都提前在依赖数组中声明。而在 CMD 中，我们只需要在具体代码逻辑内，使用依赖前，把依赖的模块 require 进来。

具体到代码实现，sea.js 与 require.js 并没有本质差别，这里不再另做分析。

#### 规范标准时代 UMD

UMD 全称：Universal Module Definition，看到 “Universal”，我们可以猜到它允许在环境中同时使用 AMD 与
CommonJS 规范，相当于一个整合。该模式的 **核心思想** 在于利用立即执行函数根据环境来判断需要的参数类别，譬如在 CommonJS
环境下，上述代码会以如下方式执行：

    
    
    function (factory) {
        module.exports = factory();
    } 
    

而如果是在 AMD 模块规范下，函数的参数就变成了 define，适用 AMD 规范。

具体代码：

    
    
    (function (root, factory) {
        if (typeof define === 'function' && define.amd) {
            // AMD 规范
            define(['b'], factory);
        } else if (typeof module === 'object' && module.exports) {
            // 类 Node 环境，并不支持完全严格的 CommonJS 规范
            // 但是属于 CommonJS-like 环境，支持 module.exports 用法
            module.exports = factory(require('b'));
        } else {
            // 浏览器环境
            root.returnExports = factory(root.b);
        }
    }(this, function (b) {
        // 返回值作为 export 内容
        return {};
    }));
    

至此，我们介绍完了模块化的 Node.js 和社区解决方案。这些方案充分利用了 JavaScript
语言特性，并结合浏览器端的特点，加以实现。不同的实现方式体现了不同的设计哲学，但是它们的最终方向都指向了模块化的几个原则：可复用性、可组合型、中心化、独立性，下一节我们继续这个主题，介绍模块化的原生解决方案。

### 分享交流

阅读文章过程中有任何疑问可随时跟其他小伙伴讨论，或者直接向作者 LucasHC 提问（作者看到后抽空回复）。 **你的分享不仅帮助他人，更会提升自己。**

你也可以说说自己最想了解的主题，课程内容会根据部分读者的意见和建议迭代和完善。

此外，我们为本课程付费读者创建了《前端开发核心知识进阶》微信交流群，以方便更有针对性地讨论课程相关问题（入群请到第1-2课末尾添加 GitChat
小助手伽利略的微信，并注明「前端核心」，谢谢~）



## 深入浅出模块化（含 tree shaking）（下）

本节课程，让我们继续模块化的话题。在此之前，先来回顾一下这个主题的知识点：

![](https://images.gitbook.cn/863babe0-4edc-11e9-8044-3de24c2bc492)

### 模块化发展历程

在上一讲中，介绍了以下方案实现模块化：

  * 早期命名空间模拟模块化
  * CommonJS
  * AMD
  * CMD
  * UMD

接下来我们来探讨 ES 原生模块化的知识，并就 tree shaking 这个话题展开。

#### ES 原生时代和 tree shaking

ES 模块化（或称为 ESM）的具体使用方法我们不再具体介绍，请读者先了解相关基础内容。

ES 模块的设计思想是尽量 **静态化** ，这样能保证在编译时就确定模块之间的依赖关系，每个模块的输入和输出变量也都是确定的。CommonJS 和 AMD
模块，无法保证前置即确定这些内容，只能在运行时确定。这是 ES 模块化和其他规范的显著不同。第二个差别在于，CommonJS 模块输出的是一个值的
**拷贝** ，ES 模块输出的是值的 **引用** 。我们来具体看一下：

    
    
    // data.js
    export let data = 'data'
    export function modifyData() {
        data = 'modified data'
    }
    
    // index.js
    import { data, modifyData } from './lib'
    console.log(data) // data
    modifyData()
    console.log(data) // modified data
    

我们在 index.js 中调用了 modifyData 方法，之后查询 data 值，得到了最新的变化。

而同样的逻辑，在 CommonJS 规范下的表现为：

    
    
    // data.js
    var data = 'data'
    function modifyData() {
        data = 'modified data'
    }
    
    module.exports = {
        data: data,
        modifyData: modifyData
    }
    
    // index.js
    var data = require('./data').data
    var modifyData = require('./data').modifyData
    console.log(data) // data
    modifyData()
    console.log(data) // data
    

因为 CommonJS 是输出了值的拷贝，而非引用，因此在调用 modifyData 之后，index.js 的 data
值并没有发生变化，其值为一个全新的拷贝。

##### **ES 模块化为什么要设计成静态的**

一个明显的优势是：通过静态分析，我们能够分析出导入的依赖。如果导入的模块没有被使用，我们便可以通过 tree shaking
等手段减少代码体积，进而提升运行性能。这就是基于 ESM 实现 tree shaking 的基础。

这么说可能过于笼统，我们从设计的角度分析这两种规范哲学的利弊。静态性需要规范去强制保证，不像 CommonJS 那样灵活，ES 模块化的静态性带来了限制：

  * 只能在文件顶部 import 依赖
  * export 导出的变量类型严格限制
  * 变量不允许被重新绑定，import 的模块名只能是字符串常量，即不可以动态确定依赖

这样的限制在语言层面带来的便利之一是：我们可以通过作用域分析，分析出代码里变量所属的作用域以及它们之间的引用关系，进而可以推导出变量和导入依赖变量的引用关系，在没有明显引用时，就可以进行去冗余。

##### **tree shaking**

上面说到的“在没有明显引用时，就可以进行去冗余”，就是我们经常提到的 **tree shaking** ，它的目的就是减少应用中写出，但没有被实际运用的
JavaScript 代码。这样一来，无用代码的清除，意味着更小的代码体积，bundle size 的缩减，对用户体验起到了积极作用。

在计算机科学当中，一个典型去除无用代码、冗余代码的手段是
[DCE](https://en.wikipedia.org/wiki/Dead_code_elimination)，dead code
elimination。 **那么 tree shaking 和 DCE（Dead Code Elemination）有什么区别？**

> Rollup 的主要贡献者 Rich Harris
做过这样的比喻：假设我们用鸡蛋做蛋糕。显然，我们不需要蛋壳而只需要蛋清和蛋黄，那么如何去除蛋壳呢？DCE
是这样做的：直接把整个鸡蛋放到碗里搅拌，蛋糕做完后再慢慢地从里面挑出蛋壳

相反，与 DCE 不同，tree shaking 是开始阶段就把蛋壳剥离，留下蛋清和蛋黄。事实上，也可以将 tree shaking 理解为广义 DCE
的一种，它在前置打包时即排除掉不会用到的代码。

当然说到底，tree shaking 只是一种辅助手段，良好的模块拆分和设计才是减少代码体积的关键。

Tree shaking 也有局限性，它还有很多不能清除无用代码的场景，比如 Rollup 的 tree shaking 实现只处理函数和顶层的
`import/export` 导入的变量，不能把没用到的类的方法消除；对于 tree shaking 来说，具有副作用的脚本无法被优化。

更多情况读者可以参考：

  * [tree-shaking 不完全指南](https://juejin.im/post/5a64724df265da3e5a575d65)
  * [webpack-common-shake](https://github.com/indutny/webpack-common-shake#limitations)
  * [你的 Tree-Shaking 并没什么卵用](https://juejin.im/post/5a5652d8f265da3e497ff3de)
  * [Webpack Tree shaking 深入探究](https://juejin.im/post/5bb8ef58f265da0a972e3434)

##### **tree shaking 使用注意事项**

webpack 和 Rollup 构建工具目前都有成熟的方案，但是笔者并不建议马上引入到项目中。事实上，是否要在成熟的项目上立即实施 tree
shaking 需要妥善考虑。这里我也提供几篇收藏的文章，介绍了 tree shaking
的使用方法，这些基本操作内容，我们不再展开，可以按照官方文档实施，我也在文档之外推荐这些内容供大家学习。

  * [Webpack 之 treeShaking](https://mp.weixin.qq.com/s/Y4v7tAWUeDNs_FWpUnKmAw)
  * [体积减少80%！释放 webpack tree-shaking 的真正潜力](https://juejin.im/post/5b8ce49df265da438151b468)
  * [Tree-Shaking 性能优化实践 - 原理篇](https://juejin.im/post/5a4dc842518825698e7279a9)

##### ES 的 export 和 export default

ES 模块化导出有 export 和 export default 两种。这里我们建议减少使用 export default 导出，原因是一方面
export default 导出整体对象结果，不利于 tree shaking 进行分析；另一方面，export default
导出的结果可以随意命名变量，不利于团队统一管理。

Nicholas C. Zakas 有一篇文章： [Why I've stopped exporting defaults from my
JavaScript
modules](https://link.juejin.im/?target=https%3A%2F%2Fhumanwhocodes.com%2Fblog%2F2019%2F01%2Fstop-
using-default-exports-javascript-module%2F) ，表达了类似的观点。

### 未来趋势和思考

个人认为，ES 模块化是未来不可避免的发展趋势，它的优点毫无争议，比如开箱即用的 tree shaking 和未来浏览器兼容性支持。Node.js 的
CommonJS 模块化方案甚至也会慢慢过渡到 ES 模块化上。如果你正在使用 webpack 构建应用项目，那么 ES
模块化是首选；如果你的项目是一个前端库，也建议使用 ES 模块化。这么看来，或许只有在编写 Node.js 程序时，才需要考虑 CommonJS。

#### 在浏览器中快速使用 ES 模块化

目前各大浏览器较新版本都已经开始逐步支持 ES 模块了。如果我们想在浏览器中使用原生 ES 模块方案，只需要在 script 标签上添加一个
type="module" 属性。通过该属性，浏览器知道这个文件是以模块化的方式运行的。而对于不支持的浏览器，需要通过 nomodule 属性来指定某脚本为
fallback 方案：

    
    
    <script type="module">
        import module1 from './module1'
    </script>
    <script nomodule>
         alert('你的浏览器不支持 ES 模块，请先升级！')
    </script>
    

使用 type="module" 的另一个作用是进行 ES Next 兼容性的嗅探。因为支持 ES 模块化的浏览器，都支持 ES Promise
等特性，基于此，应用场景较多。

#### 在 Node.js 中使用 ES 模块化

Node.js 从 9.0 版本开始支持 ES 模块，执行脚本需要启动时加上 --experimental-
modules，不过这一用法要求相应的文件后缀名必须为 *.mjs：

    
    
    node --experimental-modules module1.mjs
    import module1 from './module1.mjs'
    console.log(module1)
    

另外，也可以安装 babel-cli 和 babel-preset-env，配置 .babelrc 文件后，执行：

    
    
    ./node_modules/.bin/babel-node 
    

或：

    
    
    npx babel-node 
    

在工具方面，webpack 本身维护了一套模块系统，这套模块系统兼容了几乎所有前端历史进程下的模块规范，包括 AMD/CommonJS/ES
模块化等，具体分析咱们见后续课程《webpack 工程师 > 前端工程师》（即下一讲的内容）。

### 总结

通过本课程的学习，我们了解了 JavaScript 模块化的历史，重点分析了不同过渡方案的不同实现以及 ES
模块化标准的细节。希望读者对模块系统有一个更清晰的认识，同时希望大家可以仔细阅读源码，对代码设计有自己的理解和体会。

### 分享交流

在「模块化」相关话题上你有什么感悟？留言分享给一起学习的小伙伴吧！阅读文章过程中有任何疑问随时可以跟其他小伙伴讨论，或者直接向作者 LucasHC
提问（作者看到后抽空解答）。 **你的分享不仅帮助他人，更会提升自己。**

你也可以说说自己最想了解的主题，课程内容会根据部分读者的意见和建议迭代和完善。

此外，我们为本课程付费读者创建了《前端开发核心知识进阶》微信交流群，以方便更有针对性地讨论课程相关问题。（入群请到第1-2课末尾扫描二维码，若失效请加
GitChat 小助手伽利略的微信，ID 为 GitChatty6，注明「前端核心」。）



## webpack 工程师和前端工程师（上）

说起前端工程化， webpack 必然在前端工具链中占有最重要的地位；说起前端工程师进阶，webpack 更是一个绕不开的话题。

从原始的刀耕火种时代，到 Gulp、Grunt 等早期方案的横空出世，再到 webpack
通过其丰富的功能和开放的设计一举奠定“江湖地位”，我想每个前端工程师都需要熟悉各个时代的“打包神器”。

作为团队中不可或缺的高级工程师，能否玩转
webpack，能否通过工具搭建令人舒适的工作流和构建基础，能否不断适应技术发展打磨编译体系，将直接决定你的工作价值。

在这一系列课程里，赘述社区上大量存在的“webpack 配置 demo”，或者讲解一些现成的插件应用意义不大，这些知识都可以免费找到。

**分析 webpack 工作原理，探究 webpack 能力边界，结合实践并加以应用** 将会是本讲的重点。

webpack 主题的知识点如下所示：

![](https://images.gitbook.cn/e13b8fb0-4ecd-11e9-97d1-9b2c5e38f63d)

接下来，我们通过 2 节内容来学习这个主题。

### webpack 到底将代码编译成了什么

**项目中经过 webpack 打包后的代码究竟被编译成了什么？** 也许你认为并不重要。业务中的代码往往非常复杂，经过 webpack
编译后的代码可读性非常差。但是不管是复杂的项目还是最简单的一行代码，其经过 webpack 编译打包的 **产出本质是相同的**
。我们试图从最简单的情况开始，研究 webpack 打包产出的秘密。

#### CommonJS 规范打包结果

如何着手分析呢？首先创建并切入到项目，进行初始化：

    
    
    mkdir webpack-demo
    cd webpack-demo
    npm init -y
    

安装 webpack 最新版本：

    
    
    npm install --save-dev webpack
    npm install --save-dev webpack-cli
    

根目录下创建 index.html：

    
    
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <title>Document</title>
    </head>
    <body>
        <div id="app"></div>
        <script src="./dist/main.js"></script>
    </body>
    </html>
    

创建 `./src` 文件。因为我们要研究模块化打包产出，这一定涉及依赖关系，因此在 `./src` 目录下创建 hello.js 和
index.js，其中 index.js 为入口脚本，它将依赖 hello.js：

    
    
    const sayHello = require('./hello')
    console.log(sayHello('lucas'))
    

hello.js：

    
    
    module.exports = function (name) {
        return 'hello ' + name
    }
    

这里我们为了演示，采用了 CommonJS 规范，也没有加入 Babel 编译环节。

直接执行命令：

    
    
    node_modules/.bin/webpack --mode development
    

便得到了产出 `./dist`，打开 `./dist/main.js`，得到最终编译结果：

    
    
    (function(modules) {
        //缓存已经加载过的 module 的 exports，防止 module 在 exports 之前 JS 重复执行
        var installedModules = {};
    
        //类似 commonJS 的 require()，它是 webpack 加载函数，用来加载 webpack 定义的模块，返回 exports 导出的对象
        function __webpack_require__(moduleId) {
            //缓存中存在，则直接返回结果
            if (installedModules[moduleId]) {
                return installedModules[moduleId].exports
            }
    
            //第一次加载时，初始化模块对象，并进行缓存
            var module = installedModules[moduleId] = {
                i: moduleId, // 模块 ID
                l: false, // 是否已加载标识
                exports: {} // 模块导出对象
            };
    
            /**
            * 执行模块
            * @param module.exports -- 模块导出对象引用，改变模块包裹函数内部的 this 指向
            * @param module -- 当前模块对象引用
            * @param module.exports -- 模块导出对象引用
            * @param __webpack_require__ -- 用于在模块中加载其他模块
            */
            modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
    
            //标记是否已加载标识
            module.l = true;
    
            //返回模块导出对象引用
            return module.exports
        }
    
        __webpack_require__.m = modules;
        __webpack_require__.c = installedModules;
        //定义 exports 对象导出的属性
        __webpack_require__.d = function(exports, name, getter) {
            //如果 exports （不含原型链上）没有 [name] 属性，定义该属性的 getter
            if (!__webpack_require__.o(exports, name)) {
                Object.defineProperty(exports, name, {
                    enumerable: true,
                    get: getter
                })
            }
        };
        __webpack_require__.r = function(exports) {
            if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
                Object.defineProperty(exports, Symbol.toStringTag, {
                    value: 'Module'
                })
            }
            Object.defineProperty(exports, '__esModule', {
                value: true
            })
        };
        __webpack_require__.t = function(value, mode) {
            if (mode & 1) value = __webpack_require__(value);
            if (mode & 8) return value;
            if ((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
            var ns = Object.create(null);
            __webpack_require__.r(ns);
            Object.defineProperty(ns, 'default', {
                enumerable: true,
                value: value
            });
            if (mode & 2 && typeof value != 'string') for (var key in value) __webpack_require__.d(ns, key, function(key) {
                return value[key]
            }.bind(null, key));
            return ns
        };
        __webpack_require__.n = function(module) {
            var getter = module && module.__esModule ?
            function getDefault() {
                return module['default']
            } : function getModuleExports() {
                return module
            };
            __webpack_require__.d(getter, 'a', getter);
            return getter
        };
        __webpack_require__.o = function(object, property) {
            return Object.prototype.hasOwnProperty.call(object, property)
        };
        // __webpack_public_path__
        __webpack_require__.p = "";
    
        //加载入口模块并返回入口模块的 exports
        return __webpack_require__(__webpack_require__.s = "./src/index.js")
    })({
        "./src/hello.js": (function(module, exports) {
            eval("module.exports = function(name) {\n    return 'hello ' + name\n}\n\n//# sourceURL=webpack:///./src/hello.js?")
        }),
        "./src/index.js": (function(module, exports, __webpack_require__) {
            eval("var sayHello = __webpack_require__(/*! ./hello */ \"./src/hello.js\")\nconsole.log(sayHello('lucas'))\n\n//# sourceURL=webpack:///./src/index.js?")
        })
    });
    

不要着急阅读，我们先把最核心的代码骨架提出来，上面的代码其实就是一个 IIFE（立即执行函数表达式）：

    
    
    (function(modules){
      // ...
    })({
      "./src/hello.js": (function(){
        // ...
      }),
      "./src/index.js": (function() {
        // ...
      })
    })
    

Ben Cherry 的著名文章[ JavaScript Module Pattern: In-
Depth](http://www.adequatelygood.com/JavaScript-Module-Pattern-In-Depth.html)
介绍了 IIFE 实现模块化的多种进阶尝试，阮一峰老师在其博客中也提到了相关内容。用 IIFE 实现模块化，我们并不陌生。

**深入上述代码结果（已添加注释），我们可以提炼出以下关键几点。**

  * webpack 打包结果就是一个 IIFE，一般称它为 webpackBootstrap，这个 IIFE 接收一个对象 modules 作为参数，modules 对象的 key 是依赖路径，value 是经过简单处理后的脚本（它不完全等同于我们编写的业务脚本，而是被 webpack 进行包裹后的内容）。
  * 打包结果中，定义了一个重要的模块加载函数 `__webpack_require__`。
  * 我们首先使用 `__webpack_require__` 加载函数去加载入口模块 `./src/index.js`。
  * 加载函数 `__webpack_require__` 使用了闭包变量 installedModules，它的作用是将已加载过的模块结果保存在内存中。

如果读者对于产出结果源码存在不理解的地方，请继续阅读，我们将会在 webpack 工作基本原理部分进一步说明，同时欢迎随时在评论区跟我讨论。

#### ES 规范打包结果

以上是基于 CommonJS 规范的模块化写法，业务中我们的代码往往遵循 ES Next 模块化标准，并通过 Babel
进行编译，这样的流程下，会得到什么结果呢？

我们动手尝试一下，安装依赖：

    
    
    npm install --save-dev webpack
    npm install --save-dev webpack-cli
    npm install --save-dev babel-loader
    npm install --save-dev @babel/core
    npm install --save-dev @babel/preset-env
    

同时配置 package.json，加入：

    
    
    "scripts": {
        "build": "webpack --mode development --progress --display-modules --colors --display-reasons"
    s},
    

设置 npm script 以方便运行 webpack 构建，同时在 package.json 中加入 Babel 配置：

    
    
    "babel": {
        "presets": ["@babel/preset-env"]
    }
    

将 index.js 和 hello.js 改写为 ESM 方式：

    
    
    // hello.js
    const sayHello = name => `hello ${name}`
    export default sayHello
    
    // index.js
    import sayHello from './hello.js'
    console.log(sayHello('lucas'))
    

执行：

    
    
    npm run build
    

得到的打包主体与之前内容基本一致。但是细节上，我们发现 IIFE 传入参数 modules 对象的 value 部分，即执行脚本内容多了以下语句：

    
    
    __webpack_require__.r(__webpack_exports__)
    

实际上 `__webpack_require__.r` 这个方法是给模块的 exports 对象加上 ES 模块化规范的标记。

具体标记方式为：如果支持 Symbol 对象，则通过 Object.defineProperty 为 exports 对象的
Symbol.toStringTag 属性赋值 Module，这样做的结果是 exports 对象在调用 toString 方法时会返回
Module；同时，将 `exports.__esModule` 赋值为 true。

除了 CommonJS 和 ES Module 规范，webpack 同样支持 AMD
规范，这里不再进行分析，读者可以重新打包来观察它们的区别。总之，希望大家记住 webpack 打包输出的结果就是一个 IIFE，通过这个 IIFE，以及
`__webpack_require__` 支持了各种模块化打包方案。

#### 按需加载打包结果

**现代化的业务，尤其是在单页应用中，我们往往使用“按需加载”，那么对于这种相对较新的依赖技术，webpack 又会产出什么样的代码呢？**

我们加入 Babel 插件，以支持 dynamic import：

    
    
    npm install --save-dev babel-plugin-dynamic-import-webpack
    

并在 webpack.config.js 中添加相关插件配置：

    
    
    module.exports={
        module:{
            rules:[
                {
                    test: /\.js$/,
                    exclude: /node_modules/, 
                    loader: "babel-loader",
                    options: {
                        "plugins": [
                            "dynamic-import-webpack"
                        ]
                    }
                }
            ]
        }
    }
    

同时，将 index.js 使用 dynamic import 的方式实现按需加载：

    
    
    import('./hello').then(sayHello => {
        console.log(sayHello('lucas'))
    })
    

最后执行：

    
    
    npm run build
    

这样一来，我们发现重新构建后会输出两个文件，分别是执行入口文件 main.js 和异步加载文件 0.js，因为异步按需加载显然不能把所有的代码再打到一个
bundle 当中了。

0.js 内容为：

    
    
    (window["webpackJsonp"] = window["webpackJsonp"] || []).push([
    [0],
    {
        "./src/hello.js": (function(module, __webpack_exports__, __webpack_require__) {
            "use strict";
            eval("__webpack_require__.r(__webpack_exports__);\n// module.exports = function(name) {\n//     return 'hello ' + name\n// }\nvar sayHello = function sayHello(name) {\n  return \"hello \".concat(name);\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (sayHello);\n\n//# sourceURL=webpack:///./src/hello.js?")
        })
    }])
    

main.js 内容也与之前相比变化较大：

    
    
    (function(modules) {
        /***
        * webpackJsonp 用于从异步加载的文件中安装模块
        * 把 webpackJsonp 挂载到全局是为了方便在其他文件中调用
        *
        * @param chunkIds 异步加载的文件中存放的需要安装的模块对应的 Chunk ID
        * @param moreModules 异步加载的文件中存放的需要安装的模块列表
        * @param executeModules 在异步加载的文件中存放的需要安装的模块都安装成功后，需要执行的模块对应的 index
        */
        function webpackJsonpCallback(data) {
            var chunkIds = data[0];
            var moreModules = data[1];
            var moduleId, chunkId, i = 0,
                resolves = [];
            // 把所有 chunkId 对应的模块都标记成已经加载成功 
            for (; i < chunkIds.length; i++) {
                chunkId = chunkIds[i];
                if (installedChunks[chunkId]) {
                    resolves.push(installedChunks[chunkId][0])
                }
                installedChunks[chunkId] = 0
            }
            for (moduleId in moreModules) {
                if (Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
                    modules[moduleId] = moreModules[moduleId]
                }
            }
            if (parentJsonpFunction) parentJsonpFunction(data);
            while (resolves.length) {
                resolves.shift()()
            }
        };
    
        var installedModules = {};
        // 存储每个 Chunk 的加载状态
        // 键为 Chunk 的 ID，值为 0 代表已经加载成功
        var installedChunks = {
        "main": 0
        };
    
        function jsonpScriptSrc(chunkId) {
            return __webpack_require__.p + "" + ({}[chunkId] || chunkId) + ".js"
        }
        function __webpack_require__(moduleId) {
            if (installedModules[moduleId]) {
                return installedModules[moduleId].exports
            }
            var module = installedModules[moduleId] = {
                i: moduleId,
                l: false,
                exports: {}
            };
            modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
            module.l = true;
            return module.exports
        }
    
        /**
        * 用于加载被分割出去的，需要异步加载的 Chunk 对应的文件
        * @param chunkId 需要异步加载的 Chunk 对应的 ID
        * @returns {Promise}
        */
        __webpack_require__.e = function requireEnsure(chunkId) {
            var promises = [];
            var installedChunkData = installedChunks[chunkId];
            // 如果加载状态为 0 表示该 Chunk 已经加载成功了，直接返回 resolve Promise
            if (installedChunkData !== 0) {
                if (installedChunkData) {
                    promises.push(installedChunkData[2])
                } else {
                    var promise = new Promise(function(resolve, reject) {
                        installedChunkData = installedChunks[chunkId] = [resolve, reject]
                    });
                    promises.push(installedChunkData[2] = promise);
                    var script = document.createElement('script');
                    var onScriptComplete;
                    script.charset = 'utf-8';
                    // 设置异步加载的最长超时时间
                    script.timeout = 120;
                    if (__webpack_require__.nc) {
                        script.setAttribute("nonce", __webpack_require__.nc)
                    }
                    // 文件的路径为配置的 publicPath、chunkId 拼接而成
                    script.src = jsonpScriptSrc(chunkId);
                    onScriptComplete = function(event) {
                        script.onerror = script.onload = null;
                        clearTimeout(timeout);
                        var chunk = installedChunks[chunkId];
                        if (chunk !== 0) {
                            if (chunk) {
                                var errorType = event && (event.type === 'load' ? 'missing' : event.type);
                                var realSrc = event && event.target && event.target.src;
                                var error = new Error('Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')');
                                error.type = errorType;
                                error.request = realSrc;
                                chunk[1](error)
                            }
                            installedChunks[chunkId] = undefined
                        }
                    };
                    var timeout = setTimeout(function() {
                        onScriptComplete({
                            type: 'timeout',
                            target: script
                        })
                    }, 120000);
                    script.onerror = script.onload = onScriptComplete;head 
                    // 通过 DOM 操作，往 HTML head 中插入一个 script 标签去异步加载 Chunk 对应的 JavaScript 文件
                    document.head.appendChild(script)
                }
            }
            return Promise.all(promises)
        };
    
        __webpack_require__.m = modules;
        __webpack_require__.c = installedModules;
        __webpack_require__.d = function(exports, name, getter) {
            if (!__webpack_require__.o(exports, name)) {
                Object.defineProperty(exports, name, {
                    enumerable: true,
                    get: getter
                })
            }
        };
    
        __webpack_require__.r = function(exports) {
            if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
                Object.defineProperty(exports, Symbol.toStringTag, {
                    value: 'Module'
                })
            }
            Object.defineProperty(exports, '__esModule', {
                value: true
            })
        };
    
        __webpack_require__.t = function(value, mode) {
            if (mode & 1) value = __webpack_require__(value);
            if (mode & 8) return value;
            if ((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
            var ns = Object.create(null);
            __webpack_require__.r(ns);
            Object.defineProperty(ns, 'default', {
                enumerable: true,
                value: value
            });
            if (mode & 2 && typeof value != 'string') for (var key in value) __webpack_require__.d(ns, key, function(key) {
                return value[key]
            }.bind(null, key));
            return ns
        };
    
        __webpack_require__.n = function(module) {
            var getter = module && module.__esModule ?
            function getDefault() {
                return module['default']
            } : function getModuleExports() {
                return module
        };
        __webpack_require__.d(getter, 'a', getter);
            return getter
        };
        __webpack_require__.o = function(object, property) {
            return Object.prototype.hasOwnProperty.call(object, property)
        };
        __webpack_require__.p = "";
        __webpack_require__.oe = function(err) {
            console.error(err);
            throw err;
        };
    
        var jsonpArray = window["webpackJsonp"] = window["webpackJsonp"] || [];
        var oldJsonpFunction = jsonpArray.push.bind(jsonpArray);
        jsonpArray.push = webpackJsonpCallback;
        jsonpArray = jsonpArray.slice();
        for (var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);
    
        var parentJsonpFunction = oldJsonpFunction;
        return __webpack_require__(__webpack_require__.s = "./src/index.js")
        })({
            // 所有没有经过异步加载的，随着执行入口文件加载的模块
            "./src/index.js": (function(module, exports, __webpack_require__) {
            eval("// var sayHello = require('./hello')\n// console.log(sayHello('lucas'))\n// import sayHello from './hello.js'\n// console.log(sayHello('lucas'))\nnew Promise(function (resolve) {\n  __webpack_require__.e(/*! require.ensure */ 0).then((function (require) {\n    resolve(__webpack_require__(/*! ./hello */ \"./src/hello.js\"));\n  }).bind(null, __webpack_require__)).catch(__webpack_require__.oe);\n}).then(function (sayHello) {\n  console.log(sayHello('lucas'));\n});\n\n//# sourceURL=webpack:///./src/index.js?")
        })
    });
    

按需加载相比常规打包产出结果变化较大，也更加复杂。我们仔细对比其中差异，发现 main.js：

  * 多了一个 `__webpack_require__.e`
  * 多了一个 webpackJsonp

其中 `__webpack_require__.e` 实现非常重要，它初始化了一个 promise 数组，使用 Promise.all() 进行异步插入
script 脚本；webpackJsonp 会挂在到全局对象 window 上，进行模块安装。

熟悉 webpack 的读者可能会知道 CommonsChunkPlugin 插件（在 webpack v4
版本中已经被取代），这个插件用来分割第三方依赖或者公共库的代码，将业务逻辑和稳定的库脚本分离，以达到优化代码体积、合理使用缓存的目的。实际上，这样的思路和上述“按需加载”不谋而合，具体实现思路也一致。我们可以推测开发者在使用
CommonsChunkPlugin 插件打包后的代码结果和上面的代码结构类似，都存在 __webpack_require__.e 和
webpackJsonp。 **因为提取公共代码和异步加载本质上都是前置进行代码分割，再在必要时加载，具体实现可以观察
__webpack_require__.e 和 webpackJsonp** 。

到此，我们分析了业务中几乎所有的打包方式以及 webpack 产出结果。虽然这些内容较为晦涩，源码冗长而难以阅读，但是这对我们理解 webpack
内部工作原理，编写 loader、plugin
意义重大。只有分析过所有这些最基本的编译后代码，我们才能对上线代码的质量做到“心里有底”。在出现问题时，能够驾轻就熟，独当一面。这也是高级 Web
工程师所必备的素养。

如果读者在阅读 webpack 打包后代码存在一些困难，也没有关系，细节实现相对打包思想设计并没有那么重要。也许你试着去设计一个模块系统，了解一下
require.js 或者 sea.js
的实现，这些内容也就不再“那么高深”了。这些代码实现细节可以放在一边，通过后续章节的学习之后，再返回来看，可能效果更好。

### 分享交流

请大家留言分享「前端工程化」相关的开发心得，你也可以阅读完下一节全部完成这个主题后再来总结。阅读文章过程中有任何疑问随时可以跟其他小伙伴讨论，或者直接向作者
LucasHC 提问（作者看到后会抽空解答）。 **你的分享不仅帮助他人，更会提升自己。**

同时，欢迎说说自己最想了解的主题，课程内容会根据大家的意见和建议迭代和完善。

此外，我们为本课程付费读者创建了《前端开发核心知识进阶》微信交流群，以方便更有针对性地讨论课程相关问题。（入群请到第1-2课末尾扫描二维码，若失效请加
GitChat 小助手伽利略的微信，ID 为 GitChatty6，注明「前端核心」。）



## webpack 工程师和前端工程师（下）

上一节中，我们了解了 webpack 对于不同模块化标准的打包结果，分析了其自身的模块化解决方案。但是 webpack
绝不仅仅是一个打包器，它是一个完整的构建工具链。 **那么它到底是如何工作的，原理是什么？了解了这些原理，我们又能如何扩展，以解决工作中的实际问题？**
这一节，我们来一探究竟。

我们再次列出 webpack 主题的知识点：

![](https://images.gitbook.cn/e13b8fb0-4ecd-11e9-97d1-9b2c5e38f63d)

### webpack 工作基本原理

通过前文学习，我们知道了 webpack 编译产出，对结果进行分析。“知其然，知其所以然”，在知晓打包结果的基础上，接下来我们尝试分析产出过程，了解
webpack 工作的基本原理。

webpack 工作流程可以简单总结为下图：

![](https://images.gitbook.cn/800e19e0-4eac-11e9-9566-89cb1d9578c6)

  * 首先，webpack 会读取项目中由开发者定义的 webpack.config.js 配置文件，或者从 shell 语句中获得必要的参数。这是 webpack 内部接收业务配置信息的方式。这就完成了配置读取的初步工作。
  * 接着，实例化所需 webpack 插件，在 webpack 事件流上挂载插件钩子，这样在合适的构建过程中，插件具备了改动产出结果的能力。
  * 同时，根据配置所定义的入口文件，以入口文件（可以不止有一个）为起始，进行依赖收集：对所有依赖的文件进行编译，这个编译过程依赖 loaders，不同类型文件根据开发者定义的不同 loader 进行解析。编译好的内容使用 acorn 或其它抽象语法树能力，解析生成 AST 静态语法树，分析文件依赖关系，将不同模块化语法（如 require）等替换为 `__webpack_require__`，即使用 webpack 自己的加载器进行模块化实现。
  * 上述过程进行完毕后，产出结果，根据开发者配置，将结果打包到相应目录。

值得一提的是，在这整个打包过程中， **webpack 和插件采用基于事件流的发布订阅模式，监听某些关键过程，在这些环节中执行插件任务**
。到最后，所有文件的编译和转化都已经完成，输出最终资源。

如果深入源码，上述过程用更加专业的术语总结为——模块会经历 **加载** （loaded）、 **封存** （sealed）、 **优化**
（optimized）、 **分块** （chunked）、 **哈希** （hashed）和 **重新创建**
（restored）这几个经典步骤。在这里，我们了解大体流程即可。

梳理完 webpack 工作“流水账”，我们还需要在理论上熟悉以下概念。

#### 抽象语法树 AST

即便大家没有接触过 AST，也应该不是第一次听说这个概念。

在计算机科学中，抽象语法树（Abstract Syntax Tree，简称
AST），是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构和表达。

之所以说语法是“抽象”的，是因为这里的语法并不会表示出真实语法中出现的每个细节。比如类似于 if-condition-then
这样的条件跳转语句，可以使用带有两个分支的节点来表示。

AST 并不会被计算机所识别，更不会被运行，它是对编程语言的一种表达，为代码分析提供了基础。

**webpack 将文件转换成 AST 的目的就是方便开发者提取模块文件中的关键信息。**
这样一来，我们就可以“知晓开发者到底写了什么东西”，也就可以根据这些“写出的东西”，实现分析和扩展。在代码层面，我们可以把 AST 理解为一个
object：

    
    
    var ast = 'AST demo'
    

这样的语句转换为 AST 就是：

    
    
    {
      "type": "Program",
      "start": 0,
      "end": 20,
      "body": [
        {
          "type": "VariableDeclaration",
          "start": 0,
          "end": 20,
          "declarations": [
            {
              "type": "VariableDeclarator",
              "start": 4,
              "end": 20,
              "id": {
                "type": "Identifier",
                "start": 4,
                "end": 7,
                "name": "ast"
              },
              "init": {
                "type": "Literal",
                "start": 10,
                "end": 20,
                "value": "AST demo",
                "raw": "'AST demo'"
              }
            }
          ],
          "kind": "var"
        }
      ],
      "sourceType": "module"
    }
    

从中我们可以看出，AST 结果精确地表明了这是一条变量声明语句，语句起始于哪里，赋值结果是什么等信息都被表达出来。

一个更复杂的例子：

    
    
    let tips = [1, 2]
    
    function printTips() {
      tips.forEach((tip, i) => console.log(`Tip ${i}:` + tip))
    }
    

会转化为：

    
    
    {
      "type": "Program",
      "start": 0,
      "end": 285,
      "body": [
        {
          "type": "VariableDeclaration",
          "start": 179,
          "end": 197,
          "declarations": [
            {
              "type": "VariableDeclarator",
              "start": 183,
              "end": 196,
              "id": {
                "type": "Identifier",
                "start": 183,
                "end": 187,
                "name": "tips"
              },
              "init": {
                "type": "ArrayExpression",
                "start": 190,
                "end": 196,
                "elements": [
                  {
                    "type": "Literal",
                    "start": 191,
                    "end": 192,
                    "value": 1,
                    "raw": "1"
                  },
                  {
                    "type": "Literal",
                    "start": 194,
                    "end": 195,
                    "value": 2,
                    "raw": "2"
                  }
                ]
              }
            }
          ],
          "kind": "let"
        },
        {
          "type": "FunctionDeclaration",
          "start": 199,
          "end": 283,
          "id": {
            "type": "Identifier",
            "start": 208,
            "end": 217,
            "name": "printTips"
          },
          "expression": false,
          "generator": false,
          "params": [],
          "body": {
            "type": "BlockStatement",
            "start": 220,
            "end": 283,
            "body": [
              {
                "type": "ExpressionStatement",
                "start": 224,
                "end": 281,
                "expression": {
                  "type": "CallExpression",
                  "start": 224,
                  "end": 280,
                  "callee": {
                    "type": "MemberExpression",
                    "start": 224,
                    "end": 236,
                    "object": {
                      "type": "Identifier",
                      "start": 224,
                      "end": 228,
                      "name": "tips"
                    },
                    "property": {
                      "type": "Identifier",
                      "start": 229,
                      "end": 236,
                      "name": "forEach"
                    },
                    "computed": false
                  },
                  "arguments": [
                    {
                      "type": "ArrowFunctionExpression",
                      "start": 237,
                      "end": 279,
                      "id": null,
                      "expression": true,
                      "generator": false,
                      "params": [
                        {
                          "type": "Identifier",
                          "start": 238,
                          "end": 241,
                          "name": "tip"
                        },
                        {
                          "type": "Identifier",
                          "start": 243,
                          "end": 244,
                          "name": "i"
                        }
                      ],
                      "body": {
                        "type": "CallExpression",
                        "start": 249,
                        "end": 279,
                        "callee": {
                          "type": "MemberExpression",
                          "start": 249,
                          "end": 260,
                          "object": {
                            "type": "Identifier",
                            "start": 249,
                            "end": 256,
                            "name": "console"
                          },
                          "property": {
                            "type": "Identifier",
                            "start": 257,
                            "end": 260,
                            "name": "log"
                          },
                          "computed": false
                        },
                        "arguments": [
                          {
                            "type": "BinaryExpression",
                            "start": 261,
                            "end": 278,
                            "left": {
                              "type": "TemplateLiteral",
                              "start": 261,
                              "end": 272,
                              "expressions": [
                                {
                                  "type": "Identifier",
                                  "start": 268,
                                  "end": 269,
                                  "name": "i"
                                }
                              ],
                              "quasis": [
                                {
                                  "type": "TemplateElement",
                                  "start": 262,
                                  "end": 266,
                                  "value": {
                                    "raw": "Tip ",
                                    "cooked": "Tip "
                                  },
                                  "tail": false
                                },
                                {
                                  "type": "TemplateElement",
                                  "start": 270,
                                  "end": 271,
                                  "value": {
                                    "raw": ":",
                                    "cooked": ":"
                                  },
                                  "tail": true
                                }
                              ]
                            },
                            "operator": "+",
                            "right": {
                              "type": "Identifier",
                              "start": 275,
                              "end": 278,
                              "name": "tip"
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          }
        }
      ],
      "sourceType": "module"
    }
    

我们看到，AST 结果除了表达出变量赋值 VariableDeclaration 信息以外，对函数声明 FunctionDeclaration
也做了精确的“解剖”，哪里出现了一个花括号，哪里实现了 API 调用，通过 AST 全部一览无余。

设想一下，有了这样的语法树，开发者便可以针对源文件进行一些“分析、加工或转换”操作。

#### compiler 和 compilation

compiler 和 compilation 这两个对象是 webpack 核心原理中最重要的概念。它们是理解 webpack 工作原理、loader
和插件工作的基础。

  * compiler 对象：它的实例包含了完整的 webpack 配置，全局只有一个 compiler 实例，因此它就像 webpack 的骨架或神经中枢。当插件被实例化的时候，会收到一个 compiler 对象，通过这个对象可以访问 webpack 的内部环境。
  * compilation 对象：当 webpack 以开发模式运行时，每当检测到文件变化，一个新的 compilation 对象将被创建。这个对象包含了当前的模块资源、编译生成资源、变化的文件等信息。也就是说，所有构建过程中产生的构建数据都存储在该对象上，它也掌控着构建过程中的每一个环节。该对象也提供了很多事件回调供插件做扩展。

两者的关系可以通过以下图示说明：

![](https://images.gitbook.cn/97a316a0-4eac-11e9-9566-89cb1d9578c6)

webpack 的构建过程是通过 compiler 控制流程，compilation 进行解析。 **在开发插件时，我们可以从 compiler
对象中拿到所有和 webpack 主环境相关的内容，包括事件钩子。** 更多信息我们将在下文介绍。

compiler 对象和 compilation 对象都继承自 tapable，tapable.js 这个库暴露了所有和事件相关的 pub/sub
的方法。webpack 基于事件流的 tapable 库，不仅能保证插件的有序性，还使得整个系统扩展性更好。

关于 tapable 库的解读我们到这里不再深入，感兴趣的读者可以参加后续讨论和学习后续文章内容。

### 探秘并编写 webpack loader

熟悉了概念，我们就来进行实战：了解如何编写一个 webpack loader。事实上，在 webpack 中，loader
是魔法真正发生的阶段之一：Babel 将 ES Next 编译成 ES5，sass-loader 将 SCSS/Sass 编译成 CSS 等，都是由相关
loader 或者 plugin 完成的。因此，直观上理解， **loader 就是接受源文件，对源文件进行处理，返回编译后文件** 。如图：

![](https://images.gitbook.cn/9e70e110-4eac-11e9-9566-89cb1d9578c6)

我们看到一个 loader 秉承单一职责，完成最小单元的文件转换。当然， **一个源文件可能需要经历多步转换才能正常使用** ，比如 Sass 文件先通过
sass-loader 输出 CSS，之后将内容交给 css-loader 处理，甚至 css-loader 输出的内容还需要交给 style-loader
处理，转换成通过脚本加载的 JavaScript 代码。如下使用方式：

    
    
    module.exports = {
      ...
      module: {
        rules: [{
          test: /\.less$/,
          use: [{
            loader: 'style-loader' // 通过 JS 字符串，创建 style node
          }, {
            loader: 'css-loader' // 编译 css 使其符合 CommonJS 规范
          }, {
            loader: 'less-loader' // 编译 less 为 css
          }]
        }]
      }
    }
    

当我们调用多个 loader 串联去转换一个文件时，每个 loader 会链式地顺序执行。webpack 中，在同一文件存在多个匹配 loader
的情况下，遵循以下原则：

  * loader 的执行顺序是和配置顺序相反的，即配置的最后一个 loader 最先执行，第一个 loader 最后执行。
  * 第一个执行的 loader 接收源文件内容作为参数，其他 loader 接收前一个执行的 loader 的返回值作为参数。最后执行的 loader 会返回最终结果。

如图，对应上面代码：

![](https://images.gitbook.cn/a3934570-4eac-11e9-b0b9-2fcbe141d641)

因此，在你开发一个 loader 时，请保持其职责的单一性，只需关心输入和输出。

不难理解：loader 本质就是函数，其最简单的结构为：

    
    
    module.exports = function(source){
         // some magic...
         return content
    }
    

loader 就是一个基于 CommonJS 规范的函数模块，它接受内容（这个内容可能是源文件也可能是经过其他 loader
处理后的结果），并返回新的内容。

更进一步，我们知道在配置 webpack 时，对于 loader 可以增加一些配置，比如著名的 babel-loader 的简单配置：

    
    
    module:{
        rules:[
            {
                test: /\.js$/,
                exclude: /node_modules/, 
                loader: "babel-loader",
                options: {
                    "plugins": [
                        "dynamic-import-webpack"
                    ]
                }
            }
        ]
    }
    

这样一来，上文简单的 loader 写法便不能满足需求了，因为我们除了 source 以外，还需要根据开发者配置的 options
信息进行处理，以输出最后结果。那么如何获取 options 呢？这时候就需要 loader-utils 模块了：

    
    
    const loaderUtils = require("loader-utils")
    module.exports = function(source) {
        // 获取开发者配置的 options
        const options = loaderUtils.getOptions(this)
        // some magic...
        return content
    }
    

另外，对于 loader 返回的内容，在实际开发中，单纯对 content 进行改写并返回也许是不够的。

比如，我们想对 loader 处理过程中的错误进行捕获，或者又想导出 sourceMap 等信息，该如何做呢？

这种情况需要用到 loader 中的 this.callback 进行内容的返回。this.callback 可以传入四个参数，分别是：

  * error：Error | null，当 loader 出错时向外抛出一个 error
  * content：String | Buffer，经过 loader 编译后需要导出的内容
  * sourceMap：为方便调试生成的编译后内容的 source map
  * ast：本次编译生成的 AST 静态语法树，之后执行的 loader 可以直接使用这个 AST，进而省去重复生成 AST 的过程

这样，我们的 loader 代码变得更加复杂，同时也能够处理更多样的需求：

    
    
    module.exports = function(source) {
        // 获取开发者配置的 options
        const options = loaderUtils.getOptions(this)
        // some magic...
        // return content
        this.callback(null, content)
    }
    

**注意** 当我们使用 `this.callback` 返回内容时，该 loader 必须返回 `undefined`，这样 webpack 就知道该
loader 返回的结果在 `this.callback` 中，而不是 return 中。

**细心的读者会问，这里的 this 指向谁？** 事实上，这个 this 是一个叫 loaderContext 的 loader-runner
特有对象。如果刨根问底，就要细读 webpack loader 部分相关源码了，这并不是我们的主题，感兴趣的读者可以针对 webpack 源码再进行分析。

默认情况下，webpack 传给 loader 的内容源都是 UTF-8 格式编码的字符串。但请思考 file-loader 这个常用的
loader，它不是处理文本文件，而是处理二进制文件的，这种情况下，我们可以通过：source instanceof Buffer === true
来判断内容源类型：

    
    
    module.exports = function(source) {
        source instanceof Buffer === true
        return source
    }
    

如果自定义的 loader 也会返回二进制文件，需要在文件中显式注明：

    
    
    module.exports.raw = true
    

当然，还存在异步 loader 的情况，即对 source 的处理并不能同步完成，这时候使用简单的 async-await 即可：

    
    
    module.exports = async function(source) {
        function timeout(delay) {
            return new Promise((resolve, reject) => {
                setTimeout(() => {
                    resolve(source)
                }, delay)
            })
        }
        const content = await timeout(1000)
        this.callback(null, content)
    }
    

另一种异步 loader 解决方案是使用 webpack 提供的 this.async，调用 this.async 会返回一个 callback
Function，在异步完成之后，我们进行调用。上面的示例代码可以改写为：

    
    
    module.exports = async function(source) {
        function timeout(delay) {
            return new Promise((resolve, reject) => {
                setTimeout(() => {
                    resolve(source)
                }, delay)
            })
        }
        const callback = this.async()
        timeout(1000).then(data => {
            callback(null, data)
        })
    }
    

实际上，对于我们熟悉的 less-loader，翻看其源码，就能发现它的核心是利用 less 这个库来解析 less 代码，less 会返回一个
promise，因此 less-loader 是异步的，其实现正是运用了 this.async() 来完成。

到此，我们了解了 loader 的编写套路，更多细节内容，比如 loader 缓存开关、全程传参 pitch
等用法不再过多讨论，读者可以根据需要进行了解，也欢迎在课程评论区大家一起讨论沟通。

#### 实战案例

工程师想要进阶，一定要“学以致用”，解决实际问题。我们现在来编写一个 path-replace-loader，这个 loader 将允许自定义替换
require 语句中的 base path 为动态指定 path，使用和配置方式为：

    
    
    module.exports = {
        module: {
            rules: [{
                test: /\.js$/,
                loader: 'path-replace-loader',
                exclude: /(mode_modules)/,
                options: {
                    path: 'ORIGINAL_PATH',
                    replacePath: 'REPLACE_PATH'
                }
            }]
        }
    }
    

根据上面所介绍内容，我们给出 path-replace-loader 源码如下：

    
    
    const fs = require('fs')
    const loaderUtils = require('loader-utils')
    
    module.exports = function(source) {
        this.cacheable && this.cacheable()
        const callback = this.async()
        const options = loaderUtils.getOptions(this)
    
        if (this.resourcePath.indexOf(options.path) > -1) {
            const newPath = this.resourcePath.replace(options.path, options.replacePath)
    
            fs.readFile(newPath, (err, data) => {
                if (err) {
                    if (err.code === 'ENOENT') return callback(null, source)
                    return callback(err)
                }
    
                this.addDependency(newPath)
                callback(null, data)
            })
        }
        else {
            callback(null, source)
        }
    }
    
    module.exports.raw = true 
    

这只是一个简单的实例，但是涵盖了 loader 编写的不少内容，我们来简单分析一下：这是一个异步 loader，我们使用了下面，

    
    
    const callback = this.async()
    // ...
    callback(null, data)
    

的返回方式。通过：

    
    
    const options = loaderUtils.getOptions(this)
    // ...
    const newPath = this.resourcePath.replace(options.path, options.replacePath)
    

获取开发者的配置信息，并与 this.resourcePath（当前资源文件路径）比对，进行路径替换。

对于错误的处理也很简单：如果新的目标路径文件不存在，则返回原路径文件：

    
    
    if (err.code === 'ENOENT') return callback(null, source)
    

其它错误也一并通过 return callback(err) 抛出。

主逻辑使用了 this.addDependency(newPath) 将新的文件加入到 webpack 依赖当中，并返回内容 callback(null,
data)。

这个过程并不复杂，同时思路非常清晰，通过这个案例，读者可以根据自身团队需求，编写不同复杂度的 wepback loader，实现不同程度的拓展。

### 探秘并编写 webpack plugin

除了 webpack loader 这个核心概念以外，webpack plugin 是另一个重要话题。loader 和 plugin 就像 webpack
的双子星，有着共同之处，但是分工却很明晰。

我们反复提到过 webpack **事件流机制** ，也就是说在 webpack
构建的生命周期中，会广播许多事件。这时候，开发中注册的各种插件，便可以根据需要监听与自身相关的事件。捕获事件后，在合适的时机通过 webpack 提供的
API 去改变编译输出结果。

因此，我们可以总结出 loader 和 plugin 的 **差异** 。

  * loader 其实就是一个转换器，执行单纯的文件转换操作。
  * plugin 是一个扩展器，它丰富了 webpack 本身，在 loader 过程结束后，webpack 打包的整个过程中，weback plugin 并不直接操作文件，而是基于事件机制工作，监听 webpack 打包过程中的某些事件，见缝插针，修改打包结果。

**究竟应该如何从零开始，编写一个 webpack 插件呢？**

首先我们要清楚当前插件要解决什么问题，根据问题，找到相应的钩子事件，在相关事件中进行操作，改变输出结果。这就需要清楚开发中都有哪些钩子了，下面列举一些常用的，完整内容可以在官网找到：[Compiler
暴露的所有事件钩子](https://webpack.js.org/api/compiler-hooks/)。

我们知道 compiler 对象暴露了和 webpack 整个生命周期相关的钩子，通过如下的方式访问：

    
    
    //基本写法
    compiler.hooks.someHook.tap(...)
    

例如，如果希望 webpack 在读取 entry 配置完后就执行某项工作，我们可以：

    
    
    compiler.hooks.entryOption.tap(...)
    

因为名字为 entryOption 的 SyncBailHook 类型 hook，就表明了入口配置信息执行完毕的事件，在相关 tap
函数中我们可以在这个时间节点插入操作。

又如，如果希望在生成的资源输出之前执行某个功能，我们可以：

    
    
    compiler.hooks.emit.tap(...)
    

因为名字为 emit 的 AsyncSeriesHook 类型 hook，就表明了资源输出前的时间节点。

一个自定义 webpack plugin 的骨架结构就是一个带有 apply 方法的 class（用 prototype 实现同理
CustomPlugin.prototype.apply = function () {...}）：

    
    
    class CustomPlugin {
        constructor(options) {
            this.options = options
        }
        apply(compiler) {
            // 相关钩子注册回调
            compiler.hooks.someHook.tap('CustomPlugin', () => {
                // magic here...
            })
    
            // 打印出此时 compiler 暴露的钩子
            for(var hook of Object.keys(compiler.hooks)){
                console.log(hook)
            }
        }
    }
    
    module.exports = customPlugin
    

除了 compiler 暴露了与 webpack 整体构建生命周期相关的钩子以外，compilation
也暴露了与模块和依赖有关的粒度更小的钩子，读者可以参考：[compilation
暴露的所有事件钩子](https://webpack.js.org/api/compilation-hooks/)，找到合适的时机插入自定义行为。

其实 compilation 是 compiler 生命周期中的一个步骤，使用 compilation 相关钩子的通用写法为：

    
    
    class CustomPlugin {
        constructor(options) {
            this.options = options
        }
        apply(compiler) {
            compiler.hooks.compilation.tap('CustomPlugin', function(compilation, callback) {
                compilation.hooks.someOtherHook.tap('SomePlugin',function() {
                    // some magic here
                })
            })
        }
    }
    
    module.exports = customPlugin
    

最终，我们可以总结一下 webpack 插件的 **套路** 。

  * 定义一个 JavaScript class 函数，或在函数原型（prototype）中定义一个以 compiler 对象为参数的 apply 方法。
  * apply 函数中通过 compiler 插入指定的事件钩子，在钩子回调中拿到 compilation 对象。
  * 使用 compilation 操纵修改 webapack 打包内容。

当然，plugin 也存在异步的情况，一些事件钩子是异步的。相应地，我们可以使用 tapAsync 和 tapPromise 方法来处理：

    
    
    class CustomAsyncPlugin {
        constructor(options) {
            this.options = options
        }
        apply(compiler) {
            compiler.hooks.emit.tapAsync('CustomAsyncPlugin', function(compilation, callback) {
                setTimeout(() => {
                    callback()
                }, 1000)
            })
    
            compiler.hooks.emit.tapPromise('CustomAsyncPlugin', function(compilation, callback) {
                return asyncFun().then(() => {
                    //...
                })
            })
        }
    }
    

#### 实战案例

接下来，我们来编写一个简单的 webpack 插件。相信不少 React 开发者了解：在使用 [create-react-
app](https://github.com/facebook/create-react-app) 开发项目时，如果发生错误，会出现 error
overlay 提示。我们来开发一个类似的功能，使用如下代码：

    
    
    module.exports = {
        // ...
        plugins: [new ErrorOverlayPlugin()],
        devtool: 'cheap-module-source-map',
        devServer: {}
    }
    

我们借助 errorOverlayMiddleware 中间件来进行错误拦截并展示：

    
    
    import errorOverlayMiddleware fomt 'react-dev-utils/errorOverlayMiddleware'
    
    class ErrorOverlayPlugin {
        apply(compiler) {
            const className = this.constructor.name
            if (compiler.options.mode !== 'development') return
    
            compiler.hooks.entryOption.tap(className, (context, entry) => {
                const chunkPath = require.resolve('./entry')
                adjustEntry(entry, chunkPath)
            }) 
    
            compiler.hooks.afterResolvers.tap(className, ({ options }) => {
                if (options.devServer) {
                    const originalBefore = options.devServer.before
                    option.devServer.before = (app, server) => {
                        if (originalBefore) {
                            originalBefore(app, server)
                        }
                        app.use(errorOverlayMiddleware())
                    }
    
                }
            }) 
        }
    }
    
    function adjustEntry(entry, chunkPath) {
        if (Array.isArray(entry)) {
            if (!entry.includes(chunkPath)) {
                entry.unshift(chunkPath)
            }
        }
        else {
            Object.keys(entry).forEach(entryName => {
                entry[name] = adjustEntry(entry[entryName], chunkPath)
            })
        }
    }
    
    module.exports = ErrorOverlayPlugin
    

参考实现源码，我们发现，编写一个 webpack plugin 确实并不困难，只需要开发者了解相关步骤，熟记相关钩子，并多加尝试即可。

简单分析一下上面代码，在非生产环境下，不打开错误窗口，而是直接返回，以免影响线上体验：

    
    
    if (compiler.options.mode !== 'development') return
    

在 entryOption hook 中，获取开发者配置的 entry 并通过 adjustEntry 方法获取正确的入口模块，该方法支持 entry
配置为 array 和 object 两种形式。在 afterResolvers hook 中，判断开发者是否开启
devServer，并对相关中间件进行调用 app.use(errorOverlayMiddleware())。

实际生产环境当中，webpack pulgin 生态丰富多样，一般已有插件就可以满足大部分开发需求。如果团队结合自身业务需求，自主编写 webpack
plugin，进而反哺生态，非常值得鼓励。

#### webpack plugin 开发重点

本节目前为止所介绍的内容已经可以带领大家入门插件开发。学习过程中我们会发现，webpack 插件开发重点在于对 compilation 和 compiler
以及两者对应钩子事件的理解、运用。我们提到 webpack 的事件机制基于 tapable 库，因此想完全理解 webpack 事件和钩子，有必要学习
tapable 。

事实上，tapable 更加复杂而“神通广大”，它除了提供同步和异步类型的钩子以外，又根据执行方式，串行/并行，衍生出
Bail、Waterfall、Loop 多种类型。站在 tapable 等的肩膀上，webpack 插件的开发更加灵活，可扩张性更强。

学习的目的在于应用。相信通过本小节的学习，读者已经能够理解 webpack 开发插件的流程。根据项目需要和业务特点，手握 webpack
插件开发的理论钥匙，在实践中多摸索、多尝试，每个人都一定会有所收获。

### webpack VS Rollup

Rollup 号称下一代打包方案，它的功能和特点非常突出：

  * 依赖解析，打包构建
  * 仅支持 ES Next 模块
  * Tree shaking

Rollup 凭借其清新且友好的配置，以及强大的功能横空出世，吸睛无数。

可以说，Webpack 算得上目前最流行的打包方案，而 Rollup 是下一代打包方案，两者有何区别？目前业界对两者的定位，可以总结为一句话： **建库使用
Rollup，其他场景使用 webpack。**

为什么这么说呢？还记得我们在前面提的 webpack 打包结果吗？从结果上看，webpack
方案会生成比较多的冗余代码，这对于业务代码来说没什么问题，能保证较强的程序健硕性和语法还原度，兼容性保障更有利。也许开发者会关心代码量多带来的冗余问题，但衡量其优缺点和开发效率性价比，webpack
始终是业务开发的首选；但对于库来说就不一样了，相同的脚本，使用 Rollup 产出，复杂的模块冗余会完全消失。Rollup
通过将代码顺序引入同一个文件来解决模块依赖问题，因此，Rollup
做拆包的话就会有问题，原因是模块完全透明了，而在复杂应用中我们往往需要进行拆包，在库的编写中很少用到这样的功能。

当然，“库使用 Rollup，其他场景使用 webpack”——这不是一个绝对的原则。如果你需要代码拆分（Code
Splitting），或者有很多静态资源需要处理，或者你构建的项目需要引入很多 CommonJS 规范的模块，再或者你需要拥有相对更大的社区支持，那么
webpack 是不错的选择。

如果你的代码库基于 ES Next 模块，且希望自己写的代码能够被其他人直接使用，那么，你需要的打包工具可能就是 Rollup 。

我们借用前面小节的代码，来看看经过 Rollup 编译之后的代码会成什么样子。

main.js：

    
    
    import sayHello from './hello.js'
    console.log(sayHello('lucas'))
    

hello.js：

    
    
    const sayHello = name => `hello ${name}`
    export default sayHello
    

编译结果非常简单：

    
    
    const sayHello = name => `hello ${name}`
    console.log(sayHello('lucas'))
    

这与 webpack 的打包产出形成了鲜明差异。这种打包方式，天然支持 tree shaking，我们改写上例，加入一个没有用到的 sayHi 函数：

main.js：

    
    
    import { sayHello } from './hello.js'
    
    console.log( sayHello( 'lucas' ) )
    

hello.js：

    
    
    export const sayHi = name => `hi ${name}`
    
    export const sayHello = name => `hello ${name}`
    

打包结果：

    
    
    'use strict';
    
    const sayHello = name => `hello ${name}`;
    console.log( sayHello( 'lucas' ) );
    

通过顺序引入依赖，非常简单、清晰，并且自动做到了 tree shaking，其中的原理和更多话题我们将在“深入浅出模块化”相关内容继续说明。

### 综合运用

至此，我们对于 webpack 已经有了较为深入的理解。但是，以上实战代码都是些较小型的 demo，综合运用这些知识到底能解决哪些问题呢？

我这里有一个很好的例子。

我们知道，2018
年号称小程序元年。以微信小程序为首，百度智能小程序、支付宝小程序、头条小程序纷纷入局。作为开发人员应该注意到，在带给开发无限红利的同时，由于各平台小程序的开发语法和技术方案不尽相同，因而也带来了巨大的多端开发成本。

如果团队能够实现这样一个脚手架： **以微信小程序为基础，将微信小程序的代码平滑转换为各端小程序，岂不大幅提高开发效率？**

可是技术方案上，应该如何实现呢？受 [cantonjs](https://github.com/cantonjs)
启发，我们团队打造了一款跨多端小程序脚手架，其 **基本原理** 正是以 webpack
开发架构为基础，对于微信小程序的规范化打包，以及不同平台的差异化编译，主要依靠自定义实现 webpack loader 和 webpack plugin
来填平。

在这套脚手架基础上，开发者可以选择任何一套小程序源代码（基于微信小程序/支付宝小程序/百度小程序）来开发多端小程序。脚手架支持自动编译 wxml
文件（微信小程序）为 axml 文件（支付宝小程序）或 swan 文件（百度小程序），能够转换基础平台 API： wx（微信小程序核心对象） 为
my（支付宝小程序核心对象） 或 swan（百度小程序核心对象），反之亦然。对于个别接口在平台上的天生差异，开发者可以通过 `__WECHAT__` 或
`__ALIPAY__` 或 `__BAIDU__` 来动态处理。

具体细节，我们可以通过 DefinePlugin 这个 webpack 内置插件在 webpack 编译阶段注册全局变量： `__WECHAT__` 或
`__ALIPAY__` 或 `__BAIDU__`。

    
    
    new webpack.DefinePlugin({
      // Definitions...
    })
    

通过 webpack loader 使 webpack 能编译或处理 *.wxml 上引用的文件，并将原 App 中的 API 进行转换，使用方式与正常的
webpack 配置 loader 完全相同：

    
    
    {
      test: /\.wxml$/,
      include: /src/,
      use: [
        {
          loader: 'file-loader',
          options: {
            name: '[name].[ext]',
            useRelativePath: true,
            context: resolve('src'),
          },
        },
        {
          loader: 'mini-program-loader',
          options: {
            root: resolve('src'),
            enforceRelativePath: true,
          },
        },
      ],
    }
    

注意，我们声明 loader 的顺序表明先通过 mini-program-loader 处理，其结果交给 file-loader 处理。mini-
program-loader 的实现并不复杂，我们通过 [sax.js](https://www.npmjs.com/package/sax) 解析
wxml （XML 风格）文件，进行 API 转换。sax.js 是解析 XML 或者 HTML
的基础库，正好适用于我们各端小程序的主文档文件（wxml、swan、axml）。

通过 webpack-plugin 插件实现自动分析 ./app.js 入口文件，并智能打包，同时抹平 API 差异。

    
    
    import MiniProgramWebpackPlugin from 'mini-program-webpack-plugin'
    export default {
      // ...configs,
      plugins: [
        // ...other,
        new MiniProgramWebpackPlugin(options)
      ],
    }
    

在这两个 loader 和 plugin 的基础上，我们实现的这个脚手架构建，通过 script 脚本，启动不同目标的小程序平台编译：yarn
start、yarn start:alipay、yarn start:baidu，同时开发者可以根据自身项目特点，添加 prettier 和 lint
标准等。

到此，一个基于 webpack、webpack loader、webpack plugin 的脚手架综合应用从场景到实现已经简要介绍完毕。

通过这个案例，我们发现 webpack 的能力边界是无穷的，以高级前端工程师为目标的程序员，应该尽最大努力来开发 webpack 的潜能。

### 总结

正如本课程的标题所示： **webpack 工程师 > 前端工程师**。 webpack 要求的不仅仅是“配置工程师”那么简单，其后蕴含的 Node.js
知识、AST
知识、架构设计、代码设计原则等非常值得玩味。我们不应该畏难，社区为我们提供了大量的开箱即用工具，借助这些工具，希望大家能够掌握这方面的知识，并在此基础上运用自如。

课程代码仓库：<https://github.com/HOUCe/lucas-gitchat-courses>

### 分享交流

请大家留言分享自己开发实践中「前端工程化」相关的趣事。阅读文章过程中有任何疑问随时可以跟其他小伙伴讨论，或者直接向作者 LucasHC
提问（作者看到后会抽空解答）。 **你的分享不仅帮助他人，更会提升自己。**

你也可以说说自己最想了解的主题，课程内容会根据部分读者的意见和建议迭代和完善。

此外，我们为本课程付费读者创建了《前端开发核心知识进阶》微信交流群，以方便更有针对性地讨论课程相关问题。（入群请到第1-2课末尾扫描二维码，若失效请加
GitChat 小助手伽利略的微信，ID 为 GitChatty6，注明「前端核心」。）



## 前端工程化背后的项目组织设计（上）

通过上一节的学习，我们看到了前端构建工具及其背后蕴含的技术设计。前端工程化包罗万象，本节课，我们将分析项目组织设计的相关话题，包括：

![](https://images.gitbook.cn/a8f63cd0-4ece-11e9-aba8-d90fcdb25340)

接下来，我们通过 2 节内容来学习这个主题。希望结束这个主题后大家可以从更高的视角看待项目管理和代码组织设计。

### 大型前端项目的组织设计

随着业务复杂度的直线上升，前端项目不管是从代码量上，还是从依赖关系上都爆炸式增长。同时，
**团队中一般不止有一个业务项目，多个项目之间如何配合，如何维护相互关系？公司自己的公共库版本如何管理？这些话题随着业务扩展，纷纷浮出水面**
。一名合格的高级前端工程师，在宏观上必需能妥善处理这些问题。

当然，不是每个开发者都有机会接触项目设计。如果读者没有面对过上述难题，也许并不容易理解这些问题究竟意味着什么。举个例子，团队主业务项目名为：App-
project，这个仓库依赖了组件库：Component-lib，因此 App-project 项目的 package.json 会有类似的代码：

    
    
    {
        "name": "App-project",
        "version": "1.0.0",
        "description": "This is our main app project",
        "main": "index.js",
        "scripts": {
            "test": "echo \\"Error: no test specified\\" && exit 1"
        },
        "dependencies": {
            "Component-lib": "^1.0.0"
        }
    }
    

这时新的需求来了，产品经理需要更改 Component-lib 组件库中的 modal 组件样式及交互行为。作为开发者，我们需要切换到 Component-
lib 项目，进行相关需求开发，开发完毕后进行测试。这里的测试包括 Component-lib
当中的单元测试，当然也包括在实际项目中进行效果验收。为方便调试，有经验的开发者也许会使用 npm link/yarn link
来开发和调试效果。当确认一切没问题后，我们还需要 npm 发包 Component-lib 项目，并提升版本为
1.0.1。在所有这些都顺利完成的基础上，才能在 App-project 项目中进行升级：

    
    
    {
        //...
        "dependencies": {
            "Component-lib": "^1.0.1"
        }
    }
    

这个过程已经比较复杂了。如果中间环节出现任何纰漏，我们都要重复上述所有步骤。另外，这只是单一依赖关系，现实中 App-project 不可能只依赖
Component-lib。这种项目管理的方式无疑是低效且痛苦的。那么在项目设计哲学上，有更好的方式吗？

#### monorepo 和 multirepo

**答案是肯定的，管理组织代码的方式主要分为两种：**

  * multirepo
  * monorepo

顾名思义，multirepo 就是将应用按照模块分别在不同的仓库中进行管理，即上述 App-project 和 Component-lib
项目的管理模式；而 monorepo
就是将应用中所有的模块一股脑全部放在同一个项目中，这样自然就完全规避了前文描述的困扰，不需要单独发包、测试，且所有代码都在一个项目中管理，一同部署上线，在开发阶段能够更早地复现
bug，暴露问题。

这就是项目代码在组织上的不同哲学： **一种倡导分而治之，一种倡导集中管理**
。究竟是把鸡蛋放在同一个篮子里，还是倡导多元化，这就要根据团队的风格以及面临的实际场景进行选型。

我试着从 multirepo 和 monorepo 两种处理方式的 **弊端说起** ，希望给读者更多的参考和建议。

**multirepo 存在以下问题：**

  * 开发调试以及版本更新效率低下
  * 团队技术选型分散，不同的库实现风格可能存在较大差异（比如有的库依赖 Vue，有的依赖 React）
  * changelog 梳理困难，issues 管理混乱（对于开源库来说）

**而 monorepo 缺点也非常明显：**

  * 库体积超大，目录结构复杂度上升
  * 需要使用维护 monorepo 的工具，这就意味着学习成本比较高

清楚了不同项目组织管理的缺点，我们再来看一下社区上的经典选型案例。

Babel 和 React 都是典型的 monorepo，其 issues 和 pull requests 都集中到唯一的项目中，changelog
可以简单地从一份 commits 列表梳理出来。我们参看 React 项目仓库，从目录结构即可看出其强烈的 monorepo 风格：

    
    
    react-16.2.0/
      packages/
        react/
        react-art/
        react-.../
    

因此，[react](https://www.npmjs.com/package/react) 和 [react-
dom](https://www.npmjs.com/package/react-dom) 在 npm 上是两个不同的库，它们只不过在 React
项目中通过 monorepo 的方式进行管理。至于为什么 react 和 react-dom 是两个包，我把这个问题留给读者。

而著名的 Rollup 目前是 multirepo 方式。对于 monorepo 和 multirepo，选择了 monorepo 的 Babel
贡献了文章：[Why is Babel a
monorepo?](https://github.com/babel/babel/blob/master/doc/design/monorepo.md)，
其中提到：

**monorepo 的优势：**

  * 所有项目拥有一致的 lint，以及构建、测试、发布流程
  * 不同项目之间容易调试、协作
  * 方便处理 issues
  * 容易初始化开发环境
  * 易于发现 bug

**monorepo 的劣势：**

  * 源代码不易理解
  * 项目体积过大

这些分析与我们前文提到的类似。但是，从业内技术发展来看，monorepo 目前越来越受欢迎。了解了 monorepo 的利弊，我们应该如何实现
monorepo 呢？

### 使用 Lerna 实现 monorepo

Lerna 是 Babel 管理自身项目并开源的工具，官网对 Lerna 的定位非常简单直接：

> A tool for managing JavaScript projects with multiple packages.

我们来建立一个简单的 demo，首先安装依赖，并创建项目：

    
    
    mkdir new-monorepo && cd new-monorepo
    npm init -y
    npm i -g lerna（有需要的话要 sudo）
    git init new-monorepo
    lerna init
    

成功后，Lerna 会在 new-monorepo 项目下自动添加以下三个文件目录：

  * packages
  * lerna.json
  * package.json

我们添加第一个项目 module-1：

    
    
    cd packages
    mkdir module-1
    cd module-1
    npm init -y
    

这样，我们在 ./packages 目录下新建了第一个项目：module-1，并在 module-1 中添加了一些依赖，模拟更加真实的场景。同样的方式，建立
module-2 以及 module-3。

此时，读者可以自行观察 new-monorepo 项目下的目录结构为：

    
    
    packages/
      module-1/
        package.json
      module-2/
        package.json
      module-3/
        package.json
    

接下来，我们退到主目录下，安装依赖：

    
    
    cd ..
    lerna bootstrap
    

关于该命令的作用，官网直述为：

> Bootstrap the packages in the current Lerna repo. Installs all of their
dependencies and links any cross-dependencies.

>

> 也就是说，假设我们在 module-1 项目中添加了依赖 module-2，那么执行 lerna bootstrap 命令后，会在 module-1
项目的 node_modules 下创建软链接直接指向 module-2 目录。也就是说 lerna bootstrap 命令会建立整个项目内子 repo
之间的依赖关系，这种建立方式不是通过“硬安装”，而是通过软链接指向相关依赖。

Linux 中关于硬链接和软链接的区别，可以参考文章：[linux
硬链接与软链接](https://www.cnblogs.com/crazylqy/p/5821105.html)。

在正确连接了 Git 远程仓库后，我们可以发布：

    
    
    lerna publish
    

这条命令将各个 package 一步步发布到 npm 当中。Lerna 还可以支持自动生成 changelog 等功能。这里我们不再统一介绍。

到这里，你可能觉得 Lerna 还挺简单。但其实里面还是有更多学问，比如 Lerna 支持下面两种模式。

  * **Fixed/Locked 模式**

Babel 便采用了这样的模式。这个模式的特点是，开发者执行 lerna publish 后，Lerna 会在 lerna.json 中找到指定
version 版本号。如果这一次发布包含某个项目的更新，那么会自动更新 `version`
版本号。对于各个项目相关联的场景，这样的模式非常有利，任何一个项目大版本升级，其他项目的大版本号也会更新。

  * **Independent 模式**

不同于 Fixed/Locked 模式，Independent
模式下，各个项目相互独立。开发者需要独立管理多个包的版本更新。也就是说，我们可以具体到更新每个包的版本。每次发布，Lerna 会配合
Git，检查相关包文件的变动，只发布有改动的 package。

开发者可以根据团队需求进行模式选择。

我们也可以使用 Lerna 安装依赖，该命令可以在项目下的任何文件夹中执行：

    
    
    lerna add dependencyName
    

Lerna 默认支持 hoist 选项，即默认在 lerna.json 中：

    
    
    { bootstrap: { hoist: true } }
    

这样项目中所有的 package 下 package.json 都会出现 dependencyName 包：

    
    
      packages/
      module-1/
        package.json(+ dependencyName)
        node_modules
      module-2/
        package.json(+ dependencyName)
        node_modules
      module-3/
        package.json(+ dependencyName)
        node_modules
      node_modules
           dependencyName
    

这种方式，会在父文件夹的 node_modules 中高效安装 dependencyName（Node.js 会向上在祖先文件夹中查找依赖）。对于未开启
hoist 的情况，执行 lerna add 后，需要执行：

    
    
    lerna bootstrap --hoist
    

如果我们想有选择地升级某个依赖，比如只想为 module-1 升级 dependencyName 版本，可以使用 scope 参数：

    
    
    lerna add dependencyName --scope=module-1
    

这时候 module-1 文件夹下会有一个 node_modules，其中包含了 dependencyName 的最新版本。

### 分析一个项目迁移案例

**接下来，我选取一个正在线上运行的 multirepo 项目，并演示使用 Lerna 将其迁移到 monorepo 的过程** 。此案例来自
[mitter.io](http://mitter.io/)，该团队以往一直以 multirepo 的形式维护以下几个项目：

  * @mitter-io/core，mitter.io SDK 核心基础库
  * @mitter-io/models，TypeScript models 库
  * @mitter-io/web，Web 端 SDK 应用
  * @mitter-io/react-native，React Native 端 SDK 应用
  * @mitter-io/node，Node.js 端 SDK 应用
  * @mitter-io/react-scl，React.js 组件库

#### 背景介绍

项目使用 TypeScript 和 Rollup 工具，以及 TypeDoc 生成规范化文档。在使用 Lerna 做 monorepo
化之前，这样的技术方案带来的困扰显而易见，我们来分析一下当前技术栈的弊端，以及 monorepo 化能为这些项目带来哪些收益。

  * 如果 @mitter-io/core 中出现任何一处改动，其他所有的包都需要升级到 @mitter-io/core 最新版本，不管这些改动是 feature 还是 bug fix，成本都比较大
  * 如果所有这些包能共同分享版本，那么带来的收益也是非常巨大的
  * 这些不同的仓库之间，由于技术栈近似，一些构建脚本大体相同，部署流程也都一致，如果能够将这些脚本统一抽象，也将带来便利

#### 迁移步骤

我们运用 Lerna 构建 monorepo 项目，第一步：

    
    
    mkdir my-new-monorepo && cd my-new-monorepo
    git init .
    lerna init
    

不同于之前的示例，这是从现有项目中导入，因此我们可以使用命令：

    
    
    lerna import ~/projects/my-single-repo-package-1 --flatten
    

这行命令不仅可以导入项目，同时也会将已有项目中的 git commit 一并搬迁过来。我们可以放心地在新 monorepo 仓库中使用 git blame
来进行回溯。

如此一来，得到了这样的项目结构：

    
    
    packages/
      core/
      models/
      node/
      react-native/
      web/
    lerna.json
    package.json
    

接下来，运行熟悉的：

    
    
    lerna boostrap
    lerna publish
    

进行依赖维护和发布。注意并不是每次都需要执行 lerna bootstrap，只需要在第一次切换到项目，安装所有依赖时运行。

对于每一个 package 来说，其 pacakge.json 文件中都有以下雷同的 npm script 声明。

    
    
    "scripts": {
        ...
        "prepare": "yarn run build",
        "prepublishOnly": "./../../ci-scripts/publish-tsdocs.sh",
        ...
        "build": "tsc --module commonjs && rollup -c rollup.config.ts && typedoc --out docs --target es6 --theme minimal --mode file src"
    }
    

受益于 monorepo，所有项目得以集中管理在一个仓库中，这样我们将所有 package 公共的 npm 脚本移到 ./scripts 文件中。在单一的
monorepo 项目里，我们就可以在不同 package 之间共享构建脚本了 。

运行公共脚本时，有时候有必要知道当前运行的项目信息。npm 是能够读取到每个 package.json 信息的。因此，对每个 package，在其
package.json 中添加以下信息：

    
    
    {
        "name": "@mitter-io/core",
        "version": "0.6.28",
        "repository": {
            "type": "git"
        }
    }
    

之后，如下变量都可以被 npm script 使用：

    
    
    npm_package_name = @mitter-io/core
    npm_package_version = 0.6.28
    npm_package_repository_type = git
    

#### 流程优化

团队中正常的开发流程是每个程序员新建一个 git branch，通过代码审核之后进行合并。整套流程在 monorepo 架构下变得非常清晰，我们来梳理一下。

  * step1：当开发完成后，我们计划进行版本升级，只需要运行：lerna version
  * step2：Lerna 会提供交互式 prompt，对下一版本进行序号升级

    
    
        lerna version --force-publish
        lerna notice cli v3.8.1
        lerna info current version 0.6.2
        lerna info Looking for changed packages since v0.6.2
        ? Select a new version (currently 0.6.2) (Use arrow keys)
        ❯ Patch (0.6.3)
        Minor (0.7.0)
        Major (1.0.0)
        Prepatch (0.6.3-alpha.0)
        Preminor (0.7.0-alpha.0)
        Premajor (1.0.0-alpha.0)
        Custom Prerelease
        Custom Version
    

新版本被选定之后，Lerna 会自动改变每个 package 的版本号，在远程仓库中创建一个新的 tag，并将所有的改动推送到 GitLab 实例当中。

接下来，CI 构建实际上只需要两步：

  * Build 构建
  * Publish 发布

构建实际就是运行：

    
    
    lerna bootstrap
    lerna run build
    

而发布也不复杂，需要执行：

    
    
    git checkout master
    lerna bootstrap
    git reset --hard
    lerna publish from-package --yes
    

注意，这里我们使用了 lerna publish from-package，而不是简单的 lerna publish。因为开发者在本地已经运行了 lerna
version，这时候再运行 lerna publish 会收到“当前版本已经发布”的提示。而 from-package 参数会告诉 Lerna
发布所有非当前 npm package 版本的项目。

通过这个案例，我们了解了 Lerna 构建 monorepo 的经典套路，Lerna 还封装了更多的 API 来支持更加灵活的 monorepo
的创建，感兴趣的读者可以自行研究，欢迎在评论区留言讨论，或者直接向我提问。个人认为，未来 monorepo 和 multirepo
将会持续并存，每个开发者都应该根据项目特点来进行选择。

到此，我们分析了 multirepo 和 monorepo 方案的各自特点，通过实例和项目迁移了解了如何构建 monorepo
项目。但是，项目组织不光这些内容，下一节我们将讨论依赖关系这一话题。

### 总结

monorepo 目前来看是一个流行趋势，笔者为项目团队引入了 monorepo 的架构方案之后收益非常明显，我们也是国内最早采用 monorepo
架构的团队之一。

但是这篇课程难以做到面面俱到，并且任何一个项目都有自己的独立性和特殊性，究竟该如何组织调配、生产部署，需要每一个开发者开动脑筋。

比如：monorepo
方式会导致整个项目体积变大，在上线部署时，用时更长，甚至难以忍受。在工程中如何解决这类问题？针对于此，我设计了增量部署构建方案，通过分析项目依赖以及拓扑排序，优化项目编译构建，这里不再多做介绍。

如果对工程化话题格外感兴趣的读者较多，我会专门进行讲解。希望大家一起讨论。

### 分享交流

请大家留言分享自己开发实践中「项目组织」相关的难忘事件，你可以继续学习下一节等全部完结这个主题之后再分享。阅读文章过程中有任何疑问随时可以跟其他小伙伴讨论，或者直接向作者
LucasHC 提问（作者看到后会抽空解答）。 **你的分享不仅帮助他人，更会提升自己。**

同时，欢迎说说自己最想了解的主题，课程内容会根据大家的意见和建议迭代和完善。

此外，我们为本课程付费读者创建了《前端开发核心知识进阶》微信交流群，以方便更有针对性地讨论课程相关问题。（入群请到第1-2课末尾扫描二维码，若失效请加
GitChat 小助手伽利略的微信，ID 为 GitChatty6，注明「前端核心」。）



## 前端工程化背后的项目组织设计（下）

承接上一节的内容，本节来继续学习前端工程化中依赖关系相关的内容。在此之前，先回顾一下「项目组织」主题的知识点：

![](https://images.gitbook.cn/882d8aa0-b7f4-11e9-94c3-45f5496127b0)

说到项目中的依赖关系，我们往往会想到使用 yarn/npm 解决依赖问题。依赖关系大体上可以分为：

  * 嵌套依赖
  * 扁平依赖

项目中，我们引用了三个包：PackageA、PackageB、PackageC， 它们都依赖了 PackageD 的不同版本。那么在安装时，如果
PackageA、PackageB、PackageC 在各自的 node_modules 目录中分别含有 PackageD，那么我们将其理解为嵌套依赖：

    
    
    PackageA
        node_modules/PackageD@v1.1
    PackageB
        node_modules/PackageD@v1.2
    PackageC
        node_modules/PackageD@v1.3
    

如果在安装时，先安装了 PackageA，那么 PackageA 依赖的 PackageD 版本成为主版本，它和
PackageA、PackageB、PackageC 一起平级出现，我们认为这是扁平依赖。此时 PackageB、PackageC 各自的
node_modules 目录中也含有各自的 PackageD 版本：

    
    
    PackageA
    PackageD@v1.1
    PackageB
        node_modules/PackageD@v1.2
    PackageC
        node_modules/PackageD@v1.3
    

npm 在安装依赖包时，会将依赖包下载到当前的 node_modules 目录中。对于嵌套依赖和扁平依赖的话题，npm 给出了不同的处理方案：npm3
以下版本在依赖安装时，非常直接，它会按照包依赖的树形结构下载到本地 node_modules 目录中，也就是说，每个包都会将该包的依赖放到当前包所在的
node_modules 目录中。

这么做的原因可以理解：它考虑到了包依赖的版本错综复杂的问题，同一个包因为被依赖的关系原因会出现多个版本，保证树形结构的安装能够简化和统一对于包的安装和删除行为。这样能够简单地解决多版本兼容问题，可是也带来了较大的冗余。

npm3 则采用了扁平结构，但是更加智能。在安装时，按照 package.json 里声明的顺序依次安装包，遇到新的包就把它放在第一级
node_modules 目录。后面再进行安装时，如果遇到一级 node_modules
目录已经存在的包，那么会先判断包版本，如果版本一样则跳过安装，否则会按照 npm2 的方式安装在树形目录结构下。

npm3 这种安装方式只能够 **部分解决** 问题，比如：项目里依赖模块 PackageA、PackageB、PackageC、PackageD, 其中
PackageC、PackageB 依赖模块 PackageD v2.0，A 依赖模块 PackageD v1.0。那么可能在安装时，先安装了
PackageD v1.0，然后分别在 PackageC、PackageB 树形结构内部分别安装 PackageD
v2.0。这也是一定程度的冗余。为了解决这个问题，因此也就有了 npm dedupe 命令。

npm 和 yarn 的内容足以单独开讲，我们这里不再展开。

另外，为了保证同一个项目中不同团队成员安装的版本依赖相同，我们往往使用 package-lock.json 或 yarn-lock.json 这类文件通过
git 上传以共享。在安装依赖时，依赖版本将会锁定。

这些内容与开发息息相关，但是往往被开发者所忽视。依赖问题说小很小，说复杂却也很复杂，我们再来看一个循环依赖的问题。

### 复杂依赖关系分析和处理

前端项目，安装依赖非常简单：

    
    
    npm install / yarn add
    

安装一时爽，而带来的依赖关系慢慢地会让人头大。依赖关系的复杂性带来的主要副作用有就是 **循环依赖** 。

这里我们来重点说一下。简单来说，循环依赖就是模块 A 和模块 B 相互引用，在不同的模块化规范下，对于循环依赖的处理不尽相同。

Node.js 中，我们制造一个简单的循环引用场景。

模块 A：

    
    
    exports.loaded = false
    const b = require('./b')
    module.exports = { 
        bWasLoaded: b.loaded, 
        loaded: true 
    }
    

模块 B：

    
    
    exports.loaded = false
    const a = require('./a')
    module.exports = { 
        aWasLoaded: a.loaded, 
        loaded: true 
    }
    

在 index.js 中调用：

    
    
    const a = require('./a');
    const b = require('./b') 
    console.log(a)
    console.log(b)
    

这种情况下，并未出现死循环崩溃的现象，而是输出：

    
    
    { bWasLoaded: true, loaded: true }
    { aWasLoaded: false, loaded: true }
    

**原因是模块加载过程的缓存机制：Node.js 对模块加载进行了缓存** 。按照执行顺序，第一次加载 a 时，走到 const b =
require('./b')，这样直接进入模块 B 当中，此时模块 B 中 const a = require('./a')，模块 A 已经被缓存，因此模块
B 返回的结果为：

    
    
    {
        aWasLoaded: false,
        loaded: true
    }
    

模块 B 加载完成，回到模块 A 中继续执行，模块 A 返回的结果为：

    
    
    {
        aWasLoaded: true,
        loaded: true
    }
    

据此分析，我们不难理解最终的打印结果。也可以总结为：

Node.js，或者 CommonJS
规范，得益于其缓存机制，在遇见循环引用时，程序并不会崩溃。但这样的机制，仍然会有问题：它只会输出已执行部分，对于未执行部分，export 内容为
undefined。

**ES 模块化与 CommonJS 规范不同，ES 模块不存在缓存机制，而是动态引用依赖的模块。**

[《Exploring ES6》](http://exploringjs.com/es6/ch_modules.html)
一文中的示例很好地阐明了这样的行为：

    
    
    //------ a.js ------
    import {bar} from 'b'; // (i)
    export function foo() {
        bar(); // (ii)
    }
    
    //------ b.js ------
    import {foo} from 'a'; // (iii)
    export function bar() {
        if (Math.random()) {
            foo(); // (iv)
        }
    }
    

这样的代码，如果在 commonJS 规范中：

    
    
    //------ a.js ------
    var b = require('b');
    function foo() {
        b.bar();
    }
    exports.foo = foo;
    
    //------ b.js ------
    var a = require('a');
    function bar() {
        if (Math.random()) {
            a.foo();
        }
    }
    exports.bar = bar;
    

如果模块 a.js 先被执行，a.js 依赖 b.js，在 b.js 中，因为 a.js 此刻还并没有暴漏出任何内容，因此如果在 b.js 中，对于顶层
a.foo() 的调用，会得到报错。但是如果 a.js 模块执行完毕后，再调用 b.bar()，b.bar() 当中的 a.foo() 可以正常运行。

但是这样的方式的局限性：

如果 a.js 采用 module.exports = function () { ··· } 的方式，那么 b.js 当中的 a
变量在赋值之后不会二次更新。

ESM 不会存在这样的局限性。ESM 加载的变量，都是动态引用其所在的模块。只要引用是存在的，代码就能执行。回到：

    
    
    //------ a.js ------
    import {bar} from 'b'; // (i)
    export function foo() {
        bar(); // (ii)
    }
    
    //------ b.js ------
    import {foo} from 'a'; // (iii)
    export function bar() {
        if (Math.random()) {
            foo(); // (iv)
        }
    }
    

代码，第 ii 行和第 iv 行，bar 和 foo 都指向原始模块数据的引用。ESM 的设计目的之一就是支持循环引用。

**ES 的设计思想是：尽量静态化，这样在编译时就能确定模块之间的依赖关系。这也是 import 命令一定要出现在模块开头部分的原因。在模块中，import
实际上不会直接执行模块，而是只生成一个引用。在模块内真正引用依赖逻辑时，再到模块里取值** 。这样的设计非常有利于 tree shaking
技术的实现，我们在《深入浅出模块化相关话题（含 tree shaking）》课程中继续展开。

在工程实践中，循环引用的出现往往是由设计不合理造成的。如果使用 webpack 进行项目构建，可以使用 webpack 插件 [circular-
dependency-plugin](https://www.npmjs.com/package/circular-dependency-plugin)
来帮助检测项目中存在的所有循环依赖。循环依赖这个问题说大不大，说小不小，我们应该尽可能在设计源头规避。

另外复杂的依赖关系还会带来以下等问题：

  * 依赖版本不一致
  * 依赖丢失

针对此，需要开发者根据真实情况进行处理，同时，合理使用 npm/yarn 工具，也能起到非常关键的作用。

笔者团队中通过：

    
    
    "scripts": {
        // ...
        "analyzeDeps": "scripts analyzeDeps",
        "graph": "scripts graph",
        // ...
    }
    

即

    
    
    yarn run analyzeDeps
    

来对依赖进行分析。具体流程是 analyzeDeps 脚本会对依赖版本冲突和依赖丢失的情况进行处理，这个过程依赖 missingDepsAnalyze 和
versionConflictsAnalyze 两个任务：

其中 missingDepsAnalyze 依赖
[depcheck](https://www.npmjs.com/package/depcheck)，depcheck
可以找出哪些依赖是没有用到的，或者对比 package.json 声明中缺少的依赖项。

同时 missingDepsAnalyze 会读取 lerna.json 配置，获得项目中所有 package，接着对所有 package 中的
package.json 进行遍历，检查是否存在相关依赖，如果不存在则自动执行 yarn add XXXX 进行安装。

versionConflictsAnalyze 任务类似，只不过在获得每个 package 的 package.json
中定义的依赖之后，检查同一个依赖是否有重复声明且存在版本不一致的情况。对于版本冲突，采用交互式命令行，让开发者选择正确的版本。 ​  
相关代码并不难实现，感兴趣的读者可以在评论区交流或者向我提问，出于隐私原因，这里不再贴出。

### 使用 yarn workspace 管理依赖关系

monorepo 项目中依赖管理问题值得重视。现在我们来看一下非常流行的 yarn workspace 如何处理这种问题。

workspace 的定位为：

> It allows you to setup multiple packages in such a way that you only need to
run yarn install once to install all of them in a single pass.

翻译过来，workspace 能帮助你更好地管理有多个子 package 的 monorepo。开发者既可以在每个子 package 下使用独立的
package.json 管理依赖，又可以享受一条 yarn 命令安装或者升级所有依赖的便利。

引入 workspace 之后，在根目录执行：

    
    
    yarn install / yarn updrade XX
    

所有的依赖都会被安装或者更新。

当然，如果只想更新某一个包内的版本，可以通过以下代码完成：

    
    
    yarn workspace <workspace-name> upgrade XX
    

在使用 yarn 的项目中，如果想使用 yarn workspace，我们不需要安装其他的包，只要简单更改 package.json 便可以工作：

    
    
    // package.json
    {
      "private": true,
      "workspaces": ["workspace-1", "workspace-2"]
    }
    

需要注意的是， **如果需要启用 workspace，那么这里的 private 字段必须设置成 true。** 同时 workspaces
这个字段值对应一个数组，数组每一项是个字符串，表示一个 workspace（可以理解为一个 repo）。

接着，我们可以在 workspace-1 和 workspace-2 项目中分别添加 package.json 内容：

    
    
    {
      "name": "workspace-1",
      "version": "1.0.0",
    
      "dependencies": {
        "react": "16.2.3"
      }
    }
    

以及：

    
    
    {
      "name": "workspace-2",
      "version": "1.0.0",
    
      "dependencies": {
        "react": "16.2.3",
        "workspace-1": "1.0.0"
      }
    }
    

执行 yarn install 之后，发现项目根目录下的 node_modules 内已经包含所有声明的依赖，且各个子 package 的
node_modules 里面不会重复存在依赖，只会有针对根目录下 node_modules 中的 React 引用。

我们发现，yarn workspace 跟 Lerna 有很多共同之处，解决的问题也部分重叠。 **下面我们对比一下 workspace 和
Lerna。**

  * yarn workspace 寄存于 yarn，不需要开发者额外安装工具，同时它的使用也非常简单，只需要在 package.json 中进行相关的配置，不像 Learn 那样提供了大量 API
  * yarn workspace 只能在根目录中引入，不需要在各个子项目中引入

**事实上，Lerna 可以与 workspace 共存，搭配使用能够发挥更大作用。在我们团队中：Lerna 负责版本管理与发布，依靠其强大的 API
和设置，做到灵活细致；workspace 负责依赖管理，整个流程非常清晰。**

在 Lerna 中使用 workspace，首先需要修改 lerna.json 中的设置：

    
    
    {
        ...
        "npmClient": "yarn",
        "useWorkspaces": true,
        ...
    }
    

然后将根目录下的 package.json 中的 workspaces 字段设置为 Lerna 标准 packages 目录：

    
    
    {
      ...
      "private": true,
      "workspaces": [
        "packages/*"
      ],
      ...
    }
    

注意：如果我们开启了 workspace 功能，lerna.json 中的 packages 值便不再生效。原因是 Lerna 会将
package.json 中 workspaces 中所设置的 workspaces 数组作为 lerna packages 的路径，也就是各个子 repo
的路径。换句话说，Lerna 会优先使用 package.json 中的 workspaces 字段，在不存在该字段的情况下，再使用 lerna.json
中的 packages 字段。如果未开启 workspace 功能，lerna.json 配置为：

    
    
    {
      "npmClient": "yarn",
      "useWorkspaces": false,
      "packages": [
        "packages/11/*",
        "packages/12/*"
      ]
    }
    

根目录下的 package.json 配置为：

    
    
    {
        "private": true,
        "workspaces": [
          "packages/21/*",
          "packages/22/*",
        ],
          ...
    }
    

那么这就意味着使用 yarn 管理的是 package.json 中 workspaces 所对应的项目路径下的依赖：`packages/21/*` 以及
`packages/22/*`。而 Leran 管理的是 lerna.json 中 packages 所对应的 `packages/11/*` 以及
`packages/12/*` 的项目。

### 总结

本节主要抛出了大型前端项目的组织选型问题，着重分析了 monorepo
方案，内容注重实战。对于大型代码库的组织，本节梳理出一条完善的工作流程。找到适合自己团队的风格，是一名合格的开发者所需要具备的技能。

但是关于 npm 和 yarn 以及所牵扯出的依赖问题、monorepo
设计问题仍然将是挑战，其中的话题仍然值得深挖和系统展开。具体工程化项目的代码组织选型和设计，开发者一定要通过动手来理解。在此学习过程中，有任何疑问和想法，都欢迎与我交流，也希望能有更多机会和大家交流。

### 分享交流

请大家留言分享自己开发实践中「项目组织」相关的难忘事件。阅读文章过程中有任何疑问随时可以跟其他小伙伴讨论，或者直接向作者 LucasHC
提问（作者看到后抽空解答）。 **你的分享不仅帮助他人，更会提升自己。**

你也可以说说自己最想了解的主题，课程内容会根据部分读者的意见和建议迭代和完善。

此外，我们为本课程付费读者创建了《前端开发核心知识进阶》微信交流群，以方便更有针对性地讨论课程相关问题。（入群请到第1-2课末尾扫描二维码，若失效请加
GitChat 小助手伽利略的微信，ID 为 GitChatty6，注明「前端核心」。）



## 代码规范工具及背后技术设计（上）

不管是团队的扩张还是业务的发展，都会导致项目代码量出现爆炸式增长。为了防止“野蛮生长”现象，我们需要有一个良好的技术选型和成熟的架构做支撑，也需要团队中每一个开发者都能用心维护项目。在此方向上除了人工
code review 以外，相信大家对于一些规范工具并不陌生。

作为一名前端工程师， **在使用现代化工具的基础上，如何尽可能发挥其能量？在必要的情况下，如何开发适合自己团队需求的工具？**
本节将围绕这些问题展开，我们重点分析：

![](https://images.gitbook.cn/725e5a90-4ec9-11e9-b0b8-a9c8a3696845)

接下来，我们通过 2 节内容来学习这个主题。

### 自动化工具巡礼

现代前端开发，“武器”都已经非常自动化了。不同工具分工不同，我们的目标是合理结合各种工具，打造一条完善的自动化流水线，以高效率、低投入的方式，为我们的代码质量提供有效保障。

#### prettier

首先从 prettier 说起，英文单词 prettier 是 pretty 的比较级，pretty 译为“漂亮、美化”。顾名思义，prettier
这个工具能够美化我们的代码，或者说格式化、规范化代码，使其更加工整。它一般不会检查我们代码具体的写法，而是在“可读性”上做文章。目前支持包括
JavaScript、JSX、Angular、Vue、Flow、TypeScript、CSS（Less、SCSS）、JSON
等多种语言、数据交换格式、语法规范扩展。总结一下，它能够将原始代码风格移除，并替换为团队统一配置的代码风格。虽然几乎所有团队都在使用这款工具，不过我们还是简单分析一下使用它的原因吧：

  * 构建并统一代码风格
  * 帮助团队新成员快速融入团队
  * 开发者可以完全聚焦业务开发，不必在代码整理上花费过多心思
  * 方便低成本灵活接入，并快速发挥作用
  * 清理并规范已有代码
  * 减少潜在 Bug
  * 丰富强大的社区支持

我们来看一个从零开始的简单 demo，首先创建一个项目（该 demo 引用自系列文章 [Prettier-Eslinst-Editor-Config-
Article](https://gist.github.com/adeelibr/3d71c39436fc0d9721330d0b66a5790c)）：

    
    
    mkdir prettier-demo && cd prettier-demo
    

进行项目初始化：

    
    
    yarn init -y
    

安装依赖：

    
    
    yarn add prettier --dev --exact
    

在 package.json 中加入 script：

    
    
    {
        "name": "prettier-demo",
        "version": "1.0.0",
        "scripts": {
            "prettier": "prettier --write src/index.js"
        },
    }
    

prettier --write src/index.js 意思是运行 prettier，并对 src/index.js 文件进行处理：--write
标识告诉 prettier 要把格式化好的内容保存到当前文件中。

我们在 ./src 目录中新建 index.js 文件，键入一些格式缺失的代码：

    
    
        let person = {
                name: "Yoda",
        designation: 'Jedi Master '
        }
    
            function trainJedi (jediWarrion) {
          if (jediWarrion.name === 'Yoda') {
           console.log('No need! already trained')
          }
        console.log(`Training ${jediWarrion.name} complete`)
        }
    
                    trainJedi(person)
        trainJedi({ name: 'Adeel',  designation: 'padawan'})
    

同时在根文件中创建 prettier.config.js 文件，添加 prettier 规则：

    
    
    module.exports = {
        printWidth: 100,
        singleQuote: true,
        trailingComma: 'all',
        bracketSpacing: true,
        jsxBracketSameLine: false,
        tabWidth: 2,
        semi: true,
    }
    

prettier 读取这些规则 ，并按照以上规则配置美化代码。对于这些规则，我们看其命名便能理解大概，更多内容留给大家去官网寻找。

现在运行：

    
    
    yarn prettier
    

代码就会自动被格式化了。

当然，prettier 也可以与编辑器结合，在开发者保存后立即进行美化，也可以集成到 CI 环境中，或者 git pre-commit 的 hook
阶段。比如使用 [pretty-quick](https://www.npmjs.com/package/pretty-quick)：

    
    
    yarn add prettier pretty-quick husky --dev
    

并在 package.json 中配置：

    
    
    {
        "husky": {
            "hooks": {
                "pre-commit": "pretty-quick --staged"
            }
        }
    }
    

husky 中，定义 pre-commit 阶段，对变化的文件运行 prettier，--staged 参数表示 pre-commit 模式：只对
staged 的文件进行格式化。

这里我们使用了官方推荐的 [pretty-quick](https://www.npmjs.com/package/pretty-quick) 来实现
pre-commit 阶段的美化。这只是实现方式之一，还可以通过 lint-staged 来实现，我们会在下面介绍 ESLint 和 husky 当中介绍。
​  
通过 demo 我们能看出，prettier 确实很灵活，且自动化程度很高，接入项目也十分方便。

#### ESLint

下面来看一下以 ESLint 为代表的 linter。code linting 表示基于静态分析代码原理，找出代码反模式的这过程。多数编程语言都有
linter，它们往往被集成在编译阶段，完成 coding linting 的任务。

对于 JavaScript 这种动态、松类型的语言来说，开发者更容易犯错。由于 JavaScript 不具备先天编译流程，往往在运行时暴露错误，而
linter，尤其最具代表性的 ESLint 的出现，允许开发者在执行前发现代码错误或不合理的写法。

ESLint 最重要的几点哲学思想：

  * 所有规则都插件化
  * 所有规则都可插拔（随时开关）
  * 所有设计都透明化
  * 使用 espree 进行 JavaScript 解析
  * 使用 AST 分析语法

最后两点我们将在「工具背后的技术原理和设计」一小节进行分析。下面我们简单配置一个 ESLint 规则：

初始化项目：

    
    
    yarn init -y
    

安装依赖：

    
    
    yarn add eslint --dev
    

并执行：

    
    
    npx eslint --init
    

之后，我们就可以对任意文件进行 lint：

    
    
    eslint XXX.js
    

当然，想要顺利执行 eslint，还需要安装应用规则插件。

那么如何声明并应用规则呢？在根目录中打开 .eslintrc 配置文件，我们在该文件中加入：

    
    
    {
        "rules": {
            "semi": ["error", "always"],
            "quote": ["error", "double"]
        }
    }
    

semi、quote 就是 ESLint 规则的名称，其值对应的数组第一项可以为：off/0、warn/1、error/2，分别表示关闭规则、以
warning 形式打开规则、以 error 形式打开规则。

  * off/0：关闭规则
  * warn/1：以 warning 形式打开规则
  * error/2：以 error 形式打开规则

同样我们还会在 .eslintrc 文件中发现：

    
    
    "extends": "eslint:recommended"
    

这行表示 ESLint 默认的规则都将会被打开。当然，我们也可以选取其他规则集合，比较出名的有：

  * [Google JavaScript Style Guide](https://google.github.io/styleguide/jsguide.html)
  * [Airbnb JavaScript Style Guide](https://github.com/airbnb/javascript#table-of-contents)

我们继续拆分 .eslintrc 文件，其实它主要由六个字段组成：

    
    
    module.exports = { 
       env: {}, 
       extends: {}, 
       plugins: {}, 
       parser: {}, 
       parserOptions: {}, 
       rules: {},
    }
    

  * env：表示指定想启用的环境
  * extends：指定额外配置的选项，如 ['airbnb'] 表示使用 Airbnb 的 linting 规则
  * plugins：设置规则插件
  * parser：默认情况下 ESLint 使用 espree 进行解析
  * parserOptions：如果将默认解析器更改，需要制定 parserOptions
  * rules：定义拓展并通过插件添加的所有规则

注意，上文中 .eslintrc 文件我们采用了 .eslintrc.js 的 JavaScript 文件格式，此外还可以采用
.yaml、.json、yml 等格式。如果项目中含有多种配置文件格式，优先级顺序为：

    
    
    .eslintrc.js
    .eslintrc.yaml
    .eslintrc.yml
    .eslintrc.json
    .eslintrc
    package.json
    

最终，我们在 package.json 中可以添加 script：

    
    
    "scripts": {
        "lint": "eslint --debug src/",
        "lint:write": "eslint --debug src/ --fix"
     },
    

  * lint 这个命令将遍历所有文件，并在每个找到错误的文件中提供详细日志，但需要开发者手动打开这些文件并更正错误。

  * lint:write 与上类似，但这个命令可以自动纠正错误。

#### linter VS prettier

我们应该如何对比以 ESLint 为代表的 linter 和 prettier
呢，它们到底是什么关系？就像开篇所提到的那样，它们解决不同的问题，定位不同，但是又可以相辅相成。

所有的 linter 类似 ESLint，其规则都可以划分为两类。

  * 格式化规则（formatting rules）

这类“格式化规则“典型的有 max-len、no-mixed-spaces-and-tabs、keyword-spacing、comma-
style，它们“限制一行的最大长度”、“禁止使用空格和 tab 混合缩进”等代码格式方面的规范。事实上，即便开发者写出的代码违反了这类规则，如果在
lint 阶段前，先经过 prettier 处理，这些问题会先在 prettier 阶段被纠正，因此 linter 不会抛出提醒，非常省心，这属于
linter 和 prettier 重叠的地方。

  * 代码质量规则（code quality rules）

这类“代码质量规则”类似 no-unused-vars、no-extra-bind、no-implicit-globals、prefer-promise-
reject-errors，它们限制“声明未使用变量”，“不必要的函数绑定” 等代码写法规范。这个时候，prettier
对这些规则无能为力。而这些规则对于代码质量和强健性至关重要，还是需要 linter 来保障的。

如同 prettier，ESLint 也可以集成到编辑器或者 git pre-commit 阶段。前文已经演示过了 prettier 搭配
husky，下面我们来介绍一下 husky 到底是什么。

#### husky 和 lint-staged

其实，husky 就是 git 的一个钩子，在 git 进行到某一时段时，可以交给开发者完成某些特定的操作。安装 husky：

    
    
    yarn add --dev husky
    

然后在 package.json 文件中添加：

    
    
    "husky": {    
        "hooks": {      
             "pre-commit": "YOUR_SCRIPT", 
             "pre-push": "YOUR_SCRIPT"   
        }  
    },
    

这样每次提交（commit 阶段）或者推送（push 阶段）代码时，就可以执行相关 npm 脚本。需要注意的是，在整个项目上运行 lint
会很慢，我们一般只想对更改的文件进行检查，这时候就需要使用到 lint-staged：

    
    
    yarn add --dev lint-staged
    

然后在 package.json 添加：

    
    
    "lint-staged": {    
        "*.(js|jsx)": ["npm run lint:write", "git add"]  
    },
    

最终代码为：

    
    
    "scripts": {
        "lint": "eslint --debug src/",
        "lint:write": "eslint --debug src/ --fix",
        "prettier": "prettier --write src/**/*.js"
    },
    "husky": {
        "hooks": {
            "pre-commit": "lint-staged"
        }
    },
    "lint-staged": {
        "*.(js|jsx)": ["npm run lint:write", "npm run prettier", "git add"]
    },
    

它表示在 pre-commit 阶段对于 js 或者 jsx 后缀且修改的文件执行 ESLint 和 prettier 操作，通过之后再进行 git add
添加到暂存区。

俗话说“工欲善其事，必先利其器”，本节课我们对常用工具进行了“巡礼”，请读者们亲自动手实践，了解其中奥秘。

### 分享交流

请大家留言分享「代码规范」相关的个人经验心得，你也可以阅读完下一节全部完成这个主题之后再来总结。阅读文章过程中有任何疑问随时可以跟其他小伙伴讨论，或者直接向作者
LucasHC 提问（作者看到后抽空解答）。 **你的分享不仅帮助他人，更会提升自己。**

同时，欢迎说说自己最想了解的主题，课程内容会根据大家的意见和建议迭代和完善。

此外，我们为本课程付费读者创建了《前端开发核心知识进阶》微信交流群，以方便更有针对性地讨论课程相关问题。（入群请到第1-2课末尾扫描二维码，若失效请加
GitChat 小助手伽利略的微信，ID 为 GitChatty6，注明「前端核心」。）



## 代码规范工具及背后技术设计（下）

上一节课，我们主要介绍了代码规范工具，了解了它们的配置、使用方式。这一节，我们将深入原理，并根据其实现和扩展能力，开发更加灵活的工具集。

在此之前，我们先回顾一下「代码规范」主题的知识点：

![](https://images.gitbook.cn/725e5a90-4ec9-11e9-b0b8-a9c8a3696845)

### 工具背后的技术原理和设计

这一小节，我们挑选实现更为复杂精妙的 ESLint 来分析。大家都清楚 ESLint 是基于静态语法分析（AST）进行工作的，AST
已经不是一个新鲜话题，我们在 webpack 章节就有介绍。ESLint 使用 Espree 来解析 JavaScript 语句，生成
AST。有了完整的解析树，我们就可以基于解析树对代码进行检测和修改。

ESLint 的灵魂是每一条 rule，每条规则都是独立且插件化的，我们挑一个比较简单的“禁止块级注释规则”源码来分析：

    
    
    module.exports = {
      meta: {
        docs: {
          description: '禁止块级注释',
          category: 'Stylistic Issues',
          recommended: true    
        }
      },
      create (context) {
        const sourceCode = context.getSourceCode()
        return {
          Program () {
            const comments = sourceCode.getAllComments()
            const blockComments = comments.filter(({ type }) => type === 'Block')
            blockComments.length && context.report({
              message: 'No block comments'
            })
          }
        }
      }
    }
    

从中我们看出，一条规则就是一个 node 模块，它由 meta 和 create 组成。meta 包含了该条规则的文档描述，相对简单。而 create
接受一个 context 参数，返回一个对象：

    
    
    {
        meta: {
            docs: {
                description: '禁止块级注释',
                category: 'Stylistic Issues',
                recommended: true 
            }
        },
        create (context) {
            // ...
            return {
    
            }
        }
    }
    

从 context 对象上我们可以取得当前执行扫描到的代码，并通过选择器获取当前需要的内容。如上代码，我们获取代码的所有
comments（sourceCode.getAllComments()），如果 blockComments 长度大于 0，则 report No
block comments 信息。

我们再来看一个 no-console rule 的实现：

    
    
    "use strict";
    
    module.exports = {
        meta: {
            type: "suggestion",
    
            docs: {
                description: "disallow the use of `console`",
                category: "Possible Errors",
                recommended: false,
                url: "https://eslint.org/docs/rules/no-console"
            },
    
            schema: [
                {
                    type: "object",
                    properties: {
                        allow: {
                            type: "array",
                            items: {
                                type: "string"
                            },
                            minItems: 1,
                            uniqueItems: true
                        }
                    },
                    additionalProperties: false
                }
            ],
    
            messages: {
                unexpected: "Unexpected console statement."
            }
        },
    
        create(context) {
            const options = context.options[0] || {};
            const allowed = options.allow || [];
    
            /**
             * Checks whether the given reference is 'console' or not.
             *
             * @param {eslint-scope.Reference} reference - The reference to check.
             * @returns {boolean} `true` if the reference is 'console'.
             */
            function isConsole(reference) {
                const id = reference.identifier;
    
                return id && id.name === "console";
            }
    
            /**
             * Checks whether the property name of the given MemberExpression node
             * is allowed by options or not.
             *
             * @param {ASTNode} node - The MemberExpression node to check.
             * @returns {boolean} `true` if the property name of the node is allowed.
             */
            function isAllowed(node) {
                const propertyName = astUtils.getStaticPropertyName(node);
    
                return propertyName && allowed.indexOf(propertyName) !== -1;
            }
    
            /**
             * Checks whether the given reference is a member access which is not
             * allowed by options or not.
             *
             * @param {eslint-scope.Reference} reference - The reference to check.
             * @returns {boolean} `true` if the reference is a member access which
             *      is not allowed by options.
             */
            function isMemberAccessExceptAllowed(reference) {
                const node = reference.identifier;
                const parent = node.parent;
    
                return (
                    parent.type === "MemberExpression" &&
                    parent.object === node &&
                    !isAllowed(parent)
                );
            }
    
            /**
             * Reports the given reference as a violation.
             *
             * @param {eslint-scope.Reference} reference - The reference to report.
             * @returns {void}
             */
            function report(reference) {
                const node = reference.identifier.parent;
    
                context.report({
                    node,
                    loc: node.loc,
                    messageId: "unexpected"
                });
            }
    
            return {
                "Program:exit"() {
                    const scope = context.getScope();
                    const consoleVar = astUtils.getVariableByName(scope, "console");
                    const shadowed = consoleVar && consoleVar.defs.length > 0;
    
                    /*
                     * 'scope.through' includes all references to undefined
                     * variables. If the variable 'console' is not defined, it uses
                     * 'scope.through'.
                     */
                    const references = consoleVar
                        ? consoleVar.references
                        : scope.through.filter(isConsole);
    
                    if (!shadowed) {
                        references
                            .filter(isMemberAccessExceptAllowed)
                            .forEach(report);
                    }
                }
            };
        }
    };
    

代码中通过 astUtils.getVariableByName(scope, "console") 以及 isConsole 函数来判别 console
语句的出现，通过 allowed.indexOf(propertyName) !== -1 来过滤白名单。

实现非常简单，了解了这些，相信你也能写出 no-alert，no-debugger 的规则内容。

我们再来看一下 no-duplicate-case 规则，它监测 switch...case 中是否存在相同的 case 分支：

    
    
    module.exports = {
        meta: {
            type: "problem",
    
            docs: {
                description: "disallow duplicate case labels",
                category: "Possible Errors",
                recommended: true,
                url: "https://eslint.org/docs/rules/no-duplicate-case"
            },
    
            schema: [],
    
            messages: {
                unexpected: "Duplicate case label."
            }
        },
    
        create(context) {
            const sourceCode = context.getSourceCode();
    
            return {
                SwitchStatement(node) {
                    const mapping = {};
    
                    node.cases.forEach(switchCase => {
                        const key = sourceCode.getText(switchCase.test);
    
                        if (mapping[key]) {
                            context.report({ node: switchCase, messageId: "unexpected" });
                        } else {
                            mapping[key] = switchCase;
                        }
                    });
                }
            };
        }
    };
    

代码非常简单，只是初始化时使用一个空的 mapping，每次添加 case 是进行对 mapping 的扩充，如果存在相同的 case 则 report。

虽然 ESLint 背后的技术内容比较复杂，但是基于 AST 技术，它已经给开发者提供了较为成熟的
APIs。写一条自己的规则并不是很难，只需要开发者找到相关的 AST 选择器，比如上面代码中的
getAllComments()，更多的选择器可以参考：[Selectors - ESLint - Pluggable JavaScript
linter](https://eslint.org/docs/developer-
guide/selectors)。熟练掌握选择器，将是我们开发插件扩展的关键。

当然，更复杂的场景远不止这么简单，比如，多条规则是如何串联起来生效的？

#### 多条规则串联生效

事实上， **规则可以从多个源来定义，比如代码的注释当中，或者配置文件当中。**

ESLint 首先收集到所有规则配置源，将所有规则归并之后，进行多重遍历：遍历由源码生成的
AST，将语法节点传入队列当中；之后遍历所有应用规则，采用事件发布订阅模式（类似 webpack
tapable），为所有规则的选择器添加监听事件；在触发事件时执行，如果发现有问题，会将 report message
记录下来。最终记录下来的问题信息将会被输出。

具体 ESLint 的源码如下：

    
    
    function runRules(sourceCode, configuredRules, ruleMapper, parserOptions, parserName, settings, filename) {
        const emitter = createEmitter();
        const nodeQueue = [];
        let currentNode = sourceCode.ast;
    
        Traverser.traverse(sourceCode.ast, {
            enter(node, parent) {
                node.parent = parent;
                nodeQueue.push({ isEntering: true, node });
            },
            leave(node) {
                nodeQueue.push({ isEntering: false, node });
            },
            visitorKeys: sourceCode.visitorKeys
        });
    
    
        const lintingProblems = [];
    
        Object.keys(configuredRules).forEach(ruleId => {
            const severity = ConfigOps.getRuleSeverity(configuredRules[ruleId]);
    
            if (severity === 0) {
                return;
            }
    
            const rule = ruleMapper(ruleId);
            const messageIds = rule.meta && rule.meta.messages;
            let reportTranslator = null;
            const ruleContext = Object.freeze(
                Object.assign(
    Object.create(sharedTraversalContext),
                    {
                        id: ruleId,
                        options: getRuleOptions(configuredRules[ruleId]),
                        report(...args) {
    
                            if (reportTranslator === null) {...}
                            const problem = reportTranslator(...args);
                            if (problem.fix && rule.meta && !rule.meta.fixable) {
                                throw new Error("Fixable rules should export a `meta.fixable` property.");
                            }
                            lintingProblems.push(problem);
                        }
                    }
                )
            );
    
            const ruleListeners = createRuleListeners(rule, ruleContext);
    
            // add all the selectors from the rule as listeners
            Object.keys(ruleListeners).forEach(selector => {
                emitter.on();
            });
        });
    
        const eventGenerator = new CodePathAnalyzer(new NodeEventGenerator(emitter));
    
        nodeQueue.forEach(traversalInfo => {
            currentNode = traversalInfo.node;
            if (traversalInfo.isEntering) {
                eventGenerator.enterNode(currentNode);
            } else {
                eventGenerator.leaveNode(currentNode);
            }
        });
    
        return lintingProblems;
    }
    

请再思考，我们的程序中免不了有各种条件语句、循环语句，因此 **代码的执行是非顺序的** 。相关规则比如：“检测定义但未使用变量”，“switch-case
中避免执行多条 case 语句”，这些规则的实现，就涉及 ESLint 更高级的 code path analysis 概念等。ESLint 将 code
path 抽象为 5 个事件。

  * onCodePathStart
  * onCodePathEnd
  * onCodePathSegmentStart
  * onCodePathSegmentEnd
  * onCodePathSegmentLoop

利用这 5 个事件，我们可以更加精确地控制检测范围和粒度。更多的 ESLint rule 实现，可以翻看源码进行学习，总之根据这 5
种事件，我们可以监测非顺序性代码，其核心原理还是事件机制。

我们通过 no-unreachable 规则来进行了解，该规则可以通过监测 return，throws，break，continue
的使用，识别出不会被执行的代码，并 report：

    
    
    /**
     * Checks whether or not a given variable declarator has the initializer.
     * @param {ASTNode} node - A VariableDeclarator node to check.
     * @returns {boolean} `true` if the node has the initializer.
     */
    function isInitialized(node) {
        return Boolean(node.init);
    }
    
    /**
     * Checks whether or not a given code path segment is unreachable.
     * @param {CodePathSegment} segment - A CodePathSegment to check.
     * @returns {boolean} `true` if the segment is unreachable.
     */
    function isUnreachable(segment) {
        return !segment.reachable;
    }
    
    /**
     * The class to distinguish consecutive unreachable statements.
     */
    class ConsecutiveRange {
        constructor(sourceCode) {
            this.sourceCode = sourceCode;
            this.startNode = null;
            this.endNode = null;
        }
    
        /**
         * The location object of this range.
         * @type {Object}
         */
        get location() {
            return {
                start: this.startNode.loc.start,
                end: this.endNode.loc.end
            };
        }
    
        /**
         * `true` if this range is empty.
         * @type {boolean}
         */
        get isEmpty() {
            return !(this.startNode && this.endNode);
        }
    
        /**
         * Checks whether the given node is inside of this range.
         * @param {ASTNode|Token} node - The node to check.
         * @returns {boolean} `true` if the node is inside of this range.
         */
        contains(node) {
            return (
                node.range[0] >= this.startNode.range[0] &&
                node.range[1] <= this.endNode.range[1]
            );
        }
    
        /**
         * Checks whether the given node is consecutive to this range.
         * @param {ASTNode} node - The node to check.
         * @returns {boolean} `true` if the node is consecutive to this range.
         */
        isConsecutive(node) {
            return this.contains(this.sourceCode.getTokenBefore(node));
        }
    
        /**
         * Merges the given node to this range.
         * @param {ASTNode} node - The node to merge.
         * @returns {void}
         */
        merge(node) {
            this.endNode = node;
        }
    
        /**
         * Resets this range by the given node or null.
         * @param {ASTNode|null} node - The node to reset, or null.
         * @returns {void}
         */
        reset(node) {
            this.startNode = this.endNode = node;
        }
    }
    
    //------------------------------------------------------------------------------
    // Rule Definition
    //------------------------------------------------------------------------------
    
    module.exports = {
        meta: {
            type: "problem",
    
            docs: {
                description: "disallow unreachable code after `return`, `throw`, `continue`, and `break` statements",
                category: "Possible Errors",
                recommended: true,
                url: "https://eslint.org/docs/rules/no-unreachable"
            },
    
            schema: []
        },
    
        create(context) {
            let currentCodePath = null;
    
            const range = new ConsecutiveRange(context.getSourceCode());
    
            /**
             * Reports a given node if it's unreachable.
             * @param {ASTNode} node - A statement node to report.
             * @returns {void}
             */
            function reportIfUnreachable(node) {
                let nextNode = null;
    
                if (node && currentCodePath.currentSegments.every(isUnreachable)) {
    
                    // Store this statement to distinguish consecutive statements.
                    if (range.isEmpty) {
                        range.reset(node);
                        return;
                    }
    
                    // Skip if this statement is inside of the current range.
                    if (range.contains(node)) {
                        return;
                    }
    
                    // Merge if this statement is consecutive to the current range.
                    if (range.isConsecutive(node)) {
                        range.merge(node);
                        return;
                    }
    
                    nextNode = node;
                }
    
                /*
                 * Report the current range since this statement is reachable or is
                 * not consecutive to the current range.
                 */
                if (!range.isEmpty) {
                    context.report({
                        message: "Unreachable code.",
                        loc: range.location,
                        node: range.startNode
                    });
                }
    
                // Update the current range.
                range.reset(nextNode);
            }
    
            return {
    
                // Manages the current code path.
                onCodePathStart(codePath) {
                    currentCodePath = codePath;
                },
    
                onCodePathEnd() {
                    currentCodePath = currentCodePath.upper;
                },
    
                // Registers for all statement nodes (excludes FunctionDeclaration).
                BlockStatement: reportIfUnreachable,
                BreakStatement: reportIfUnreachable,
                ClassDeclaration: reportIfUnreachable,
                ContinueStatement: reportIfUnreachable,
                DebuggerStatement: reportIfUnreachable,
                DoWhileStatement: reportIfUnreachable,
                ExpressionStatement: reportIfUnreachable,
                ForInStatement: reportIfUnreachable,
                ForOfStatement: reportIfUnreachable,
                ForStatement: reportIfUnreachable,
                IfStatement: reportIfUnreachable,
                ImportDeclaration: reportIfUnreachable,
                LabeledStatement: reportIfUnreachable,
                ReturnStatement: reportIfUnreachable,
                SwitchStatement: reportIfUnreachable,
                ThrowStatement: reportIfUnreachable,
                TryStatement: reportIfUnreachable,
    
                VariableDeclaration(node) {
                    if (node.kind !== "var" || node.declarations.some(isInitialized)) {
                        reportIfUnreachable(node);
                    }
                },
    
                WhileStatement: reportIfUnreachable,
                WithStatement: reportIfUnreachable,
                ExportNamedDeclaration: reportIfUnreachable,
                ExportDefaultDeclaration: reportIfUnreachable,
                ExportAllDeclaration: reportIfUnreachable,
    
                "Program:exit"() {
                    reportIfUnreachable();
                }
            };
        }
    };
    

实现中，通过 isUnreachable 函数来判别一个 code path 是否无法触及，我提供一些返例帮助大家理解：

    
    
    function foo() {
        return true;
        console.log("done");
    }
    
    function bar() {
        throw new Error("Oops!");
        console.log("done");
    }
    
    while(value) {
        break;
        console.log("done");
    }
    
    throw new Error("Oops!");
    console.log("done");
    
    function baz() {
        if (Math.random() < 0.5) {
            return;
        } else {
            throw new Error();
        }
        console.log("done");
    }
    

因为 unreachable 的代码需要放在一个区块当中去理解，单条语句无法去进行判别，因此使用 ConsecutiveRange 类来保留连续代码信息。

最后，这种优秀的插件扩展机制对于设计一个库，尤其是设计一个规范工具来说，是非常值得借鉴的模式。事实上，prettier
也会在新的版本中引入插件机制，目前已经在 beta
版，感兴趣的读者可以[尝鲜](https://prettier.io/docs/en/plugins.html#docsNav)。

### 自动化规范与团队建设

自动化规范还有其他一些细节，比如使用 EditorConfig 来保证编辑器的设置统一，确定在制表符空格或换行方面的一致性，又如使用
[commitlint](https://www.npmjs.com/package/@commitlint/config-conventional)
并配合 husky，来保证 commit message 的规范：

    
    
    # 安装 commitlint cli 和 conventional config
    npm install --save-dev @commitlint/{config-conventional,cli}
    
    # 配置 commitlint
    echo "module.exports = {extends: ['@commitlint/config-conventional']}" > commitlint.config.js
    

并在 commit-msg 的 git hook 阶段进行检查，在 package.json 中添加：

    
    
    {
        "husky": {
            "hooks": {
                "commit-msg": "commitlint -E HUSKY_GIT_PARAMS"
            }  
        }
    }
    

我们也可以根据团队需求做更多定制化的尝试，比如自动规范化或生产 commit message，有了规范的 commit message
之后，就可以提取关键内容，规范化生产 changelog 等。

其他方向上，还可以从团队文档的生产来考虑。举个例子，如果使用 React 开发项目，那么 React
组件文档如何规范化生成？如何提高组件使用的效率，减少学习成本？我在[掘金
AMA](https://juejin.im/pin/5c45dd09092dcb473721710d) 上做客时，有人便提出了这样的问题。

> 我们组内面临着最古老的 React 管理平台重构任务，这次我们想生成关于管理平台的阅读文档（包括常用的样式命名、工具方法、全局组件、复杂 API
交互流程等）。

>

> 所以我想提出的问题是：面向 React
代码的可维护性和可持续发展（不要单个功能每个团队成员都实现一遍，当新成员加入的时候知道有哪些功能能从现在代码中复用，
也知道有哪些功能还没有，他可以添加实现进去），业内有哪些工具或 npm 库或开发模式是可以确切能够帮助解决痛点或者改善现状的呢？

**确实，随着项目复杂度的提升，各种组件也“爆炸式”增长。如何让这些组件方便易用，能快速上手，同时不成为负担，又避免重复造轮子现象，良好的组件管理在团队中非常重要。**

关于“React 组件管理文档”，简单梳理一下：总得来说，社区在这方面的探索很多，相关方案也各有特色。

  * 最知名的一定是 [storybook](https://storybook.js.org/)，它会生成一个静态页面，专门用来展示组件的实际效果以及用法；缺点是业务侵入性较强，且 story 编写成本较高。
  * 我个人很喜欢的是 [react-docgen](https://github.com/reactjs/react-docgen)，比较极客风格，它能够分析并提取 React 组件信息。原理是使用了 recast 和 @babel/parser AST 分析，最终产出一个 JSON 文档。 <https://github.com/reactjs/react-docgen> 是它的网页链接，缺点是它较为轻量，缺乏有效的可视化能力。
  * 那么在 react-docgen 之上，我们可以考虑 [React Styleguidist](https://www.npmjs.com/package/react-styleguidist)，这款 React 组件文档生成器，支持丰富的 demo，可能会更符合需求。
  * 一些小而美的解决方案：比如 react-doc、react-doc-generator、cherrypdoc，都可以考虑尝试。

“自己动手、丰衣足食”，其实开发一个类似的工具并不会太复杂。如果有时间和精力，你可以根据自己的需求，实现一个完全匹配自己团队的 React
组件管理文档，或者其他框架相关、业务相关的文档，这非常有意义。

### 总结

在规范化的道路上，只有你想不到，没有你做不到。

简单的规范化工具用起来非常清爽，但是背后的实现却蕴含了很深的设计与技术细节，值得我们深入学习。

作为前端工程师，我们应该从平时开发的痛点和效率瓶颈入手，敢于尝试，不断探索。保证团队开发的自动化程度，就能减少不必要的麻烦。

除了“偏硬”的强制规范手段，一些“软方向”，比如团队氛围、code review/analyse
等，也直接决定着团队的代码质量。进阶的工程师不仅需要在技术上成长，在团队建设上更需要主动交流。

课程代码仓库： <https://github.com/HOUCe/lucas-gitchat-courses>

### 分享交流

请大家留言分享「代码规范」相关的个人经验心得。阅读文章过程中有任何疑问随时可以跟其他小伙伴讨论，或者直接向作者 LucasHC
提问（作者看到后会抽空解答）。 **你的分享不仅帮助他人，更会提升自己。**

同时，欢迎说说自己最想了解的主题，课程内容会根据大家的意见和建议迭代和完善。

此外，我们为本课程付费读者创建了《前端开发核心知识进阶》微信交流群，以方便更有针对性地讨论课程相关问题。（入群请到第1-2课末尾扫描二维码，若失效请加
GitChat 小助手伽利略的微信，ID 为 GitChatty6，注明「前端核心」。）



## 性能监控和错误收集与上报（上）

性能始终是前端领域非常重要的话题，它直接决定了产品体验的优劣，重要性无需赘言。我们在体验一个产品时，能够直观感受到其性能，可是如何量化衡量性能的好坏呢？

同时，我们无法保证程序永远不出问题，如何在程序出现问题时及时获得现场数据、还原现场，以做出准确地响应呢？

离开了实际场景谈这些话题都是“耍流氓”，性能数据的监控、错误信息的收集和上报应该都要基于线上真实环境。这对于我们随时掌控线上产品，优化应用体验具有重大意义。

本节课程，我们就聚焦在性能监控和错误收集与上报系统上。希望通过学习，每个人都心中有数，做到不仅能够分析性能数据、处理错误，还能建设一个成熟的配套系统。

本节课主要知识点：

![](https://images.gitbook.cn/9f1e2980-4ed7-11e9-b0b8-a9c8a3696845)

接下来，我们通过 2 节内容来学习这个主题。

### 性能监控指标

既然是性能监控，那我们首先需要明确衡量指标。一般来说，业界认可的常用指标有：

  * 首次绘制（FP）和首次有内容绘制（FCP）时间
  * 首次有意义绘制（FMP）时间
  * 首屏时间
  * 用户可交互（TTI）时间
  * 总下载时间
  * 自定义指标

接下来分别看看每个指标的含义。

> **首次绘制（FP）时间** ：对于应用页面，用户在视觉上首次出现不同于跳转之前的内容时间点，或者说是页面发生第一次绘制的时间点。

>

> **首次有内容绘制（FCP）时间** ：指浏览器完成渲染 DOM
中第一个内容的时间点，可能是文本、图像或者其他任何元素，此时用户应该在视觉上有直观的感受。

>

> **首次有意义绘制（FMP）时间**
：指页面关键元素渲染时间。这个概念并没有标准化定义，因为关键元素可以由开发者自行定义——究竟什么是“有意义”的内容，只有开发者或者产品经理自己了解。

>

> **首屏时间**
：对于所有网页应用，这是一个非常重要的指标。用大白话来说，就是进入页面之后，应用渲染完整个手机屏幕（未滚动之前）内容的时间。需要注意的是，业界对于这个指标其实同样并没有确切的定论，比如这个时间是否包含手机屏幕内图片的渲染完成时间。

>

> **用户可交互时间** ：顾名思义，也就是用户可以与应用进行交互的时间。一般来讲，我们认为是 domready
的时间，因为我们通常会在这时候绑定事件操作。如果页面中涉及交互的脚本没有下载完成，那么当然没有到达所谓的用户可交互时间。那么如何定义 domready
时间呢？我推荐参考司徒正美的文章：[何谓
domReady](https://www.cnblogs.com/rubylouvre/p/4536334.html)。

以上时间，我们可以通过下图对比认识：

![enter image description
here](https://images.gitbook.cn/ef4f34e0-b8f3-11e9-953b-67880772eeef)

这是我访问 Medium 移动网站分析得到的时序图，读者可根据网页加载的不同时段，体会各个时间节点的变化。更完整的信息由 Chrome DevTool
给出：

![enter image description
here](https://images.gitbook.cn/32f5c790-b8f4-11e9-953b-67880772eeef)

通过 Google Lighthouse 分析得到：

![enter image description
here](https://images.gitbook.cn/4b3730f0-b8f4-11e9-b842-d54514bdf4a6)

请注意 First Meaningful Paint 和 First Contentful Paint 以及 Time to
Interactive（可交互时间）被收录其中。

这里我们先对这些时间节点以及数据有一个感性的认知，后面将会逐步学习如何统计这些时间，做出如上图一样的分析系统。接下来，我们继续学习一些概念。

> **总下载时间** ：页面所有资源加载完成所需要的时间。一般可以统计 window.onload
时间，这样可以统计出同步加载的资源全部加载完的耗时。如果页面中存在较多异步渲染，也可以将异步渲染全部完成的时间作为总下载时间。

>

> **自定义指标** ：由于应用特点不同，我们可以根据需求自定义时间。比如，一个类似 Instagram
的页面，页面由图片瀑布流组成，那么我们可能非常关心屏幕中第一排图片渲染完成的时间。

**这里我们提一下，DOMContentLoaded 与 load 事件的区别** 。其实从这两个事件的命名我们就能体会，DOMContentLoaded
指的是文档中 DOM 内容加载完毕的时间，也就是说 HTML
结构已经完整。但是我们知道，很多页面包含图片、特殊字体、视频、音频等其他资源，这些资源由网络请求获取，DOM
内容加载完毕时，由于这些资源往往需要额外的网络请求，还没有请求或者渲染完成。而当页面上所有资源加载完成后，load
事件才会被触发。因此，在时间线上，load 事件往往会落后于 DOMContentLoaded 事件。

如图：

![enter image description
here](https://images.gitbook.cn/64c369d0-b8f4-11e9-b842-d54514bdf4a6)

表示页面加载一共请求了 13 个资源，大小为 309 KB，DOMContentLoaded 时间为 2.82 s，load 时间为 2.95
s，页面完全稳定时间 5.38 s 。

### FMP 的智能获取算法

另外结合自定义指标和首次有意义绘制（FMP）时间，稍做延伸：我们知道首次有意义绘制比较主观，开发者可以自行指定究竟哪些属于有意义的渲染元素。我们也可以通过
**FMP 的智能获取算法** 来完成自定义 FMP 时间。该算法实现过程如下。

**首先** ，获取有意义的渲染元素，一般认为：

  * 体积占比比较大
  * 屏幕内可见占比大
  * 属于资源加载元素（img、svg、video、object、embed、canvas）
  * 主要元素是多个组成的

具备这几个条件的元素，更像是有意义的元素。根据元素对页面视觉的贡献，我们对元素特点的权重进行划分：

    
    
    const weightMap = {
        SVG: 2,
        IMG: 2,
        CANVAS: 3,
        OBJECT: 3,
        EMBED: 3,
        VIDEO: 3,
        OTHER: 1
    }
    

**接着** ，我们对整个页面进行深度优先遍历搜索，之后对每一个元素进行分数计算，具体通过 element.getBoundingClientRect
获取元素的位置和大小，然后通过计算「width * height * weight * 元素在 viewport
的面积占比」的乘积，确定元素的最终得分。接着将该元素的子元素得分之和与其得分进行比较，取较大值，记录得分元素集。这个集合是“可视区域内得分最高的元素的集合”，我们会对这个集合的得分取均值，然后过滤出在平均分之上的元素集合，进行时间计算。这就得到了一个智能的
FMP 时间。

**最终** ，代码由 qbright 实现：[fmp-timing](https://github.com/qbright/fmp-
timing)，感兴趣的读者可以自行了解细节。

### 性能数据获取

了解了上述性能指标，我们来分析一下这些性能指标数据究竟该如何计算获取。

#### window.performance：强大但有缺点

目前最为流行和靠谱的方案是采用 Performance API，它非常强大：不仅包含了页面性能的相关数据，还带有页面资源加载和异步请求的相关数据。

调用 window.performance.timing 会返回一个对象，这个对象包含各种页面加载和渲染的时间节点。如图：

![enter image description
here](https://images.gitbook.cn/ba109250-b8f4-11e9-953b-67880772eeef)

具体解析：

    
    
    const window.performance = { 
        memory: {
            usedJSHeapSize,
            totalJSHeapSize,
            jsHeapSizeLimit
        },
    
        navigation: {
            // 页面重定向跳转到当前页面的次数
            redirectCount,
            // 以哪种方式进入页面
            // 0 正常跳转进入
            // 1 window.location.reload() 重新刷新
            // 2 通过浏览器历史记录，以及前进后退进入
            // 255 其他方式进入
            type,         
        },
    
        timing: {
            // 等于前一个页面 unload 时间，如果没有前一个页面，则等于 fetchStart 时间
            navigationStart
            // 前一个页面 unload 时间，如果没有前一个页面或者前一个页面与当前页面不同域，则值为 0
            unloadEventStart,
            // 前一个页面 unload 事件绑定的回调函数执行完毕的时间
            unloadEventEnd,
            redirectStart,
            redirectEnd,
            // 检查缓存前，准备请求第一个资源的时间
            fetchStart,
            // 域名查询开始的时间
            domainLookupStart,
            // 域名查询结束的时间
            domainLookupEnd,
            // HTTP（TCP） 开始建立连接的时间            connectStart,
            // HTTP（TCP）建立连接结束的时间
            connectEnd,
            secureConnectionStart,
            // 连接建立完成后，请求文档开始的时间
            requestStart,
            // 连接建立完成后，文档开始返回并收到内容的时间
            responseStart,
            // 最后一个字节返回并收到内容的时间
            responseEnd,
            // Document.readyState 值为 loading 的时间
            domLoading,
            // Document.readyState 值为 interactive
            domInteractive,
            // DOMContentLoaded 事件开始时间
            domContentLoadedEventStart,
            // DOMContentLoaded 事件结束时间
            domContentLoadedEventEnd,
            // Document.readyState 值为 complete 的时间            domComplete,
            // load 事件开始的时间
            loadEventStart,
            // load 事件结束的时间
            loadEventEnd
        }
    }
    

根据这些时间节点，我们选择相应的时间两两做差，便可以计算出一些典型指标：

    
    
    const calcTime = () => {
        let times = {}
        let t = window.performance.timing
    
        // 重定向时间
        times.redirectTime = t.redirectEnd - t.redirectStart
    
        // DNS 查询耗时
        times.dnsTime = t.domainLookupEnd - t.domainLookupStart
    
        // TCP 建立连接完成握手的时间
        connect = t.connectEnd - t.connectStart
    
        // TTFB 读取页面第一个字节的时间
        times.ttfbTime = t.responseStart - t.navigationStart
    
        // DNS 缓存时间
        times.appcacheTime = t.domainLookupStart - t.fetchStart
    
        // 卸载页面的时间
        times.unloadTime = t.unloadEventEnd - t.unloadEventStart
    
        // TCP 连接耗时
        times.tcpTime = t.connectEnd - t.connectStart
    
        // request 请求耗时
        times.reqTime = t.responseEnd - t.responseStart
    
        // 解析 DOM 树耗时
        times.analysisTime = t.domComplete - t.domInteractive
    
        // 白屏时间
        times.blankTime = t.domLoading - t.fetchStart
    
        // domReadyTime 即用户可交互时间
        times.domReadyTime = t.domContentLoadedEventEnd - t.fetchStart
    
        // 用户等待页面完全可用的时间
        times.loadPage = t.loadEventEnd - t.navigationStart
    
        return times
    }
    

**这个 API 非常强大，但是并不适用所有场景** 。比如：使用 window.performance.timing 所获的数据，在单页应用中改变 URL
但不刷新页面的情况下（单页应用典型路由方案），是不会更新的，还需要开发者重新设计统计方案。同时，可能无法满足一些自定义的数据。下面我们来分析一下部分无法直接获取的性能指标的计算方法。

#### 自定义时间计算

**首屏时间的计算实现方式不尽相同，开发者可以根据自己的需求来确定首屏时间的计算方式。我列举几个典型的方案。**

对于 **网页高度小于屏幕** 的网站来说，统计首屏时间非常简单，只要在页面底部加上脚本，完成当前时间的打印即可，这个时间再通过与
window.performance.timing.navigationStart 时间做差，即得到首屏渲染耗时。

但网页高度小于屏幕的站点毕竟是少数：对于 **网页高度大于一屏** 的页面来说，只要在估算接近于一屏幕的最后一个元素的位置后，插入计算脚本即可：

    
    
    var time = +new Date() - window.performance.timing.navigationStart
    

显然上述方案是比较理想化的，我们很难通过自动化工具或者一段集中管理的代码进行统计。开发者直接在页面 DOM
中插入时间统计，不仅代码侵入性太强，而且成本很高。同时，这样的计算方式其实并没有考虑首屏图片加载的情况，也就是说首屏图片未加载完的情况下，我们也认为加载已经完成。如果要考虑首屏图片的加载，建议使用
**集中化脚本统计首屏时间** 的方法：使用定时器不断检测 img
节点，判断图片是否在首屏且加载完成，找到首屏加载最慢的图片加载完成的时间，从而计算出首屏时间。如果首屏有没有图片，就用 domready 时间：

    
    
    const win = window
    const firstScreenHeight = win.screen.height
    let firstScreenImgs = []
    let isFindLastImg = false
    let allImgLoaded = false
    let collect = []
    
    const t = setInterval(() => {
        let i, img
        if (isFindLastImg) {
            if (firstScreenImgs.length) {
                for (i = 0; i < firstScreenImgs.length; i++) {
                    img = firstScreenImgs[i]
                    if (!img.complete) {
                        allImgLoaded = false
                        break
                    } else {
                        allImgLoaded = true
                    }
                }
            } else {
                allImgLoaded = true
            }
            if (allImgLoaded) {
                collect.push({
                    firstScreenLoaded: startTime - Date.now()
                })
                clearInterval(t)
            }
        } else {
            var imgs = body.querySelector('img')
            for (i = 0; i < imgs.length; i++) {
                img = imgs[i]
                let imgOffsetTop = getOffsetTop(img)
                if (imgOffsetTop > firstScreenHeight) {
                    isFindLastImg = true
                    break
                } else if (imgOffsetTop <= firstScreenHeight 
                && !img.hasPushed) {
                    img.hasPushed = 1
                    firstScreenImgs.push(img)
                }
            }
        }
    }, 0)
    
    const doc = document
    doc.addEventListener('DOMContentLoaded', () => {
        const imgs = body.querySelector('img')
        if (!imgs.length) {
            isFindLastImg = true
        }
    })
    
    win.addEventListener('load', () => {
        allImgLoaded = true
        isFindLastImg = true
        if (t) {
            clearInterval(t)
        }
    })
    

另外一种方式是不使用定时器，且默认影响首屏时间的主要因素是图片的加载，如果没有图片，纯粹渲染文字是很快的，因此，可以通过统计首屏内图片的加载时间获取首屏渲染完成的时间。

    
    
    (function logFirstScreen() {
        let images = document.getElementsByTagName('img')
        let iLen = images.length
        let curMax = 0
        let inScreenLen = 0
    
        // 图片的加载回调
        function imageBack() {
            this.removeEventListener
            && this.removeEventListener('load', imageBack, !1)
            if (++curMax === inScreenLen) {
                // 所有在首屏的图片均已加载完成的话，发送日志
                log()
            }   
        } 
        // 对于所有的位于指定区域的图片，绑定回调事件
        for (var s = 0; s < iLen; s++) {
            var img = images[s]
            var offset = {
                top: 0
            }
            var curImg = img
            while (curImg.offsetParent) {
                offset.top += curImg.offsetTop
                curImg = curImg.offsetParent
            }
            // 判断图片在不在首屏
            if (document.documentElement.clientHeight < offset.top) {
                continue
            }
            // 图片还没有加载完成的话
            if (!img.complete) {
                inScreenLen++
                img.addEventListener('load', imageBack, !1)
            }
        }
        // 如果首屏没有图片的话，直接发送日志
        if (inScreenLen === 0) {
            log()
        }
        // 发送日志进行统计
        function log () {
            window.logInfo.firstScreen = +new Date() - window.performance.timing.navigationStart
            console.log('首屏时间：', +new Date() - window.performance.timing.navigationStart)
        }
    })()
    

可见，除了使用教科书般强大的 Performance API
外，我们也完全拥有自主权来统计各种页面性能数据。这就需要开发者根据具体场景和业务需求，结合社区已有方案，找到完全适合自己的统计采集方式。

这节课我们介绍了性能核心指标以及获取方式，关键在于合理利用强大的 API。与此同时，对于“开放性”数据，我们需要结合实际，灵活进行开发。

### 分享交流

请大家留言分享「性能优化」相关的开发心得，你也可以阅读完下一节全部完成这个主题后再来分享。阅读文章过程中有任何疑问随时可以跟其他小伙伴讨论，或者直接向作者
LucasHC 提问（作者看到后抽空解答）。 **你的分享不仅帮助他人，更会提升自己。**

同时，欢迎说说自己最想了解的主题，课程内容会根据大家的意见和建议迭代和完善。

此外，我们为本课程付费读者创建了《前端开发核心知识进阶》微信交流群，以方便更有针对性地讨论课程相关问题。（入群请到第1-2课末尾扫描二维码，若失效请加
GitChat 小助手伽利略的微信，ID 为 GitChatty6，注明「前端核心」。）



## 性能监控和错误收集与上报（下）

上一节课我们学习了性能监控方面的知识。这一节来深入了解关于错误和异常的收集，并学习如何统一将这些信息进行上报。

在此之前，我们先回顾一下这个主题的知识点：

![](https://images.gitbook.cn/9f1e2980-4ed7-11e9-b0b8-a9c8a3696845)

### 错误信息收集

提到错误收集方案，大家应该会首先想到两种：try catch 捕获错误和 window.onerror 监听。

#### 认识 try catch 方案

我们先看一下 try catch 方案：

    
    
    try {
        // 代码块
    } catch(e) {
        // 错误处理
        // 在这里，我们可以将错误信息发送给服务端
    }
    

这种方式需要开发者对预估有错误风险的代码进行包裹，这个包裹过程可以手动添加，也可以通过自动化工具或类库完成。自动化方案的基本原理是 AST 技术：比如
UglifyJS 就提供操作 AST 的 API，我们可以对每个函数添加 try catch，社区上
[foio](https://github.com/foio/try-catch-global.js/blob/master/try-catch-
global.js) 的实现，就是一个很好的例子：

    
    
    const fs = require('fs')
    const _ = require('lodash')
    const UglifyJS = require('uglify-js')
    
    const isASTFunctionNode =  node => node instanceof UglifyJS.AST_Defun || node instanceof UglifyJS.AST_Function
    ​   
    const globalFuncTryCatch = (source, errorHandler) => {
        if (!_.isFunction(errorHandler)) {
            throw 'errorHandler should be a valid function'
        }
    
        const errorHandlerSource = errorHandler.toString()
        const errorHandlerAST = UglifyJS.parse('(' + errorHandlerSource + ')(error);')
        var tryCatchAST = UglifyJS.parse('try{}catch(error){}')
        const sourceAST = UglifyJS.parse(source)
        var topFuncScope = []
    
        tryCatchAST.body[0].catch.body[0] = errorHandlerAST
    
        const walker = new UglifyJS.TreeWalker(function (node) {
            if (isASTFunctionNode(node)) {
                topFuncScope.push(node)
            }
        })
        sourceAST.walk(walker)
        sourceAST.transform(transfer)
    
        const transfer = new UglifyJS.TreeTransformer(null,
            node => {
                if (isASTFunctionNode(node) && _.includes(topFuncScope, node)) {
                    var stream = UglifyJS.OutputStream()
                    for (var i = 0; i < node.body.length; i++) {
                        node.body[i].print(stream)
                    }
                    var innerFuncCode = stream.toString()
                    tryCatchAST.body[0].body.splice(0, tryCatchAST.body[0].body.length)
                    var innerTyrCatchNode = UglifyJS.parse(innerFuncCode, {toplevel: tryCatchAST.body[0]})
                    node.body.splice(0, node.body.length)
                    return UglifyJS.parse(innerTyrCatchNode.print_to_string(), {toplevel: node});
                }
            })
        const outputCode = sourceAST.print_to_string({beautify: true})
        return outputCode
    }
    
    module.exports.globalFuncTryCatch = globalFuncTryCatch
    

我们从 globalFuncTryCatch 函数的第一个参数中获得目标代码 source，将其转换为 AST：

    
    
    const sourceAST = UglifyJS.parse(source)
    

globalFuncTryCatch 函数的第二个参数为开发者定义的在出现错误时的响应函数，我们将其字符串化并转为 AST，并插入到 catch 块当中：

    
    
    var tryCatchAST = UglifyJS.parse('try{}catch(error){}')
    const errorHandlerSource = errorHandler.toString()
    const errorHandlerAST = UglifyJS.parse('(' + errorHandlerSource + ')(error);')
    tryCatchAST.body[0].catch.body[0] = errorHandlerAST
    

这样，借助于 globalFuncTryCatch，我们可以对每个函数添加 try catch 语句，并根据 globalFuncTryCatch
的第二个参数，传入自定义的错误处理函数（可以在该函数中进行错误上报）：

    
    
    globalFuncTryCatch(inputCode, function (error) {
        // 此处是异常处理代码，可以上报并记录日志
        // ...
    })
    

关键之处在于使用 UglifyJS 的能力，对 AST 语法树进行遍历，并转换：

    
    
    const walker = new UglifyJS.TreeWalker(function (node) {
        if (isASTFunctionNode(node)) {
            topFuncScope.push(node)
        }
    })
    sourceAST.walk(walker)
    sourceAST.transform(transfer)
    

最终再返回经过处理后的代码：

    
    
    const outputCode = sourceAST.print_to_string({beautify: true})
    return outputCode
    

使用 try catch，我们可以保证页面不崩溃，并对错误进行兜底处理，这是一个非常好的习惯。

#### try catch 方案的局限性

但是 try catch 处理异常的能力有限，对于运行时非异步错误，它并没有问题。但是对于：

  * 语法错误
  * 异步错误

try catch 就无法 cover 了。我们来看一个运行时非异步错误：

    
    
    try {
        a // 未定义变量 
    } catch(e) {
        console.log(e)
    }
    

可以被 try catch 处理。但是，将上述代码改动为语法错误：

    
    
    try {
        var a =\ 'a'
    } catch(e) {
        console.log(e);
    }
    

就无法捕获。

我们再看一下异步的情况：

    
    
    try {
        setTimeout(() => {
            a
        })
    } catch(e) {
        console.log(e)
    }
    

也无法捕获。

![enter image description
here](https://images.gitbook.cn/b674d7f0-bfd9-11e9-8e2c-3b4fd17ad6da)

除非在 setTimeout 中再加一层 try catch：

![enter image description
here](https://images.gitbook.cn/d1bc0740-bfd9-11e9-a5f2-bfb3232fc8ba)

总结一下， **try catch 能力有限，且对于代码的侵入性较强。**

#### 认识 window.onerror

我们再看一下 window.onerror 对错误进行处理的方案：开发者只需要给 window 添加 onerror 事件监听，同时 **注意需要将
window.onerror 放在所有脚本之前，这样才能对语法异常和运行异常进行处理。**

    
    
    window.onerror = function (message, source, lineno, colno, error) { 
        // ... 
    }
    

这里的参数较为重要，包含稍后需要上传的信息：

  * mesage 为错误信息提示
  * source 为错误脚本地址
  * lineno 为错误的代码所在行号
  * colno 为错误的代码所在列号
  * error 为错误的对象信息，比如 error.stack 获取错误的堆栈信息

window.onerror 这种方式对代码侵入性较小，也就不必涉及 AST 自动插入脚本。除了对语法错误和网络错误（因为 **网络请求异常不会事件冒泡**
）无能为力以外，无论是异步还是非异步，onerror 都能捕获到运行时错误。

但是需要注意的是，如果想使用 window.onerror 函数消化错误，需要显示返回 true，以保证错误不会向上抛出，控制台也就不会看到一堆错误提示。

#### 跨域脚本的错误处理

千万不要以为掌握了这些，就万事大吉了。现实场景多种多样，比如 **一种情况是：加载不同域的 JavaScript 脚本**
，这样的场景较为常见，比如加载第三方内容，以展示广告，进行性能测试、错误统计，或者想用第三方服务等。

对于不同域的 JavaScript 文件，window.onerror
不能保证获取有效信息。由于安全原因，不同浏览器返回的错误信息参数可能并不一致。比如，跨域之后 window.onerror
在很多浏览器中是无法捕获异常信息的，要统一返回 Script error，这就需要 script 脚本设置为：

    
    
    crossorigin="anonymous"
    

同时服务器添加 Access-Control-Allow-Origin 以指定允许哪些域的请求访问。

#### 使用 source map 进行错误还原

到目前为止，我们已经学习了获取错误信息的“十八般武艺”。但是，如果错误脚本是经过压缩的，那么纵使你有千般本领，也无用武之地了，因为这样捕获到的错误信息的位置（行列号）就会出现较大偏差，错误代码也经过压缩而难以辨认。这时候就需要启用
source map。很多构建工具都支持 source map，比如我们利用 webpack 打包压缩生成的一份对应脚本的 map 文件进行追踪，在
webpack 中开启 source map 功能：

    
    
    module.exports = {
        // ...
        devtool: '#source-map',
        // ...
    }
    

更多 source map 的内容，感兴趣的读者还可以参考以下资料：

  * [JavaScript Source Map 详解](http://www.ruanyifeng.com/blog/2013/01/javascript_source_map.html)
  * [Using source maps](https://webpack.js.org/guides/development/#using-source-maps)

Webpack sourcemap 这里不是我们的重点，就不再展开。

#### 对 Promise 错误处理

**我们再来看一下针对 Promise 的错误收集与处理** 。我们都提倡养成写 Promise 的时候最后写上 catch 函数的习惯。ESLint 插件
eslint-plugin-promise 会帮我们完成这项工作，使用规则：catch-or-return 来保障代码中所有的
promise（被显式返回的除外）都有相应的 catch 处理。比如这样的写法：

    
    
    var p = new Promise()
    p.then(fn1)
    p.then(fn1, fn2)
    function fn1() {
        p.then(doSomething)
    }
    

是无法通过代码检查的。

这类 ESLint 插件基于 AST 实现，逻辑也很简单：

    
    
    module.exports = {
      meta: {
        docs: {
          // ...
        },
        messages: {
           // ...
        }
      },
      create(context) {
        const options = context.options[0] || {}
        const allowThen = options.allowThen
        let terminationMethod = options.terminationMethod || 'catch'
    
        if (typeof terminationMethod === 'string') {
          terminationMethod = [terminationMethod]
        }
    
        return {
          ExpressionStatement(node) {
            if (!isPromise(node.expression)) {
              return
            }
    
            if (
              allowThen &&
              node.expression.type === 'CallExpression' &&
              node.expression.callee.type === 'MemberExpression' &&
              node.expression.callee.property.name === 'then' &&
              node.expression.arguments.length === 2
            ) {
              return
            }
    
            if (
              node.expression.type === 'CallExpression' &&
              node.expression.callee.type === 'MemberExpression' &&
              terminationMethod.indexOf(node.expression.callee.property.name) !== -1
            ) {
              return
            }
    
            if (
              node.expression.type === 'CallExpression' &&
              node.expression.callee.type === 'MemberExpression' &&
              node.expression.callee.property.type === 'Literal' &&
              node.expression.callee.property.value === 'catch'
            ) {
              return
            }
    
            context.report({
              node,
              messageId: 'terminationMethod',
              data: { terminationMethod }
            })
          }
        }
      }
    }
    

如果读者对于 AST 和 ESLint 相关内容感兴趣，请关注课程《代码风格规范和背后技术设计》，会展开分析这方面的话题。

可能大家会想到，promise 实例的 then 方法中的第二个 onRejected 函数也能处理错误，这个和上面提到的 catch
方法有什么差别呢？事实上，我更加推荐 catch 方法，请看下面代码：

    
    
    new Promise((resolve, reject) => {
        throw new Error()
    }).then( () => {
        console.log('resolved')
    }, err => {
        console.log('rejected')
        throw err
    }).catch(err => {
        console.log(err, 'catch')
    })
    

输出：rejected，在有 onRejected 的情况下，onRejected 发挥作用，catch 并未被调用。 而当：

    
    
    new Promise((resolve, reject) => {
        resolve()
    }).then(() => {
        throw new Error()
        console.log('resolved')
    }, err => {
        console.log('rejected')
        throw err
    }).catch(err => {
        console.log(err, 'catch')
    })
    

输出：`VM705:10 Error at Promise.then (<anonymous>:4:9) "catch"`，此时 onRejected
并不能捕获 then 方法中第一个参数 onResolved 函数中的错误。一经对比，也许 catch
是进行错误处理更好的选择。但是，这两种方式各有特点，还是需要读者对 Promise 有较为深入的认识。

除此之外，对于 Promise 的错误处理，我们还可以注册对 Promise 全局异常的捕获事件 unhandledrejection：

    
    
    window.addEventListener("unhandledrejection",  e => {
        e.preventDefault()
        console.log(e.reason)
        return true
    })
    

这对于集中管理和错误收集更加友好。

#### 处理网络加载错误

前面介绍的处理方式都是对已经在浏览器端的脚本逻辑错误进行的，我们设想用 script 标签，link
标签进行脚本或者其他资源加载时，由于某种原因（可能是服务器错误，也可能是网络不稳定），导致了脚本请求失败，网络加载错误。

    
    
    <script src="***.js"></script>
    <link rel="stylesheet" href="***.css">
    

为了捕获这些加载异常，我们可以：

    
    
    <script src="***.js"  onerror="errorHandler(this)"></script>
    <link rel="stylesheet" href="***.css" onerror="errorHandler(this)">
    

除此之外，也可以使用 window.addEventListener('error') 方式对加载异常进行处理，注意这时候我们无法使用
window.onerror 进行处理， **因为 window.onerror 事件是通过事件冒泡获取 error
信息的，而网络加载错误是不会进行事件冒泡的。**

这里多提一下， **不支持冒泡的事件还有** ：鼠标聚焦 / 失焦（focus / blur）、鼠标移动相关事件（mouseleave /
mouseenter）、一些 UI 事件（如 scroll、resize 等）。

因此，我们也就知道 **window.addEventListener 不同于 window.onerror，它通过事件捕获获取 error
信息，从而可以对网络资源的加载异常进行处理：**

    
    
    window.addEventListener('error', error => {
        console.log(error)
    }, true)
    

**那么，怎么区分网络资源加载错误和其他一般错误呢** ？这里有个小技巧，普通错误的 error 对象中会有一个 error.message
属性，表示错误信息，而资源加载错误对应的 error 对象却没有，因此可以根据下面代码进行判断：

    
    
    window.addEventListener('error', error => {
        if (!error.message) {
            // 网络资源加载错误
            console.log(error)
        }
    }, true)
    

但是，也因为没有 error.message 属性，我们也就没有额外信息获取具体加载的错误细节，现阶段也无法具体区分加载的错误类别：比如是 404
资源不存在还是服务端错误等，只能配合后端日志进行排查。

**到这里，我们简单做一个总结，分析 window.onerror 和 window.addEventListener('error') 的区别。**

  * window.onerror 需要进行函数赋值：window.onerror = function() {//...}，因此重复声明后会被替换，后续赋值会覆盖之前的值。这是一个弊端。

请看下图示例：

![enter image description
here](https://images.gitbook.cn/f275ddd0-bfd9-11e9-8e2c-3b4fd17ad6da)

  * 而 window.addEventListener('error') 可以绑定多个回调函数，按照绑定顺序依次执行，请看下图示例：

![enter image description
here](https://images.gitbook.cn/0be789d0-bfda-11e9-98b2-fde9741b330a)

#### 页面崩溃收集和处理

一个成熟的系统还需要收集崩溃和卡顿，对此我们可以监听 window 对象的 load 和 beforeunload 事件，并结合
sessionStorage 对网页崩溃实施监控：

    
    
    window.addEventListener('load', () => {
        sessionStorage.setItem('good_exit', 'pending')
    })
    
    window.addEventListener('beforeunload', () => {
        sessionStorage.setItem('good_exit', 'true')
    })
    
    if(sessionStorage.getItem('good_exit') &&
        sessionStorage.getItem('good_exit') !== 'true') {
        // 捕获到页面崩溃
    }
    

代码很简单，思路是首先在网页 load 事件的回调里：利用 sessionStorage 记录 good_exit 值为
pending；接下来，在页面无异常退出前，即 beforeunload 事件回调中，修改 sessionStorage 记录的 good_exit 值为
true。因此，如果页面没有崩溃的话，good_exit 值都会在离开前设置为 true，否则就可以通过
sessionStorage.getItem('good_exit') && sessionStorage.getItem('good_exit') !==
'true' 判断出页面崩溃，并进行处理。

如果你的应用部署了 PWA，那么便可以享受 service worker 带来的福利！在这里，可以通过 service worker
来完成网页崩溃的处理工作。基本原理在于：service worker 和网页的主线程独立。因此，即便网页发生了崩溃现象，也不会影响 service
worker 所在线程的工作。我们在监控网页的状态时，通过 navigator.serviceWorker.controller.postMessage
API 来进行信息的获取和记录。

#### 框架的错误处理

对于框架来说，React 16 版本之前，使用 unstable_handleError 来处理捕获的错误；16 版本之后，使用著名的
componentDidCatch 来处理错误。Vue 中，提供了 Vue.config.errorHandler 来处理捕获到的错误，如果开发者没有配置
Vue.config.errorHandler，那么捕获到的错误会以 console.error 的方式输出。具体 API
的使用方式和框架特点，这里不再赘述。

上面提到框架会用 console.error 的方法抛出错误，因此可以劫持 console.error，捕获框架中的错误并做出处理：

    
    
    const nativeConsoleError = window.console.error
    window.console.error = (...args) => nativeConsoleError.apply(this, [`I got ${args}`])
    

如下图：

![enter image description
here](https://images.gitbook.cn/2027dd50-bfda-11e9-98b2-fde9741b330a)

最后总结一下，我们大概处理了以下错误或者异常：

  * JavaScript 语法错误、代码异常
  * AJAX 请求异常（xhr.addEventListener('error', function (e) { //... })）
  * 静态资源加载异常
  * Promise 异常
  * 跨域 Script error
  * 页面崩溃
  * 框架错误

在真实生产环境中，错误和异常多种多样，需要开发者格外留心，并对每一种情况进行覆盖。另外，除了性能和错误信息，一些额外信息，比如页面停留时间、长任务处理耗时等往往对分析网页表现非常重要。所有这些话题，欢迎大家在评论区展开讨论，也可以直接向我提问。对于错误信息采集和处理的介绍到此为止，接下来看一下数据的上报和系统设计。

### 性能数据和错误信息上报

数据都有了，我们该如何上报呢？可能有的开发者会想：“不就是一个 AJAX 请求吗？”，实际上还真没有这么简单，有一些细节需要考虑。

##### **上报采用单独域名是否更好**

我们发现，成熟的网站数据上报的域名往往与业务域名并不相同。这样做的好处主要有两点：

  * 使用单独域名，可以防止对主业务服务器的压力，能够避免日志相关处理逻辑和数据在主业务服务器的堆积；
  * 另外，很多浏览器对同一个域名的请求量有并发数的限制，单独域名能够充分利用现代浏览器的并发设置。

##### **独立域名的跨域问题**

对于单独的日志域名，肯定会涉及跨域问题。我们经常发现页面使用“构造空的 Image 对象的方式”进行数据上报。原因是请求图片并不涉及跨域的问题：

    
    
    let url = 'xxx'
    let img = new Image()
    img.src = url
    

我们可以将数据进行序列化，作为 URL 参数传递：

    
    
    let url = 'xxx?data=' + JSON.stringify(data)
    let img = new Image()
    img.src = url
    

##### **何时上报数据**

页面加载性能数据可以在页面稳定后进行上报。

一次上报就是一次访问，对于其他错误和异常数据的上报，假设我们的应用日志量很大，则有必要合并日志在统一时间，统一上报。那么什么情况下上报性能数据呢？一般合适的场景为：

  * 页面加载和重新刷新
  * 页面切换路由
  * 页面所在的 Tab 标签重新变得可见
  * 页面关闭

但是，对于越来越多的单页应用来说，需要格外注意数据上报时机，请看下文。

#### 单页应用上报

如果切换路由是通过改变 hash 值来实现的，那么只需要监听 hashchange 事件，如果是通过 history API 来改变 URL，那么需要使用
pushState 和 replaceState 事件。当然一劳永逸的做法是进行 monkey patch，结合发布订阅模式，为相关事件的触发添加处理：

    
    
    const patchMethod = type => 
        () => {
           const result = history[type].apply(this, arguments)
           const event = new Event(type)
           event.arguments = arguments
           window.dispatchEvent(event)
           return result
           }
    
    
    history.pushState = patchMethod('pushState')
    history.replaceState = patchMethod('replaceState')
    

我们通过重写 history.pushState 和 history.replaceState 方法，添加并触发 pushState 和
replaceState 事件。这样一来 history.pushState 和 history.replaceState
事件触发时，可以添加订阅函数，进行上报：

    
    
    window.addEventListener('replaceState', e => {
        // report...
    })
    window.addEventListener('pushState', e => {
        // report...
    })
    

##### **何时以及如何上报**

如果是在页面离开时进行数据发送，那么在页面卸载期间是否能够安全地发送完数据是一个难题：因为页面跳转，进入下一个页面，就难以保证异步数据的发送了。如果使用同步的
AJAX：

    
    
    window.addEventListener('unload', logData, false);
    const logData = () => {
        var client = new XMLHttpRequest()
        client.open("POST", "/log", false) // 第三个参数表明是同步的 XHR
        client.setRequestHeader("Content-Type", "text/plain;charset=UTF-8")
        client.send(data)
    }
    

又会对页面跳转流畅程度和用户体验造成影响。

这时候给大家推荐一下 sendBeacon 方法：

    
    
    window.addEventListener('unload', logData, false)
    
    const logData = () => {
        navigator.sendBeacon("/log", data)
    }
    

navigator.sendBeacon 就是天生来解决“页离开时的请求发送”问题的。它的几个特点决定了对应问题的解决方案：

  * 它的行为是异步的，也就是说请求的发送不会阻塞向下一个页面的跳转，因此可以保证跳转的流畅度；
  * 它在不受到极端“数据 size 和队列总数”的限制下，优先返回 true 以保证请求的发送成功。

目前 Google Analytics 使用 navigator.sendBeacon 来上报数据，请参考：[Google Analytics added
sendBeacon functionality to Universal Analytics JavaScript
API](https://www.thyngster.com/google-analytics-added-sendbeacon-
functionality-universal-analytics-javascript-api/)。通过这篇文章，我们看到 Google
Analytics 通过动态创建 img 标签，在 img.src 中拼接 URL 的方式发送请求，不存在跨域限制。如果 URL 太长，就会采用
sendBeacon 的方式发送请求，如果 sendBeacon 方法不兼容，则发送 AJAX post 同步请求。类似：

    
    
    const reportData = url => {
        // ...
        if (urlLength < 2083) {
            imgReport(url, times)
        } else if (navigator.sendBeacon) {
            sendBeacon(url, times)
        } else {
            xmlLoadData(url, times)
        }
    }
    

最后，如果网页访问量很大，那么一个错误发送的信息就非常多，我们可以给上报设置一个采集率：

    
    
     const reportData = url => {
        // 只采集 30%
        if (Math.random() < 0.3) {
            send(data)
        }
    }
    

这个采集率当然可以通过具体实际的情况来设定，方法多种多样。

### 无侵入和性能友好的方案设计

目前为止，我们已经了解了性能监控和错误收集的所有必要知识点。那么根据这些知识点，如何设计一个好的系统方案呢？

首先，这样的系统大致可分为四个阶段：

![](https://images.gitbook.cn/d0ebda50-4eac-11e9-8d6d-edc0eec9ca99)

针对这几个阶段，我们聊一下关键方面的核心细节。

**数据上报优化方面**

借助 HTTP 2.0 带来的新特性，我们可以持续优化上报性能。比如：采用 HTTP 2.0 头部压缩，以减少数据传送大小；采用 HTTP 2.0
多路复用技术，以充分利用链接资源。

**接口和智能化设计方面**

我们可以考虑以下方面：

  * 识别周高峰和节假日，动态设置上报采样率；
  * 增强数据清洗能力，提高数据的可用性，对一些垃圾信息进行过滤；
  * 通过配置化，减少业务接入成本；
  * 如果用户一直触发错误，相同的错误内容会不停上报，这时可以考虑是否需要做一个短时间滤重。

**实时性方面**

目前我们对系统数据的分析都是后置的，如何做到实时提醒呢？这就要依赖后端服务，将超过阈值的情况进行邮件或短信发送。

在这个链路中，所有细节单独拿出来都是一个值得玩味的话题。打个比方，报警阈值如何设定。我们的应用可能在不同的时段和日期，流量差别很大，比如“点评”类应用，或“酒店预订”类应用，在节假日流量远远高于平时。如果报警阈值不做特殊处理，报警过于敏感，也许运维或开发者就要收到“骚扰”。业界上流行
3-sigma 的阈值设置，这是一个统计学概念。它表示对于一个正态分布或近似正态分布来说，数值分布在（μ-3σ,μ+3σ)
中属于正常范围区间。这方面更多内容可以参考：

  * <https://www.investopedia.com/terms/t/three-sigma-limits.asp>
  * [What does a 1-sigma, a 3-sigma or a 5-sigma detection mean](https://thecuriousastronomer.wordpress.com/2014/06/26/what-does-a-1-sigma-3-sigma-or-5-sigma-detection-mean/)

最后，我收集了业界几个性能监控和错误收集上报系统的分享，这些分享方案有的以 PPT 形式呈现，有的以源码分析实现，希望大家能够继续了解学习：

  * [前端异常监控解决方案研究](https://cdc.tencent.com/2018/09/13/frontend-exception-monitor-research/)
  * [解密 ARMS 前端监控数据上报技术内幕](https://zhuanlan.zhihu.com/p/37275225)
  * [别再让你的 Web 页面在用户浏览器端裸奔](https://mp.weixin.qq.com/s/Z8daa96JD5NbjTPn9mGPPg)
  * [把前端监控做到极致](https://zhuanlan.zhihu.com/p/32262716?utm_medium=social&utm_source=wechat_session&from=singlemessage&isappinstalled=0)
  * [浏览器端 JS 异常监控探索与实践](https://mp.weixin.qq.com/s?__biz=MzUxMzcxMzE5Ng==&mid=2247485669&idx=1&sn=a4d4aee73b606d412aba71abafb88325&source=41#wechat_redirect)

### 总结

本节梳理了性能监控和错误收集上报方方面面的内容。前端业务场景和浏览器的兼容性千差万别，因此数据监控上报系统要兼容多种情况。页面生命周期、业务逻辑复杂性也决定了成熟稳定的系统不是一蹴而就的。我们也要持续打磨，结合新技术和老经验，同时对比类似
Sentry 这样的巨型方案，探索更稳定高效的系统。

课程代码仓库：

<https://github.com/HOUCe/lucas-gitchat-courses>

### 分享交流

请大家留言分享「性能监控和错误上报」相关的经验心得。阅读文章过程中有任何疑问随时可以跟其他小伙伴讨论，或者直接向作者 LucasHC 提问。
**你的分享不仅帮助他人，更会提升自己。**

你也可以说说自己最想了解的主题，课程内容会根据部分读者的意见和建议迭代和完善。

此外，我们为本课程付费读者创建了《前端开发核心知识进阶》微信交流群，以方便更有针对性地讨论课程相关问题。（入群请到第1-2课末尾扫描二维码，若失效请加
GitChat 小助手伽利略的微信，ID 为 GitChatty6，注明「前端核心」。）



## 性能优化问题，老司机如何解决（上）

一直以来，性能优化是前端的重要课题，不仅实实在在影响产品性能，在面试环节也会被反复提及。无论应聘者是初入前端的新手，还是工作经验丰富的老司机，面试官都能在性能方面找到合适的切入点，对候选人进行考察。作为程序员，应该如何在平时学习、工作中积累性能优化方面的经验，保障产品顺畅体验？作为面试者，如何在面试流程中出色地回答性能相关问题？

**前端性能是一个太过宽泛的话题，脱离场景和需求谈性能往往毫无意义**
。我相信很少有面试官会直接把：“前端如何优化性能？”——这样一个空架子问题抛出的。也不会有技术经理直接丢给你“把产品性能提升一些”这样的项目。毕竟这样的问题过大，根本让人无处下手。我们还需要针对具体场景和瓶颈来分析。

但是，如果真的有面试官这么问了呢？

如果是我，我也许会这样回答：

> 前端性能涉及方方面面，优化角度切入点都有所不同。我认为，主要可以分为：页面工程优化和代码细节优化两大方向。

**页面工程优化** 从页面请求开始，涉及网络协议、资源配置、浏览器性能、缓存等； **代码细节优化** 上相对零散，比如 JavaScript 对 DOM
操作，宿主环境的单线程相关内容等。

也正如上所答，本节课程也会基于以下两个大方向的相关知识进行梳理：

  * **页面工程优化**
  * **代码细节优化**

为了更好地还原真实场景，这两方面我都将配合两类面试题目来解析：

  * 开放例题实战
  * 代码例题实战

这个主题的知识点如下：

![](https://images.gitbook.cn/a4889460-4ecc-11e9-8044-3de24c2bc492)

接下来，我们通过 2 节内容来学习这个主题。

### 开放例题实战

如上分析，面试官往往会根据面试者的实际经验或者性能的某一细分方向，进行深度提问，以了解候选人的知识储备以及在以往项目中的表现。

作为一个面试者，包括在蚂蚁金服、阿里淘宝某团队、头条、美团以及其他公司的多次面试流程中，我曾经被问到过：
**“在平时工作中做过哪些性能优化方面的项目？”**

我是这样回答的：

> 因为我服务的是有亿级流量的 To C 型产品，因此平时工作中，在性能优化方面一直持续进行探索和迭代。除了代码细节方面外，较大型工程优化主要有 WebP
图片格式替换、资源打包和逆向代码拆分（按需加载）等。

#### WebP 图片优化

因为并不知道面试官需要考察的程度，以上回答可以避免自己“侃侃而谈”浪费时间的尴尬。在这样的面试场景中，我往往会把主动权交给面试官。大部分面试官会继续追问，比如他对
WebP 图片格式优化项目感兴趣， **那我会从项目的立项、实施、收益的角度进行解答，表现作为一个项目负责人对优化项目的理解** ：

> 我们的产品页面中，往往存在大量的图片内容，因此图片的性能优化是瓶颈和重点。除了传统的图片懒加载手段以外，我调研并实施了 WebP
图片格式的替换。由于可能会有潜在兼容性的问题，因而具体做法是先进行兼容性嗅探。这一手段借鉴了社区一贯做法，利用 `img` 标签加载一张 base64 的
WebP 图片，并将结果存入 `localStorage` 中防止重复判断。如果该终端支持，则再对图片格式进行替换。这个兼容性嗅探过程，也封装成
promise 化的通用接口。

相关代码片段如下：

    
    
    const supportWebp = () => new Promise(resolve => {
        const image = new Image()
        image.onerror = () => resolve(false)
        image.onload = () => resolve(image.width === 1)
        image.src = 'data:image/webp;base64,UklGRiQAAABXRUJQVlA4IBgAAAAwAQCdASoBAAEAAwA0JaQAA3AA/vuUAAA='
    }).catch(() => false)
    

这时候，面试官往往会进一步关心项目收益情况。这就需要面试者根据实情作答，仍然以这个项目为例：

> 在具体上线时，我对 10% 的流量进行了分组切分。5% 为对照组，仍然采用传统格式；另外 5% 为实验组，进行 WebP 格式试验。
**最终结果显示收益非常有限** 。 为此我进行分析：认为出现近似零收益的原因是图片服务的缓存问题。新转换的一批 WebP
格式图片由于没有缓存，因而在性能上打了折扣。为了验证猜想，我决定继续进行扩量试验并观察结果。果然，后续排除缓存问题之后，收益提升 25%~30% 左右。

这里，我们就涉及了工程优化中的一个重要环节：网络请求和缓存。这些内容我们会在后续课程网络环节《第 8-1课：缓存谁都懂，一问都哑口》中具体展开。

通过以上回答，我如实讲述了出现的非预期
case，并说明遇见问题时，如何进行分析进而解决问题的一系列过程。这样的回答能明确表现出我确实做过该项目并进行了思考分析，最终落地。这类思路也更容易被面试官所接受。

更多关于 WebP 的好文章：

  * [WebP Support - It's More Than You Think](https://www.keycdn.com/support/webp-support)
  * [从零开始带你认识最新的图片格式 WebP](http://www.uisdc.com/image-format-webp-introduction)
  * [把网站的图片升级到 WebP 格式吧](https://segmentfault.com/a/1190000007482148)

也由此看出，性能优化其实并不难做，重要的是解决问题的思路，以及解决过程中对于项目的把控和推荐。这些内容我们称之为“软素质”。

#### 按需加载优化

如果面试官围绕着刚才列举的“资源打包和逆向拆分（按需加载）”方向提问，我仍然会采用同样的“思路”进行回答：

>
我接手项目之后，发现历史原有的资源打包配置并不合理，严重影响了性能表现。因此借助构建工具，对资源进行合并打包。但是，需要注意的是，我的策略并不是大刀阔斧地进行资源合并，因为这样会让
bundle.js 的 size 越来越大，所以也进行了逆向过程。

>

> 以实际页面为例：

>

> ![enter image description
here](https://images.gitbook.cn/6f5fc910-bff2-11e9-8e2c-3b4fd17ad6da)

>

>
如上，当点击左图播放按钮之后，页面出现视频列表浮层（右侧所示，仍为同一页面，类似单页应用）。视频列表浮层包含了滚动处理、视频播放等多项复杂逻辑，因此关于这个浮层的脚本我并没有进行打包合并，而是单独进行拆分。当用户点击浮层触发按钮后，再执行对这一部分脚本的请求。

工程化性能优化不仅需要做，还要用数据证明做法的合理性：

> 同时，我对用户点击触发按钮的概率进行统计，发现进入页面的用户只有 10%
左右会点击按钮，从而触发视频列表浮层。也就是说，大部分用户（90%）并不会看到这一浮层，延迟按需加载是有统计数据支持的。

通过这个案例，我们发现性能优化其实是一个开放式问题，非常依赖实践。读者可根据上面的例子，结合自己的项目进行回答。

虽然没有涉及代码实施，但是建立起项目意识和方向意识，这在工程化性能上非常难能可贵。上面提到的借助构建工具进行“按需加载”等内容，前面章节如《webpack
工程师 > 前端工程师》都会具体从代码角度给出示例。

当然上述举例的按需加载，我们并不是使用成熟的 webpack
工具链，而是采用公司内部封装的工程化工具。在几年前，这样的方案并不成熟，因此我写了一些按需加载的差距，配合自己的工程化工具使用。这一方面内容，很多面试官会很感兴趣，话题也可以延伸到
FIS 和 webpack 的比较，工程化工具的设计等话题。

#### 讲不完的工程化优化

此外，工程优化方向还包括：

  * 图片懒加载
  * 雪碧图
  * 合理设置缓存策略
  * 使用 prefetch / preload 预加载等新特性
  * 以 tree shaking 手段为主的代码瘦身

这里不再一一举例，欢迎订阅此课程的同学结合自己的经历在评论区留言讨论或者直接向我提问，我会尽量拿出时间跟大家一起进行项目分析、描述。

以上是 **工程化** 性能的实际题目，总结一下：工程师需要对日常项目进行深入总结，结合产品角度、研发角度描述。在面试前就需要做到“心中有数，胸有成竹”。

另外，在具体的实现方向上，关于性能优化的切入点也有很多。比如：

  * 动画性能方向
  * 操作 DOM 方向
  * 浏览器加载、渲染性能方向
  * 性能测量、监控方向

这些方向并不是相互独立的，它们彼此依存，比如 **动画性能方向与浏览器渲染性能息息相关** 。这里我用一道经典的面试题来分析：
**“如果发现页面动画效果卡顿，你会从哪些角度解决问题？”**

首先从动画实现入手：

>   * 一般 CSS3 动画会比基于 JavaScript 实现的动画效率要高，因此优先使用 CSS3 实现效果（这一点并不绝对）

>   * 在使用 CSS3 实现动画时，考虑开启 GPU 加速（这一点也并不总是正向效果）

>   * 优先使用消耗最低的 transform 和 opacity 两个属性

>   * 使用 will-change 属性

>   * 独立合成层，减少绘制区域

>   * 对于只能使用 JavaScript 实现动画效果的情况，考虑 requestAnimationFrame、requestIdleCallback
API

>   * 批量进行样式变换，减少布局抖动

>

事实上，上面每一点的背后都包含着很多知识点，例如：

  * 如何理解 requestAnimationFrame 和 60 fps
  * 如何实现 requestAnimationFrame polyfill
  * 哪些操作会触发浏览器 reflow（重排）或者 repaint（重绘）
  * 对于给出的代码，如何进行优化
  * 如何实现滚动时的节流、防抖函数

这些问题，我们会拿出其中几个在下一节分析。同时，订阅课程的朋友们，都可以在下节课末尾彩蛋区获得我在这些主题方向上收藏的文章。

### 总结

工程化优化是一个太大的话题了，本节课我们只是在“大面上”进行方向指引，以面试为角度抛砖引玉，更多具体代码细节实例，下节课我们会继续探讨。

另外，正因为这个话题的特殊性，一千个项目，就有一千个优化场景，也欢迎大家拿出来项目中的具体情况，跟我讨论。

### 分享交流

请大家留言分享「性能优化」方面的经验心得，也可以继续学习下一节等全部完结这个主题之后再分享。阅读文章过程中有任何疑问随时可以跟其他小伙伴讨论，或者直接向作者
LucasHC 提问（作者看到后会抽空解答）。 **你的分享不仅帮助他人，更会提升自己。**

同时，说说自己最想了解的主题，课程内容会根据大家的意见和建议迭代和完善。

此外，我们为本课程付费读者创建了《前端开发核心知识进阶》微信交流群，以方便更有针对性地讨论课程相关问题。（入群请到第1-2课末尾扫描二维码，若失效请加
GitChat 小助手伽利略的微信，ID 为 GitChatty6，并注明「前端核心」。）



## 性能优化问题，老司机如何解决（下）

上一节课，我们从宏观上讲述了性能优化的概念。这一节，我们直接来“手写代码”。

在此之前，我们先回顾一下「性能优化」主题的知识点：

![](https://images.gitbook.cn/a4889460-4ecc-11e9-8044-3de24c2bc492)

### 代码例题实战

“白板写代码”是考察候选人基础能力、思维能力的有效手段。这一部分，我们列举几个性能相关的代码片段，供读者体会。

#### 实战 1：初步解决布局抖动问题

请候选人对以下代码进行优化：

    
    
    var h1 = element1.clientHeight
    element1.style.height = (h1 * 2) + 'px'
    
    var h2 = element2.clientHeight
    element2.style.height = (h2 * 2) + 'px'
    
    var h3 = element3.clientHeight
    element3.style.height = (h3 * 2) + 'px'
    

这是一道较为基础的题目，上面的代码，会造成典型的布局抖动问题。

**布局抖动** 是指 DOM 元素被 JavaScript
多次反复读写，导致文档多次无意义重排。我们知道浏览器很“懒”，它会收集（batch）当前操作，统一进行重排。可是，如果在当前操作完成前，从 DOM
元素中获取值，这会迫使浏览器提早执行布局操作，这称为 **强制同步布局** 。这样的副作用对于低配置的移动设备来说，后果是不堪设想的。

我们对 element1 进行读、写操作之后，又企图去获取 element2 的值，浏览器为了获取正确的值，只能进行重排。优化思路为：

    
    
    // 读
    var h1 = element1.clientHeight
    var h2 = element2.clientHeight
    var h3 = element3.clientHeight
    
    // 写（无效布局）
    element1.style.height = (h1 * 2) + 'px'
    element2.style.height = (h2 * 2) + 'px'
    element3.style.height = (h3 * 2) + 'px'
    

#### 实战 2：使用 window.requestAnimationFrame 对上述代码优化

如果读者对 window.requestAnimationFrame 不熟悉的话，我们先来看一下 MDN 上的说明：

> 该方法告诉浏览器你希望执行的操作，并请求浏览器在下一次重绘之前调用指定的函数来更新。

语法：

    
    
    window.requestAnimationFrame(callback)
    

也就是说，当你需要更新屏幕画面时就可以调用此方法。在浏览器下次重绘前统一执行回调函数，优化方案：

    
    
    // 读
    var h1 = element1.clientHeight
    // 写
    requestAnimationFrame(() => {
        element1.style.height = (h1 * 2) + 'px'
    })
    
    // 读
    var h2 = element2.clientHeight
    // 写
    requestAnimationFrame(() => {
        element2.style.height = (h2 * 2) + 'px'
    })
    
    // 读
    var h3 = element3.clientHeight
    // 写
    requestAnimationFrame(() => {
        element3.style.height = (h3 * 2) + 'px'
    })
    

我们将代码中所有 DOM 的写操作在下一帧一起执行，保留所有 DOM 的读操作在当前同步状态。这样有效减少了无意义的重排，显然效率更高。

#### 实战 3：延伸题目，实现 window.requestAnimationFrame 的 polyfill

polyfill 就是我们常说的垫片，此处指在浏览器兼容性不支持的情况下，备选实现方案。

window.requestAnimationFrame 在一些老版本浏览器中无法兼容，为了让代码在老机器也能运行不报错，请用代码实现：

    
    
    if (!window.requestAnimationFrame) window.requestAnimationFrame = (callback, element) => {
        const id = window.setTimeout(() => {
            callback()
        }, 1000 / 60)
        return id
    }
    if (!window.cancelAnimationFrame) window.cancelAnimationFrame = id => {
        clearTimeout(id)
    }
    

上面的代码按照 1 秒钟 60 次（大约每 16.7 毫秒一次），并使用 window.setTimeout
来进行模拟。这是一种粗略的实现，并没有考虑统一浏览器前缀和 callback 参数等问题。一般需求中，实现上面的答案已经可以符合要求了。

#### 实战 4：为以下每个 li 添加点击事件

    
    
    <div>
        <ul>
            <li>1</li>
            <li>2</li>
            <li>3</li>
            <li>4</li>
            <li>5</li>
            <li>6</li>
            <li>7</li>
            <li>8</li>
            <li>9</li>
            <li>10</li>
        </ul>
    </div>
    

这道题目非常基础，但是实现方式上需要注意是否使用了 **事件委托** 。如果候选人直接对 li
进行绑定处理，那么很容易给面试官留下「平时代码习惯不好」的印象，造成潜在性能负担。更好的做法显然是：

    
    
    window.onload = () => {
        const ul = document.getElementsByTagName('ul')[0]
        const liList = document.getElementsByTagName('li')
    
        ul.onclick = e => {
            const normalizeE = e || window.event
            const target = normalizeE.target || normalizeE.srcElement
    
            if (target.nodeName.toLowerCase() == "li") {
                alert(target.innerHTML)
            }
        }
    }
    

一般情况下，作为面试官，我不会提示候选人采用事件委托的写法，而是观察候选人的第一反应，对其代码习惯进行考察。如果候选人没有采用事件委托的写法，才会进一步追问。

#### 实战 5：实现节流、防抖

我们知道，鼠标滚动（scroll）、调整窗口大小（resize）、敲击键盘（keyup）这类事件在触发时往往频率极高。这时候事件对应的回调函数也会在极短时间内反复执行。想象一下，如果这些回调函数内的逻辑涉及复杂的计算，或者对
DOM 操作非常频繁，从而造成大量布局操作、绘制操作，那么就存在阻塞主线程的危险，直接后果就是掉帧，用户能够感受到明显的卡顿。

有经验的程序员为了规避这样的问题，往往会使用节流（throttle）或者防抖（debounce）来进行处理。因此节流和防抖已经成为非常常见的优化手段，现如今也是面试的必考题型之一。

**节流和防抖总是一起出现，那么它们有什么不同呢？**

回答这个问题，我们首先要知道它们解决的问题相同，方向类似： **两者并不会减少事件的触发，而是减少事件触发时回调函数的执行次数**
。为了达成这个目的，节流和防抖采用的手段有所差别。

  * 防抖：抖动现象本质就是指短时间内高频次触发。因此，我们可以把短时间内的多个连续调用合并成一次，也就是只触发一次回调函数。
  * 节流：顾名思义，就是将短时间的函数调用以一个固定的频率间隔执行，这就如同水龙头开关限制出水口流量。

[这个例子](http://caiogondim.github.io/js-debounce-throttle-visual-
explanation/)可以很形象地展示节流与防抖的区别。

另外，请参考防抖图示：

![](https://images.gitbook.cn/e1a88550-4eac-11e9-8d6d-edc0eec9ca99)

节流图示：

![](https://images.gitbook.cn/e773acd0-4eac-11e9-b1fa-0757868d211c)

了解了原理，我们先来实现事件防抖：

    
    
    // 简单的防抖动函数
    const debounce = (func, wait, immediate) => {
        let timeout
        return function () {
            const context = this
            const args = arguments
    
            const callNow = immediate & !timeout
    
            timeout && clearTimeout(timeout)
    
            timeout = setTimeout(function() {
                timeout = null
                if (!immediate) func.apply(context, args)
            }, wait)
    
            if (callNow) func.apply(context, args)
        }
    }
    
    // 采用了防抖动
    window.addEventListener('scroll', debounce(() => {
        console.log('scroll')
    }, 500))
    
    // 没采用防抖动
    window.addEventListener('scroll', () => {
        console.log('scroll')
    })
    

如代码所示，我们使用 setTimeout 在 500ms 后执行事件回调，如果在这 500ms 内又有相关事件触发，则通过
clearTimeout(timeout) 取消上一次设置的回调。因此在 500ms 内没有连续触发多次 scroll 事件，才会真正触发 scroll
回调函数——或者说，500ms 内的多次调用被归并成了一次，在最后一次“抖动”后，进行回调执行。同时，我们设置了 immediate
参数，用以立即执行。关于 func.apply 的用法，学习过《第 1-1 课：一网打尽 this，对执行上下文说 Yes》的读者应该不会陌生。

关于事件节流：

    
    
    const throttle = (func, wait) => {
        let startTime = 0
        return function() {
            let handleTime = +new Date()
            let context = this
            const args = arguments
    
            if (handleTime - startTime >= wait) {
                func.apply(context, args)
                startTime = handleTime
            }
        }
    }
    
    window.addEventListener('scroll', throttle(() => {
        console.log('scroll')
    }, 500))
    

当然，我们同样可以用 setTimeout 来实现：

    
    
    const throttle = (func, wait) => {
        let timeout 
    
        return function () {
            const context = this
            const args = arguments
            if (!timeout) {
                timeout = setTimeout(function() {
                    func.apply(context, args)
                    timeout = null
              }, wait)
            }
        }
    }
    

与防抖相比，少了 clearTimeout 的操作，请读者细心对比。

要准确理解节流和防抖，需要多动手实践。这里也建议大家有时间研究研究 lodash
库关于节流和防抖的实现。事实上，这个话题还可以玩出很多花来，比如如何暴露给开发者 cancelDebounce，又如上述 throttle
的两种方式各有哪些瑕疵，针对这些瑕疵，是否可以结合两种实现优化？感兴趣的读者请在评论区留言探讨，或者在文末彩蛋部分找到相关内容。

### 总结

性能优化，实在是一个极大的话题，需要我们在平时工作学习中不断积累。对于准备面试的朋友，在面试前，除了时刻注意代码习惯、掌握常见考点以外，还要整理、回顾、复盘平时的性能相关项目。

这一节课难以覆盖性能优化的方方面面，本课程的其他章节，还会有这个话题的相关渗透，如网络协议、缓存策略、数据结构和算法等，这些内容和性能息息相关。请大家持续关注学习，同时欢迎在评论区和其他小伙伴讨论以及向我提问。

课程代码仓库： <https://github.com/HOUCe/lucas-gitchat-courses>

### 彩蛋分享

#### 节流和防抖相关

  * [Debouncing and Throttling Explained Through Examples](https://css-tricks.com/debouncing-throttling-explained-examples/)
  * [谈谈 JS 中的函数节流](https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&mid=2651551467&idx=2&sn=2ce4ce1ec06c32aa698451128985b870&chksm=8025a12ab752283c66f1e529664fcc9fe272d5d500f8daedcc35e85f79baa69b62a208b2235a&scene=0#wechat_redirect)
  * [JavaScript 函数节流和函数防抖之间的区别](https://juejin.im/entry/58a3911b570c35006cdc2d6a)
  * [高性能滚动 scroll 及页面渲染优化](https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&mid=2651552107&idx=1&sn=7ea1a6d4b3cf1c8a99b50f703e4c41f1&chksm=8025aeaab75227bc3bae46270d175bd1444f4983c9472eb93de5fc9c19951416e239dcc4860f&mpshare=1&scene=1&srcid=0419s6nwU8LrOAy4BP2TH3wO&key=14e4edd6ca5f2a5d9d86be4c9f83873bba1ae3395ad7d51553704ab7d15851bb129ead9ae2751548d6e530fcdfb471b1b7fdc9d4576bac260e706ef288ada0c02f31962f40314318bb69347d0284f0c2&ascene=0&uin=NjI4NTQ2ODIx&devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.4+build\(14E46\)&version=12020110&nettype=WIFI&fontScale=100&pass_ticket=OxCcOonsw3hgntyvXy%2FSYPn%2Fw9jx2Hv%2FheV8seAGt987cQT%2FygphdRBJ0UyMTQvc)
  * [从 lodash 源码学习节流与防抖](https://juejin.im/post/5b043309f265da0ba77015e7)
  * [理解并优化函数节流 Throttle](https://juejin.im/post/5be24d76e51d451def13cca2)

#### 浏览器引擎渲染性能相关

  * [Inside look at modern web browser](https://developers.google.com/web/resources/contributors/kosamari)
  * [How Browsers Work: Behind the scenes of modern web browsers](https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/)
  * [How browsers work](http://taligarsiel.com/Projects/howbrowserswork1.htm)
  * [How browser rendering works — behind the scenes](https://blog.logrocket.com/how-browser-rendering-works-behind-the-scenes-6782b0e8fb10)
  * [What Every Frontend Developer Should Know About Webpage Rendering](http://frontendbabel.info/articles/webpage-rendering-101/)
  * [前端文摘：深入解析浏览器的幕后工作原理](https://www.cnblogs.com/lhb25/p/how-browsers-work.html)
  * [从 Chrome 源码看浏览器如何加载资源](https://zhuanlan.zhihu.com/p/30558018)
  * [浏览器内核渲染：重建引擎](https://juejin.im/post/5bbaa7da6fb9a05d3761aafe)
  * [体现工匠精神的 Resource Hints](https://juejin.im/entry/5c26d05d5188257a937fb6b2)
  * [浏览器页面渲染机制，你真的弄懂了吗](https://www.itcodemonkey.com/article/10417.html)
  * [前端不止：Web 性能优化 – 关键渲染路径以及优化策略](https://insights.thoughtworks.cn/critical-rendering-path-and-optimization-strategy/)
  * [浏览器前端优化](https://zcfy.cc/article/optimising-the-front-end-for-the-browser-hacker-noon-2847.html)
  * [浅析前端页面渲染机制](https://mp.weixin.qq.com/s/1kQ-cyQmLfLcYiLiJ_ViwA?)
  * [浅析渲染引擎与前端优化](https://juejin.im/entry/5893fbe88d6d8100582e8b7f)
  * [渲染性能](https://github.com/sundway/blog/issues/2)
  * [Repaint 、Reflow 的基本认识和优化 (2)](https://segmentfault.com/a/1190000002629708)

#### 动画性能相关

  * [Timing control for script-based animations](https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/dev-guides/hh920765\(v=vs.85\))
  * [Gain Motion Superpowers with requestAnimationFrame](https://medium.com/@bdc/gain-motion-superpowers-with-requestanimationframe-ecc6d5b0d9a4)
  * [CSS Animation 性能优化](https://github.com/amfe/article/issues/47)
  * [GSAP的动画快于 jQuery 吗？为何？](https://segmentfault.com/a/1190000000391529)
  * [Javascript 高性能动画与页面渲染](https://juejin.im/entry/58b0187c1b69e60058a09faf)
  * [也许你不知道，JS animation 比 CSS 更快！](https://mp.weixin.qq.com/s?__biz=MzA5NzkwNDk3MQ==&mid=2650585331&idx=1&sn=c2d55ab4c5458d3dcda25188fd608079&source=41#wechat_redirect)
  * [渐进式动画解决方案](https://www.w3cplus.com/animation/progressive-web-animation.html)
  * [你应该知道的 requestIdleCallback](https://juejin.im/post/5ad71f39f265da239f07e862)
  * [无线性能优化：Composite](http://taobaofed.org/blog/2016/04/25/performance-composite/)
  * [优化动画卡顿：卡顿原因分析及优化方案](https://juejin.im/post/5c8a1db15188257e9044ec52)
  * [一篇文章说清浏览器解析和 CSS（GPU）动画优化](https://mp.weixin.qq.com/s/kC7RmozaG5bWjIqdiZat7A?)

#### 实战案例相关

  * [Building the Google Photos Web UI](https://medium.com/google-design/google-photos-45b714dfbed1)
  * [A Netflix Web Performance Case Study](https://medium.com/dev-channel/a-netflix-web-performance-case-study-c0bcde26a9d9)
  * [The Cost Of JavaScript In 2018](https://medium.com/@addyosmani/the-cost-of-javascript-in-2018-7d8950fbb5d4)
  * [How we reduced our initial JS/CSS size by 67%](https://dev.to/goenning/how-we-reduced-our-initial-jscss-size-by-67-3ac0?utm_source=mybridge&utm_medium=blog&utm_campaign=read_more?add=add)
  * [Front-End Performance Checklist 2019](https://www.smashingmagazine.com/2019/01/front-end-performance-checklist-2019-pdf-pages/)
  * [网站性能优化实战——从 12.67s 到 1.06s 的故事](https://imweb.io/topic/5b6fd3c13cb5a02f33c013bd)
  * [前端黑科技：美团网页首帧优化实践](https://mp.weixin.qq.com/s?__biz=MzUxMzcxMzE5Ng==&mid=2247489935&idx=1&sn=f59537133b8548caf5a513ee95ecc1be&chksm=f951acccce2625da71bacdb5cd814bcdc8900c293c56662bbad6e39af40ebd451837d3866404&token=1623409489&lang=zh_CN&scene=21#wechat_redirect)
  * [Web 字体图标-自动化方案](https://juejin.im/post/5c398a81e51d4551e13b88f3?add=asd)
  * [JS 加载慢？谷歌大神带你飞!](https://mp.weixin.qq.com/s/uWuzwE1jPHbd73Y3UiyezA)
  * [前端性能优化（三） 移动端浏览器前端优化策略](https://my.oschina.net/zhangstephen/blog/1601383?from=juejin)
  * [CSS @font-face 性能优化](https://juejin.im/post/5c7e578de51d4541c11413fc)
  * [移动 Web 性能优化从入门到进阶](https://juejin.im/post/5c931c4a6fb9a070dc28923b)
  * [记一次惊心动魄的前端性能优化之旅](https://segmentfault.com/a/1190000005147979)

### 分享交流

请大家留言分享「性能优化」方面的经验心得。阅读文章过程中有任何疑问随时可以跟其他小伙伴讨论，或者直接向作者 LucasHC 提问（作者看到会抽空解答）。
**你的分享不仅帮助他人，更会提升自己。**

你也可以说说自己最想了解的主题，课程内容会根据部分读者的意见和建议迭代和完善。

此外，我们为本课程付费读者创建了《前端开发核心知识进阶》微信交流群，以方便更有针对性地讨论课程相关问题。（入群请到第1-2课末尾扫描二维码，若失效请加
GitChat 小助手伽利略的微信，ID 为 GitChatty6，注明「前端核心」。）



## 以 React 为例，说说框架和性能（上）

在上一节课中，我们提到了性能优化。在这个话题上，除了工程化层面的优化和语言层面的优化以外，框架性能也备受瞩目。这一节课，我们就来聊聊框架的性能话题，并以
React 为例进行分析。

主要知识点如下：

![enter image description
here](https://images.gitbook.cn/dd24aad0-cbf3-11e9-a9bd-857608719494)

### 框架性能到底指什么

说起框架的性能话题，很多读者可能会想到“不要过早地做优化”这条原则。实际上，大部分应用的复杂度并不会对性能和产品体验构成挑战。毕竟在之前课程中我们学习到，现代化的框架凭借高效的虚拟
DOM diff 算法和（或）响应式理念，以及框架内部引擎，已经做得较为完美了，一般项目需求对性能的压力并不大。

但是对于一些极其复杂的需求，性能优化是无法回避的。如果你开发的是图形处理应用、DNA
检测实验应用、富文本编辑器或者功能丰富的表单型应用，则很容易触碰到性能瓶颈。同样，作为框架的使用者，也需要对性能优化有所了解，这对于理解框架本身也是有很大帮助的。

前端开发自然离不开浏览器，而性能优化大都在和浏览器打交道。我们知道，页面每一帧的变化都是由浏览器绘制出来的，并且这个绘制频率受限于显示器的刷新频率，因此一个重要的性能数据指标是每秒
60 帧的绘制频率。这样进行简单的换算之后，每一帧只有 16.6ms 的绘制时间。

如果一个应用对用户的交互响应处理过慢，则需要花费很长的时间来计算更新数据，这就造成了应用缓慢、性能低下的问题，被用户感知造成极差的用户体验。对于框架来说，以
React 为例，开发者不需要额外关注 DOM 层面的操作。因为 React 通过维护虚拟 DOM 及其高效的 diff 算法，可以决策出每次更新的最小化
DOM batch 操作。 **但实际上，使用 React 能完成的性能优化，使用纯原生的 JavaScript 都能做到，甚至做得更好。只不过经过
React 统一处理后，大大节省了开发成本，同时也降低了应用性能对开发者优化技能的依赖。**

**因此现代框架的性能表现，除了想办法缩减自身的 bundle size 之外，主要优化点就在于框架本身运行时对 DOM
层操作的合理性以及自身引擎计算的高效性。** 这一点我们会通过两节课程来慢慢展开。

### React 的虚拟 DOM diff

React 主要通过以下几种方式来保证虚拟的 DOM diff 算法和更新的高效性能：

  * 高效的 diff 算法
  * Batch 操作
  * 摒弃脏检测更新方式

当任何一个组件使用 setState 方法时，React 都会认为该组件变“脏”，触发组件本身的重新渲染（re-render）。同时因其始终维护两套虚拟的
DOM，其中一套是更新后的虚拟的 DOM；另一套是前一个状态的虚拟的 DOM。通过对这两套虚拟的 DOM 的 diff
算法，找到需要变化的最小单元集，然后把这个最小单元集应用在真实的 DOM 当中。

而通过 diff 算法找到这个最小单元集后，React 采用启发式的思路进行了一些假设，将两棵 DOM 树之间的 diff 成本由 O(n3) 缩减到
O(n)。

说到这里，你一定很想知道 React 的那些大胆假设吧：

  * DOM 节点跨层级移动忽略不计
  * 拥有相同类的两个组件生成相似的树形结构，拥有不同类的两个组件生成不同的树形结构

根据这些假设，ReactJS 采取的策略如下：

  * React 对组件树进行分层比较，两棵树只会对同一层级的节点进行比较
  * 当对同一层级节点进行比较时，对于不同的组件类型，直接将整个组件替换为新类型组件

对于下图所示的组件结构，我们可以想象：如果子组件 B 和 H 的类型同时发生变化，当遍历到 B 组件时，直接进行新组件的替换，减少了不必要的消耗。

![enter image description
here](https://images.gitbook.cn/33f3e140-c6d7-11e9-99c1-c37abd23c4b1)

  * 当对同一层级节点进行比较时，对于相同的组件类型，如果组件的 state 或 props 发生变化，则直接重新渲染组件本身。开发者可以尝试使用 shouldComponentUpdate 生命周期函数来规避不必要的渲染。
  * 当对同一层级节点进行比较时，开发者可以使用 key 属性来“声明”同一层级节点的更新方式。

另外，setState 方法引发了“蝴蝶效应”，并通过创新的 diff 算法找到需要更新的最小单元集，但是这些变更也并不一定立即同步产生。实际上，React
会进行 setState 的 batch 操作，通俗地讲就是“积攒归并”一批变化后，再统一进行更新。显然这是出于对性能的考虑。

### 提升 React 应用性能的建议

我们知道，React 渲染真实的 DOM 节点的过程由两个主要过程组成：

  * 对 React 内部维护的虚拟的 DOM 进行更新
  * 前后两个虚拟 DOM 比对，并将 diff 所得结果应用于真实的 DOM 中的过程

这两步极其关键，设想一下，如果虚拟的 DOM 更新很慢，那么重新渲染势必会很耗时。本节我们就针对此问题，对症下药，来了解更多的性能优化小技巧。

#### 最大限度地减少 re-render

为了提升 React 应用性能，我们首先想到的就是最大限度地规避不必要的 re-render。但是当状态发生变化时，重新渲染是 React
内部的默认行为，我们如何保证不必要的渲染呢？

最先想到的一定是使用 shouldComponentUpdate 生命周期函数，它旨在对比前后状态 state/props
是否出现了变更，根据是否变更来决定组件是否需要重新渲染。

实际上，还有很多方式，开发者都可以给 React 发送“不需要渲染”的信号。

比如，无状态组件返回同一个 element 实例：如果 render 方法返回同一个 element 实例，React
会认为组件并没有发生变化。请参考以下代码：

    
    
    class MyComponent extends Component {
      text = "";
      renderedElement = null;
      _render() {
        return <div>{this.props.text}</div>
      }
      render() {
        if (!this.renderedElement || this.props.text !== this.text) {
          this.text = this.props.text;
          this.renderedElement = _render();
        }
        return this.renderedElement;
      }
    

熟悉 lodash 库的读者，可能会想到其带来的 memoize 函数，同样可以用来简化上述代码：

    
    
    import memoize from 'lodash/memoize'
    
    class MyComponent extends Component {
      _render = memoize((text) => <div>{text}</div>)
      render() {
        return _render(this.props.text)
      }
    }
    

在之前介绍的高阶组件的基础上，我们不妨设想这样一类高阶组件：它能够细粒度地控制组件的渲染行为。比如，某个组件仅仅在某一项 props 变化时才会触发 re-
render。这样一来，开发者可以完全掌控组件渲染时机，更有针对性地进行渲染优化。

这样的方法有点类似于农业灌溉上的“滴灌”技术，它规避了代价昂贵的粗暴型灌溉，而是精准地定位需求，从而达到节约水资源的目的。

在社区中，优秀的 recompose 库恰好可以满足我们的需求。请参考如下代码：

    
    
    @onlyUpdateForKeys(['prop1', 'prop2'])
    class MyComponent2 extends Component {
      render() {
          //...
      }
    }
    

使用 @onlyUpdateForKeys 修饰器，MyComponent2 组件只在 prop1 和 prop2 变化时才进行渲染；否则其他的 props
发生任何改变，都不会触发 re-render。

藏在 onlyUpdateForKeys 背后的“黑魔法”其实并不难理解，只需要在高阶组件中调用 shouldComponentUpdate 方法，在
shouldComponentUpdate 方法中比较对象由完整的 props 转为传入的指定 props 即可。有兴趣的读者，可以翻阅 recompose
源码进行了解，其实思路即是如此。

#### 规避 inline function 反模式

我们需要注意一个“反模式”。当使用 render 方法时，要留意 render
方法内创建的函数或者数组等，这些创建可能是显式地，也可能是隐式生成。因为这些新生成的函数或数组，在量大时会造成一定的性能负担。同时 render
方法经常被反复执行多次，也就是说总有新的函数或数组被创建，这样造成内存无意义开销。往往性能更友好的做法只需要它们创建一次即可，而不是每次渲染都被创建。比如：

    
    
    render() {
      return <MyInput onChange={this.props.update.bind(this)} />;
    }
    

或者：

    
    
    render() {
      return <MyInput onChange={() => this.props.update()} />;
    }
    

对于 render 方法内产生数组或其他类型的情况，也存在类似问题：

    
    
    render() {
      return <SubComponent items={this.props.items || []}/>
    }
    

这样做会在每次渲染且 this.props.items 不存在时创建一个空数组。更好的做法是：

    
    
    const EMPTY_ARRAY = []
    render() {
        return <SubComponent items={this.props.items || EMPTY_ARRAY}/>
    }
    

事实上，不得不说，这些性能副作用或者优化手段都“微乎其微”，并不是性能恶化的“罪魁祸首”。但是理解这些内容对我们编写出高质量的代码还是有帮助的。我们后续课程会针对这种情况进行框架层面上的启发式探索。

#### 使用 PureComponent 保证开发性能

PureComponent 大体与 Component 相同，唯一不同的地方是 PureComponent 会自动帮助开发者使用
shouldComponentUpdate 生命周期方法。也就是说，当组件 state 或者 props 发生变化时，正常的 Component
都会自动进行 re-render，在这种情况下，shouldComponentUpdate 默认都会返回 true。但是 PureComponent
会先进行对比，即比较前后两次 state 和 props 是否相等。需要注意的是，这种对比是浅比较：

    
    
    function shallowEqual (objA: mixed, objB: mixed) {
        if (is(objA, objB)) {
            return true;
        }
    
        if (typeof objA !== 'object' || objA === null ||
            typeof objB !== 'object' || objB === null) {
            return false;
        }
    
        const keysA = Object.keys(objA);
        const keysB = Object.keys(objB);
    
        if (keysA.length !== keysB.length) {
            return false;
        }
    
        for (let i = 0; i < keysA.length; i++) {
            if (
            !hasOwnProperty.call(objB, keysA[i]) ||
            !is(objA[keysA[i]], objB[keysA[i]])
            ) {
                return false;
            }
        }
    
        return true;
    }
    

基于以上代码，我们总结出使用 PureComponent 需要注意如下细节：

  * 既然是浅比较，也就是说，当与前一状态下的 props 和 state 比对时，如果比较对象是 JavaScript 基本类型，则会对其值是否相等进行判断；如果比较对象是 JavaScript 引用类型，比如 object 或者 array，则会判断其引用是否相同，而不会进行值比较；
  * 开发者需要避免共享（mutate）带来的问题。

如果在一个父组件中对 object 进行了 mutate 的操作，若子组件依赖此数据，且采用PureComponent 声明，那么子组件将无法进行更新。尽管
props 中的某一项值发生了变化，但是它的引用并没有发生变化，因此 PureComponent 的 shouldComponentUpdate 也就返回了
false。更好的做法是在更新 props 或 state 时，返回一个新的对象或数组。

#### 分析一个真实案例

设想一下，如果应用组件非常复杂，含有一个具有很长 list 的组件，如果只是其中一个子组件发生了变化，那么使用 PureComponent
进行对比，有选择性地进行渲染，一定是比所有列表项目都重新渲染划算很多。

我们来看一个案例：简易实现一个采用 PureComponent 和不采用 PureComponent
的性能差别对比试验。假如在页面中需要渲染非常多的用户信息，所有的用户信息都被维护在一个 users 数组当中，数组的每一项为一个 JavaScript
对象，表示一个用户的基本信息。User 组件负责渲染每一个用户的信息内容：

    
    
    import User from './User'
    const Users = ({users}) =>
        <div>
            {users.map(user => <User {...user} />}
        </div>
    

这样做存在的问题是：users 数组作为 Users 组件的 props 出现，users 数组的第 K 项发生变化时，users
数组即发生变化，Users 组件重新渲染导致所有的 User 组件都会进行渲染。某个 User 组件，即使非 K 项并没有发生变化，这个 User
组件不需要重新渲染，但也不得不必要的渲染。

在测试中，我们渲染了一个有 200 项的数组：

    
    
    const arraySize = 200;
    const getUsers = () =>
      Array(arraySize)
        .fill(1)
        .map((_, index) => ({
          name: 'John Doe',
          hobby: 'Painting',
          age: index === 0 ? Math.random() * 100 : 50
        }));
    

注意：在 getUsers 方法中，对 age 属性进行了判断，保证每次调用时，getUsers 返回的数组只有第一项的 age 属性不同，其余的全部为
50。在测试组件中，在 componentDidUpdate 中保证数组将会触发 400 次 re-render，并且每一次只改变数组第一项的 age
属性，其他的均保持不变。

    
    
      const repeats = 400;
      componentDidUpdate() {
        ++this.renderCount;
        this.dt += performance.now() - this.startTime;
        if (this.renderCount % repeats === 0) {
          if (this.componentUnderTestIndex > -1) {
            this.dts[componentsToTest[this.componentUnderTestIndex]] = this.dt;
            console.log(
              'dt',
              componentsToTest[this.componentUnderTestIndex],
              this.dt
            );
          }
          ++this.componentUnderTestIndex;
          this.dt = 0;
          this.componentUnderTest = componentsToTest[this.componentUnderTestIndex];
        }
        if (this.componentUnderTest) {
          setTimeout(() => {
            this.startTime = performance.now();
            this.setState({ users: getUsers() });
          }, 0);
        } 
        else {
          alert(`
            Render Performance ArraySize: ${arraySize} Repeats: ${repeats}
            Functional: ${Math.round(this.dts.Functional)} ms
            PureComponent: ${Math.round(this.dts.PureComponent)} ms
            Component: ${Math.round(this.dts.Component)} ms
          `);
        }
      }
    

下面对三种组件声明方式进行对比。

  * 函数式方式

    
    
    export const Functional = ({ name, age, hobby }) => (
      <div>
        <span>{name}</span>
        <span>{age}</span>
        <span>{hobby}</span>
      </div>
    )
    

  * PureComponent 方式

    
    
    export class PureComponent extends React.PureComponent {
      render() {
        const { name, age, hobby } = this.props;
        return (
          <div>
            <span>{name}</span>
            <span>{age}</span>
            <span>{hobby}</span>
          </div>
        )
      }
    }
    

  * 经典 class 方式

    
    
    export class Component extends React.Component {
      render() {
        const { name, age, hobby } = this.props;
        return (
          <div>
            <span>{name}</span>
            <span>{age}</span>
            <span>{hobby}</span>
          </div>
        )
      }
    

在使用 PureComponent 声明的组件中，会自动在触发渲染前后进行 {name, age, hobby} 对象值比较。如果没有发生变化，则
shouldComponentUpdate 返回 false，以规避不必要的渲染。因此，使用 PureComponent
声明的组件性能明显优于其他方式。在不同的浏览器环境下，可以得出：

  * 在 Firefox 下，PureComponent 收益 30%
  * 在 Safari 下，PureComponent 收益 6%
  * 在 Chrome 下，PureComponent 收益 15%

实际上，我们通过定义 changedItems 来表示变化数组的项目，array
表示所需渲染的数组。changedItems.length/array.length
的比值越小，表示数组中变化的元素也越少，React.PureComponent 涉及的性能优化也越有必要实施，因为 React.PureComponent
通过浅比较规避了不必要的更新过程，而浅比较自身的计算成本一般都不值一提，可以节约成本。

当然，PureComponent 也不是万能的，尤其是它的浅比较，需要开发者格外注意。因此在特定情况下，开发者根据需求自己实现
shouldComponentUpdate 中的比较逻辑，将是更高效的选择。

### 总结

性能优化是前端开发中一个永恒的话题，不同框架之间的性能对比也一直是各位开发者关注的方面。性能涉及方方面面，如前端工程化、浏览器解析和渲染、比较算法等。本章主要介绍了
React 框架在性能上的优劣、虚拟的 DOM 思想，以及在开发 React 应用时需要注意的性能优化环节和手段。
也许不是每个应用都会面临性能的问题，如同社区中所说的：“过早地进行性能优化是毫无必要的，但是开发者在性能优化方面的积累却要时刻先行。”同时，优化手段也在与时俱进，不断更新，需要开发者时刻保持学习。

### 分享交流

请大家留言分享「性能优化」方面的经验心得。阅读文章过程中有任何疑问随时可以跟其他小伙伴讨论，或者直接向作者 LucasHC 提问（作者看到会抽空解答）。
**你的分享不仅帮助他人，更会提升自己。**

你也可以说说自己最想了解的主题，课程内容会根据部分读者的意见和建议迭代和完善。

此外，我们为本课程付费读者创建了《前端开发核心知识进阶》微信交流群，以方便更有针对性地讨论课程相关问题。（入群请到第1-2课末尾扫描二维码，若失效请加
GitChat 小助手伽利略的微信，ID 为 GitChatty6，注明「前端核心」。）



## 以 React 为例，说说框架和性能（下）

在上一讲中，我们提到了框架性能优化的一些基本概念，并分析了以 React
框架为代表的常用优化手段。但是这些内容还不够，需要了解更多框架设计底层的性能相关话题。这一讲，我将会以 Vue（未来新版本 3.0）和 React
为主，分析这两个框架在设计层面，而非使用层面的性能考量。

相关知识点如下图所示：

![enter image description
here](https://images.gitbook.cn/dd24aad0-cbf3-11e9-a9bd-857608719494)

### React 性能设计亮点

React 设计上的性能亮点非常多，除了“老生常谈”的虚拟 DOM 之外，还有很多不为人知的细节，比如事件机制（合成和池化）、React fiber 设计。

#### React 性能设计亮点之事件

React 事件机制我们前面已经有所介绍，总结一下性能亮点的体现有：

  * 将所有事件挂载到 document 节点上，利用事件代理实现优化；
  * 采用合成事件，在原生事件的基础上包装合成事件，并结合池化思路实现内存保护。

前面课程《第 4-2 课：你真的懂 React 吗？》已经介绍过相关内容，这里不再展开。

#### React 性能设计亮点之 setState

setState 这个谜之 API 我们也有所介绍，其异步（或者叫做 batch 合并）设计也是出于性能的考虑。这种优化思路已经被很多框架所借鉴，Vue
当中也是有类似的设计。

#### React 性能设计亮点之 React fiber

前面两个“亮点”我们在以往的课程中已经有所涉及，这里来重点说一下 React fiber。

通过课程《第 2-1 和 2-2 课：异步不可怕“死记硬背”+ 实战拿下》，我们知道在浏览器主线程中，JavaScript 代码在调用栈 call
stack 执行时，可能会调用浏览器的 APIs，对 DOM 进行操作；也可能执行一些异步任务：这些异步任务如果是以回调的方式处理，那么往往会被添加到
event queue 当中；如果是以 promise 处理，就会先放到 job queue
当中。这个涉及到宏任务和微任务，这些异步任务和渲染任务将会在下一个时序当中由调用栈处理执行。

理解了这些，大家就会明白：如果调用栈 call stack 运行一个很耗时的脚本，比如解析一个图片，call stack
就会像北京上下班高峰期的环路入口一样，被这个复杂任务堵塞。主线程其他任务都要排队，进而阻塞 UI 响应。这时候用户点击、输入、页面动画等都没有了响应。

这样的性能瓶颈，就如同阿喀琉斯之踵一样，在一定程度上限制着 JavaScript 的发挥。

我们一般有两种方案突破上文提到的瓶颈，其中之一就是将耗时高、成本高、易阻塞的长任务切片，分成子任务，并异步执行。

这样一来，这些子任务会在不同的 call stack tick 周期执行，进而主线程就可以在子任务间隙当中执行 UI
更新操作。设想一个常见的场景：如果我们需要渲染一个由十万条数据组成的列表，那么相比一次性渲染全部数据，我们可以将数据分段，使用 setTimeout API
去分步处理，构建渲染列表的工作就被分成了不同的子任务在浏览器中执行。在这些子任务间隙，浏览器得以处理 UI 更新。

React 在 JavaScript 执行层面花费的时间较多，这是因为下面一系列复杂过程所造成的：

> Virtual DOM 构建 → 计算 DOM diff → 生成 render patch

也就是说，在一定程度上：React 著名的调度策略 -- stack reconcile 是 React 的性能瓶颈。因为 React stack
reconcile 过程会深度优先遍历所有的 Virtual DOM 节点，进行 diff。整棵 Virtual DOM
树计算完成之后，将任务出栈释放主线程。因此，浏览器主线程被 React
更新状态任务占据的时候，用户与浏览器进行任何交互都不能得到反馈，只有等到任务结束，才能得到浏览器的响应。

我们来看一个典型的场景，来自文章：[React 的新引擎—React
Fiber是什么？](https://link.zhihu.com/?target=http%3A//www.infoq.com/cn/articles/what-
the-new-engine-of-react)

这个例子会在页面中创建一个输入框、一个按钮、一个 BlockList 组件。BlockList 组件会根据 NUMBER_OF_BLOCK
数值渲染出对应数量的数字显示框，数字显示框显示点击按钮的次数。

![enter image description
here](https://images.gitbook.cn/06d42e30-cd4f-11e9-b3e5-eb0a42842eb1)

在这个例子中，我们可以设置 NUMBER_OF_BLOCK 的值为 100000，表示渲染 100000 个矩形框。这时候点击按钮，触发
setState，页面开始更新。此时点击输入框，输入一些字符串，比如 “hi，react”，可以看到：页面没有任何响应；等待 7s
之后，输入框中突然出现了之前输入的 “hireact”。同时，BlockList 组件也更新了。

显而易见，这样的用户体验并不好。

浏览器主线程在这 7s 的 performance 如下图所示：

![enter image description
here](https://images.gitbook.cn/2dbfb640-cd4f-11e9-a968-ffa0ed414b87)

  * 黄色部分：是 JavaScript 执行时间，也是 React 占用主线程的时间。
  * 紫色部分：是浏览器重新计算 DOM Tree 的时间。
  * 绿色部分：是浏览器绘制页面的时间。

这三种任务，总共占用浏览器主线程 7s 的时间，此时间内浏览器无法与用户交互。主要是黄色部分执行时间较长，占用了 6s，即 React
较长时间占用主线程，导致主线程无法响应用户输入。这就是一个典型的例子。

React 核心团队很早之前就预知性能风险的存在，并且持续探索可解决的方式。基于浏览器对 requestIdleCallback 和
requestAnimationFrame 这两个 API 的支持，React 团队实现新的调度策略 —— Fiber reconcile。

在应用 React Fiber 的场景下，重复刚才的例子，不会再出现页面卡顿，交互自然而顺畅。

浏览器主线程的 performance 如下图所示：

![enter image description
here](https://images.gitbook.cn/4b852c00-cd4f-11e9-a968-ffa0ed414b87)

可以看到：在黄色 JavaScript 执行过程中，也就是 React 占用浏览器主线程期间，浏览器也在重新计算 DOM
Tree，并且进行重绘。直观来看，黄色和紫色等互相交替，同时页面截图显示，用户输入得以及时响应。简单说，在 React
占用浏览器主线程期间，浏览器也在与用户交互。这显然是“更好的性能”表现。

### 从 Vue 3.0 动静结合的 Dom diff 谈起

Vue3.0 提出的动静结合的 DOM diff 思想，我个人认为是 Vue 近几年在“创新”上的一个很好体现。之所以能够做到动静结合的 DOM
diff，或者把这个问题放得更大：之所以能够做到预编译优化，是因为 Vue core 可以静态分析 template，在解析模版时，整个 parse
的过程是利用正则表达式顺序解析模板，当解析到开始标签、闭合标签和文本的时候都会分别执行对应的回调函数，来达到构造 AST 树的目的。

![enter image description
here](https://images.gitbook.cn/945db370-cd4f-11e9-a6b5-097d100ec5bd)

这个过程换成代码如下：

![enter image description
here](https://images.gitbook.cn/4f04c060-cd50-11e9-b604-8f8ee8a124cd)

借助预编译过程，Vue 可以做到的预编译优化就很强大了。比如在预编译时标记出模版中可能变化的组件节点，再次进行渲染前 diff
时就可以跳过“永远不会变化的节点”，而只需要对比“可能会变化的动态节点”。这也就是动静结合的 DOM diff 将 diff
成本与模版大小正相关优化到与动态节点正相关的理论依据。

类似地，我们也可以标记出来一些“快速通道（fast path）”。比如某个复杂的组件之所以 className
发生变化（这个场景很常见，我们根据变量，通过更改 className 来应用不同的样式）。针对这种场景，我们在预编译阶段进行特定的标记，在重新渲染 diff
时只需要更新新的 className 即可。

#### 预编译优化的本质是什么？

我关心的是：React 能否像 Vue 那样进行预编译优化？

Vue 需要做数据双向绑定，需要进行数据拦截或代理，那它就需要在预编译阶段静态分析模版，分析出视图依赖了哪些数据，进行响应式处理。而 React
就是局部重新渲染，React 拿到的或者说掌管的，所负责的就是一堆递归 React.createElement 的执行调用，它无法从模版层面进行静态分析。

比如这样的 JSX：

    
    
    <div>
        <p>
            <span> This is a test </span>
        </p>
    </div>
    

将会被编译为：

    
    
    React.createElement(
      "div", null, 
      React.createElement(
        "p", null, 
        React.createElement(
          "span", null, "This is a test"
        )
      )
    )
    

因此 React JSX 过度的灵活性导致运行时可以用于优化的信息不足。但是，在 React
框架之外，我们作为开发者还是可以通过工程化手段达到类似的目的，因为我们能够接触到 JSX 编译成 React.createElement
的整个过程。开发者在项目中开发 babel 插件，实现 JSX 编译成 React.createElement，那么优化手段就是是从编写 babel
插件开始：

如图：

![enter image description
here](https://images.gitbook.cn/883ba9c0-cd50-11e9-b604-8f8ee8a124cd)

那么到底开发者应该怎么做，实现预编译优化呢？

为此我挑出了一些具有代表性的案例，这些案例都是由开发者开发 Babel plugin 实现的 React 预编译手段。

##### **Hoist constant elements**

将静态不变的节点在预编译阶段就抽象成函数或者静态变量，这个和 Vue
框架内所做的一样，不过需要开发者实现，这样一来就不需要在每次重新渲染时生成多余实例，只需要调用 _ref 变量即可。

    
    
    const _ref = <span>Hello World</span>
    
    class MyComponent extends React.Component {
      render() {
        return (
          <div className={this.props.className}>
            {_ref}
          </div>
        )
      }
    }
    

##### **remove propTypes in runtime**

PropTypes 提供了许多验证工具，用来帮助确定 React 组件中 props 数据的有效性。但是，React v15.5 后就被移除了
PropTypes ，因此现在使用 prop-types 库代替。

propTypes 对于业务开发非常有用，帮助我们弥补了 JS 数据类型检查的不足。但是在线上代码中，propTypes 是多余的。

因此在运行时代码删除 propTypes 就变的比较有必要了。

##### **remove inline functions and varaibles**

第三个优化场景是这样的：我们知道组件内如果存在函数生成（箭头函数定义，bind
使用）或者闭包变量的情况下，组件每一次刷新，都会生成一个新的函数或者闭包变量。我们将这种不必要的函数称为 inline functions。

比如下面这段代码中，transformeData 和 onClick 对应的匿名函数，都会随着组件渲染重新生成一个全新的引用。

    
    
    export default ({ data, sortComparator, filterPredicate, history }) => {
    
      const transformedData = data
        .filter(filterPredicate)
        .sort(sortComparator)
    
      return (
        <div>
          <button 
            className="back-btn" 
            onClick={() => history.pop()} 
          />
          <ul className="data-list">
            {transformedData.map(({ id, value }) => (
              <Item value={value}>
            ))}
          </ul>
        </div>
      )
    }
    

反复生成这些 inline functions 或者数据，这对于 React 运行时性能或多或少会有一点影响，也带来了 GC 压力。

我们在工程中，可以通过插件对 inline functions 或者变量进行内存持久化处理。最终经过预编译优化后的代码为：

    
    
     let _anonymousFnComponent
    
    export default ({ data, sortComparator, filterPredicate, history }) => {
    
      const transformedData = React.useMemo(
        () =>
        data.filter(filterPredicate).sort(sortComparator),
        [data, data.filter, filterPredicate, sortComparator]
      )
    
      return React.createElement(_anonymousFnComponent = _anonymousFnComponent || (() => {
    
        const _onClick2 = React.useCallback(
          () => history.pop(), 
          [history, history.pop]
        )
    
        return (
          <div>
            <button className="back-btn" onClick={_onClick2} />
            <ul className="data-list">
              {transformedData.map(({ id, value }) =>
                React.createElement(
                  //...
                )
              )}
            </ul>
          </div>
        )
      }), null)
    }
    

我们使用了 React 新特性 useMemo 和 useCallback 将这些变量包裹。 useMemo 和 useCallback
都会在组件第一次渲染的时候执行，之后会在其依赖的变量，也就是 useMemo 和 useCallback
的第二个参数数组，数组内的数值发生改变时再次执行；这两个 hooks 都返回缓存的值，useMemo 返回缓存的变量，useCallback
返回缓存的函数。

我们看代码，transformeData 在其数据源：data,data.filter,filterPredicate,sortComparator
发生变化时才会更新，才会重新生成一份
transformeData，函数渲染时只要依赖的data,data.filter,filterPredicate,sortComparator
不变，不会重新生成 transformeData，而是使用缓存的值。onClick 也使用了 useCallback 将函数引用持久化保存，道理一样。

这样一来就避免了在组件重新渲染时，总是生成不必要的 inline functions 和闭包变量的困扰。

##### **transform to stateless function component**

我们知道函数式组件虽然未来会比 class 声明的组件性能更好，并且函数不管是从性能上、可组合性上还是 TS 契合度上，都要要优于 class 使用。

这个例子，我们将符合条件的 class 声明组件自动在预编译阶段转化为函数式组件。

我们的目标是：

    
    
    class MyComponent extends React.Component {
      static propTypes = {
        className: React.PropTypes.string.isRequired
      }
    
      render() {
        return (
          <div className={this.props.className}>
            <span>Hello World</span>
          </div>
        )
      }
    }
    

在预编译阶段优化为：

    
    
    const MyComponent = props => 
      <div className={props.className}>
        <span>Hello World</span>
      </div>
    
    MyComponent.propTypes = {
      className: React.PropTypes.string.isRequired
    }
    

在这里我们展开实现一下 Babel plugin 的编写，其中会涉及到一些 AST 的内容，读者只需明白思想方向即可。

    
    
    module.exports = function({ types: t }) {
      return {
        visitor: {
          Class(path) {
            const state = {
              renderMethod: null,
              properties: [],
              thisProps: [],
              isPure: true
            }
    
            path.traverse(bodyVisitor, state)
    
            let replacement = []
    
            state.thisProps.forEach(function(thisProp) {
              thisProp.replaceWith(t.identifier('props'))
              thisProp.replaceWith(t.identifier('props'))
            })
    
            replacement.push(
              t.functionDeclaration(
                id,
                [t.identifier('props')],
                state.renderMethod.node.body
              )
            )
    
            state.properties.forEach(prop => {
              replacement.push(t.expressionStatement(
                t.assignmentExpression('=',
                  t.MemberExpression(id, prop.node.key),
                  prop.node.value
                )
              ))
            })
    
            if (t.isExpression(path.node)) {
              replacement.push(t.returnStatement(id))
    
              replacement = t.callExpression(
                t.functionExpression(null, [],
                  t.blockStatement(replacement)
                ),
                []
              )
            }
    
            path.replaceWithMultiple(
              replacement
            )
          }
        }
      }
    
      const bodyVisitor = {
        ClassMethod(path) {
          if (path.node.key.name === 'render') {
            this.renderMethod = path
          } else {
            this.isPure = false
            path.stop()
          }
        },
    
        ClassProperty(path) {
          const name = path.node.key.name
    
          if (path.node.static && (
            name === 'propTypes' ||
            name === 'defaultProps'
          )) {
            this.properties.push(path)
          } else {
            this.isPure = false
            this.isPure = false
          }
        },
    
        MemberExpression(path) {
          this.thisProps.push(path)
        },
    
        JSXIdentifier(path) {
          if (path.node.name === 'ref') {
            this.isPure = false
            path.stop()
          }
        }
      }
    }
    

代码分析：我们先明确，什么样的 class 组件，具备转换成函数式组件的条件？

首先，class 组件不能具有 this.state 的引用，组件不能出现任何生命周期方法，也不能出现
createRef，因为这些特性在函数式组件中并不存在。

满足这样的条件时，我们在进行 JSX 转换过程进行组件替换：通过 AST 进行遍历， 首先在遍历过程中找到符合条件的 class 组件，是否符合条件我们用
isPure 来进行标记， 同时在遍历时，对每一个符合条件的 class 组件，储存 render 方法，作为转换函数式组件的返回值；储存
propTypes 和 defaultProps 静态属性，之后会挂载在函数组件函数属性上；同时对 this.props 的用法转为 props,
props 作为函数式组件的参数出现 最后在按照上述规则，修改 AST 树，新的 AST 树相关组件节点会生成函数式组件。

#### Prepack 对于框架的影响

Prepack 同样是 FaceBook 团队的作品。它让你编写普通的 JavaScript
代码，它在构建阶段就试图了解代码将做什么，然后生成等价的代码，减少了运行时的计算量。

我们看一个 fibonacci 数列求和的例子，再经过 prepack 处理之后，直接输出结果，运行时就是一个 610 这么一个结果。这么看 prepack
是一个 JavaScript 的部分求值器（Partial Evaluator），可在编译时执行原本在运行时的计算过程，并通过重写 JavaScript
代码来提高其执行效率。

我就用 Prepack 结合 React 尝了个鲜：

![enter image description
here](https://images.gitbook.cn/a720c050-cd50-11e9-a6b5-097d100ec5bd)

![enter image description
here](https://images.gitbook.cn/b89d11d0-cd50-11e9-a968-ffa0ed414b87)

上图左边部分是我编写的代码，在不使用 prepack 情况下，运行时代码如右边所示：经过编译之后右边的代码仍然是对数组 list 进行
map，逐条渲染出数组内容。

经过 preack 优化后，运行时代码已经非常轻量了。运行时就减少 map 的计算等，直接用生成的组件内容作为运行时结果。

### 总结

框架的性能实际上要分两方面来学习：一方面是使用层面，我们需要了解框架，进而保证达到性能优化；另一方面需要了解框架实现，思考作者在框架编译时和运行时两个重要环节是如何进行处理，持续进行优化的。

总而言之，框架的性能优化仍然属于语言范畴和浏览器范畴的优化，一些思想具有共通性，希望大家一起积累思考。



## 揭秘前端设计模式（上）

设计模式——我认为这是一个一言难尽的概念。维基百科对设计模式的定义为：

> 在软件工程中，设计模式（Design
Pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。这个术语是由埃里希·伽玛（Erich Gamma）等人在 1990
年代从建筑设计领域引入到计算机科学的。设计模式并不是直接用来完成代码的编写，而是描述在各种不同情况下，要怎么解决问题的一种方案。

为什么“一言难尽”呢？首先从设计模式的概念可以看出：这是一套理论，干巴巴的描述其所有内容并没有太大意义。我们不会在面试中提出：“请你解释一下设计模式”、“你会多少种设计模式”这种问题。设计模式一般认为有
23 种， **这 23 种设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性，以及类的关联关系和组合关系的总结应用。**

那么对于 JavaScript 或者前端开发来说，设计模式似乎是一个有些遥远的概念。我们应该如何了解并学习设计模式呢？

**我认为设计模式不能停留在理论上，而是应该结合到实际代码当中**
。因此打算通过两讲内容来介绍：本讲内容先介绍基本概念，分享一些经典的设计模式书籍以及相关经验，也许稍微有些“无趣”；第二讲内容将深入结合前端开发，挑选那些我们一直使用的、会用到的设计模式进行讲解。

相关知识点如下：

![enter image description
here](https://images.gitbook.cn/cb2e6d60-cbfe-11e9-a9bd-857608719494)

### 设计模式到底是什么

之前提到，设计模式是一种经验总结，它就是一套兵法，一共包含了 23 个套路。最终目的是为了更好的代码重用性、可读性、可靠性、可维护性。

在平常开发中，“也许你不知道，但是已经在使用设计模式了”。在之前课程内容的学习中，我们其实也有所提及，比如单例模式（细心的读者还能找到单例模式实现的课程出处吗？）、发布订阅模式、原型模式等。

如果到此，仍然不明白设计模式到底是指什么，别着急，请继续阅读以下内容。

### 设计模式原则

既然是一套理论，是一种约定和规范，那么设计模式也就有自己的模式原则。总体来说，其六大原则包括：

  * 开闭原则
  * 里氏替换原则
  * 依赖反转原则
  * 接口隔离原则
  * 最小知道原则
  * 合成复用原则

如图：

![enter image description
here](https://images.gitbook.cn/8112c980-cbfc-11e9-93b3-c35630e1847c)

我们来逐一了解：

  * 开闭原则（Open Close Principle）

理解开闭原则，就要了解开和闭。 **这里的开是指对扩展开放，闭是说对修改关闭**
。想想我们有一套实现、提供一个服务，这样的程序需要能够随时进行扩展、随时支持第三方的自定义配置，但是不能去修改已用的实现代码。

比如我们做了一个 UI 组件轮子，业务方在使用时显然不能够修改我们的代码，但是仍然可以进行扩展。再比如著名的 Draft.js
库，在实现一个编辑器时，提供了灵活的插件机制，实现了热插拔效果，使得整个程序的扩展性好，易于维护和升级。甚至 Redux 库、Koa
库等基本所有库都有开闭原则的体现。

对于面向对象类型的语言来说，想要严格遵守开闭原则，往往需要使用接口和抽象类，这个我们会在具体设计中再次提到。

  * 里氏替换原则（Liskov Substitution Principle）

里氏代换原则就稍微有些抽象，但它是面向对象设计的基本原则之一。

> 里氏代换原则要求，任何基类可以发挥作用的地方，子类一定可以发挥作用。

这句话怎么理解呢？想想我们的继承实现，里氏替换原则就是继承复用的基础。只有当派生类可以随时替换掉其基类，同时功能不被破坏，基类的方法仍然能被使用，这才是真正的继承，继承才能真正地实现复用，当然，派生类也需要随时能够在基类的基础上增加新的行为。

事实上，里氏代换原则是对开闭原则的补充。

  * 依赖反转原则（Dependence Inversion Principle）

该原则要求针对接口编程，依赖于抽象。更多理论内容我并不打算展开，后续在程序设计中会结合实例提及。

  * 接口隔离原则（Interface Segregation Principle）

接口隔离的意思或者目的是减少耦合的出现。在大型软件架构中，使用多个相互隔离的接口，一定比使用单个大而全的接口要好。

  * 最少知道原则，又称迪米特法则（Demeter Principle）

最少知道顾名思义，是指：一个系统的功能模块应该最大限度地不知晓其他模块的出现，减少感知，模块应相对独立。

  * 合成复用原则（Composite Reuse Principle）

合成复用原则是指：尽量使用合成 /
聚合的方式，而不是使用继承。这是很有意思的一点，我们在之前的课程中提到过：基于原型的继承在很多程度上“优于”基于类的继承，原因就在于基于原型的继承模式体现了可组合性，能够规避“大猩猩和香蕉”等问题的出现。组合是非常优秀的编程思想，这一点在函数式编程范畴中得到了最大程度的印证。

### 设计模式的三大类型和二十三种套路

设计模式并没有什么困难的，大体上所有的设计模式可以归结为三大类：

  * 创建型
  * 结构型
  * 行为型

如图：

![enter image description
here](https://images.gitbook.cn/1190fdb0-cbfd-11e9-942c-915593d3f51c)

对于 Java 来说，它还包括了 J2EE 类型设计模式。

我们分别来看：

  * 创建型（Creational Patterns）

创建型的五种设计模式提供了更加灵活的对象创建方式，同时可以隐藏创建的具体逻辑。与直接使用 new
运算符实例化对象相比，这些模式具有更强的灵活性以及可定制性。

  * 结构型（Structural Patterns）

结构型的七种设计模式关注类和对象的组合，结合继承的概念，这些设计模式能使得对象具有更加灵活的功能设定。

  * 行为型（Behavioral Patterns）

行为型的十一种设计模式聚焦于对象和类之间的通信，这是构建大型程序架构必不可少的环节。

### 关于设计模式的学习

设计模式使代码编写真正工程化，我们说设计模式是软件工程的基石脉络，如同大厦的结构一样。其实我认为没有必要刻意地去学习设计模式，因为有关设计模式的思想一定是在实际工程开发中慢慢体会总结的。但是这需要开发者做到“非常有心”，才能够自己去慢慢积累，为了能够培养这种“用心”，读者去专门了解设计模式似乎也是一种捷径和方式。两节课程的设置足以帮助大家培养设计模式思想，同时我再分享一些关于设计模式的经典资料：

  * [design-patterns-for-humans](https://github.com/kamranahmedse/design-patterns-for-humans)：这是一本非常著名的设计模式书 pdf
  * [design-patterns-for-humans-cn](https://github.com/guanguans/design-patterns-for-humans-cn)：上本书的中文版 pdf
  * [Learning JavaScript Design Patterns](https://addyosmani.com/resources/essentialjsdesignpatterns/book/)：addyosmani 大神的书 pdf
  * [图说设计模式](https://design-patterns.readthedocs.io/zh_CN/latest/)

其中强烈推荐《Learning JavaScript Design Patterns》，这本书在网上开源免费，其中的内容示例都是用 JavaScript
编写的，而且在代码实例编写当中剖析了很多 jQuery 等经典“轮子”的设计。

同时 GitHub 上也有一个不错的 repo：[JsPattern-
ES6](https://github.com/DavidCai1993/JsPattern-ES6)，使用 ES6 重写了《JavaScript
模式》一书中的样例。

还有一个“神器”是：[es6-design-patterns](http://loredanacirstea.github.io/es6-design-
patterns/#composite)，如截图：

![enter image description
here](https://images.gitbook.cn/765be890-cbfd-11e9-a9bd-857608719494)

这个网站通过 UML 图解释设计模式，同时配以可以运行的代码示例，非常方便对每一种设计模式进行学习。

### 总结

本讲介绍了设计模式的基础理论以及学习方式，其中有一些概念较为抽象，读者不必完全明白，相信通过下一讲的学习，我们结合前端实例，一定会有更深入的体会。



## 揭秘前端设计模式（下）

在上一讲中，我们介绍了设计模式的一些基本概念。本讲我们来结合实例，结合前端开发，继续讲解这个话题。

回顾一下设计模式的内容：

![](https://images.gitbook.cn/cb2e6d60-cbfe-11e9-a9bd-857608719494)

### 工厂模式在前端中的应用

创建型的工厂模式一共分为三种：

  * 简单工厂模式（Simple Factory）
  * 工厂方法模式（Factory Method）
  * 抽象工厂模式（Abstract Factory）

顾名思义，工厂模式就是隐藏了创建一个实例的复杂度，只需要提供一个简单的接口调用，直接完成创建实例的目的。而这三种工厂模式的区别我认为没有太大必要去细分，重点还是在于应用。比如一个非常常见的场景，就是
jQuery 的选择器：

    
    
    class jQuery {
        constructor(selector) {
            super(selector)
        }
        //  ....
    }
    
    window.$ = function(selector) {
        return new jQuery(selector)
    }
    

这样的代码非常明显，我们需要构建一个 jQuery 实例时，只需要：

    
    
    $('selector')
    

因为 `$` 已经被挂载在 window 上，而 `$` 作为一个函数，它直接返回了 new jQuery(selector)，开发者不需要再麻烦地使用
`new $('selector')` 方式。

除了 jQuery 以外，React 开发者常用的 React.createElement 也是工厂模式的体现：

    
    
    React.createElement('span', null, 'Factory Pattern!'),
    

只要具有组件化思想的类库或者框架，无一例外都会使用工厂模式去创建组件实例，除了提到的 React、jQuery（jQuery UI）
以外，Vue，甚至是更古老的 ExtJS 都不例外。

我们再来看一个例子，请读者体会：

    
    
    class Car {
      constructor(options) {
        const {doors = 4, state = 'new', color = 'black'} = options
        this.doors = doors
        this.state = state
        this.color = color
      }
    }
    
    class Truck {
      constructor(options) {
        const {wheelSize = 'medium', state = 'used', color = 'silver'} = options
        this.wheelSize = wheelSize
        this.state = state
        this.color = color
      }
    }
    
    
    class VehicleFactory {
      createVehicle(options) {
        switch (options.type) {
          case 'car':
            this.vehicleTarget = Car
            break;
          case 'truck':
            this.vehicleTarget = Truck
            break;
          default:
            this.vehicleTarget = Car
            break;
        }
    
        return new this.vehicleTarget(options)
      }
    }
    
    let factory = new VehicleFactory()
    
    let instance1 = factory.createVehicle({
      type: 'car',
      color: 'yellow',
      doors: 4
    })
    
    let instance2 = factory.createVehicle({
      type: 'truck',
      state: 'new',
      wheelSize: 'small'
    })
    

尝试：

    
    
    instance1 instanceof Car
    instance2 instanceof Truck
    

都会返回
true。理解了这个例子，其实你也就明白了建造者模式。“什么？我还不知道建造者模式是什么！”，没错，设计模式就是这样，重要的不是死记硬背每种模式的概念，而是在实际中应用，其实不经意之间，你一直在使用设计模式。

### 单例模式在前端中的应用

单例模式非常简单，通俗来说就是某个类只能有一个是实例。那么他的应用场景也就非常直观：引用第三方库，全局唯一的对象或者状态管理，全局唯一的插件等。在之前的课程中，我们通过闭包实现了单例模式，这里再次用
ES6 实现：

    
    
    class Singleton {
      constructor() {
        if (!Singleton.instance) {
          Singleton.instance = this;
        }
    
        return Singleton.instance;
      }
    }
    

### 建造者模式在前端中的应用

前面我们提到了建造者模式，这里再深入地进行了解。建造者的精髓在于“分步骤分情况构建一个复杂的对象”。比如我们想实现一个 pizza 类，用于生成 pizza
实例：

    
    
    class Pizza {
        constructor(size, chesse = true, tomato = false, lettuce = false) {
        }
    }
    

构建一个 pizza 需要在初始化时传入需要的参数，如果这个 pizza 类变得复杂，比如需要声明是否添加 mushroom、oliver、poulet
等，那么参数就会非常失控：

    
    
    class Pizza {
        constructor(size, mushroom = true, oliver= true, poulet = false, chesse = true, tomato = false, lettuce = false) {
        }
    }
    

使用建造者模式：

    
    
    class Pizza {
        constructor(size) {
            this.size = size
        }
    
        addMushroom() {
            this.mushroom = true
            return this
        }
    
        addOliver() {
            this.oliver = true
            return this
        }
    
        addPoulet() {
            this.poulet = true
            return this
        }
    
        addChesse() {
            this.chesse = true
            return this
        }
    
        addTomato() {
            this.tomato = true
            return this
        }
    
        addLettuce() {
            this.lettuce = true
            return this
        }
    
        build() {
            return new Pizza(this)
        }
    }
    

这样一来，使用就会更加优雅：

    
    
    new Pizza(32)
        .addOliver()
        .addTomato()
        .build()
    

当然，你可以认为参数以对象的形式传入，就能解决参数过多以及参数顺序问题。可是往往构造一个对象并不只是参数的问题。比如构建一个复杂的 DOM 结构，而针对于此
jQuery 利用建造者模式简化了构建 DOM 的过程：

我们可以通过多种方式构造 DOM ：

    
    
    $( "<div class= "foo">bar</div>" );
    
    
    
    $( "<p id="test">foo <em>bar</em></p>").appendTo("body" );
    
    
    
    var newParagraph = $( "<p />" ).text( "Hello world" );
    
    
    
    $( "<input />" )
          .attr({ "type": "text", "id":"sample"});
          .appendTo("#container");
    

对应 jQuery.prototype 源码：

    
    
      // HANDLE: $(html) -> $(array)
        if ( match[1] ) {
          context = context instanceof jQuery ? context[0] : context;
          doc = ( context ? context.ownerDocument || context : document );
    
          //如果传入的是单个字符串，并且是单个标记
          //只需执行 createElement 并跳过其余部分
    
          ret = rsingleTag.exec( selector );
    
          if ( ret ) {
            if ( jQuery.isPlainObject( context ) ) {
              selector = [ document.createElement( ret[1] ) ];
              jQuery.fn.attr.call( selector, context, true );
    
            } else {
              selector = [ doc.createElement( ret[1] ) ];
            }
    
          } else {
            ret = jQuery.buildFragment( [ match[1] ], [ doc ] );
            selector = ( ret.cacheable ? jQuery.clone(ret.fragment) 
            : ret.fragment ).childNodes;
          }
    
          return jQuery.merge( this, selector );
    

### 外观模式在前端中的应用

外观模式的精髓在于对接口进行二次封装，隐藏其内部的复杂度。这种设计在前端开发中也非常常见，比如跨浏览器兼容性的封装，比如事件：

    
    
    var addMyEvent = function( el,ev,fn ){
      if( el.addEventListener ){//存在 DOM2 级方法，则使用并传入事件类型、事件处理程序函数和第3个参数 false（表示冒泡阶段）
            el.addEventListener( ev,fn, false );
      }else if(el.attachEvent){ // 为兼容 IE8 及更早浏览器，注意事件类型必须加上"on"前缀
            el.attachEvent( "on" + ev, fn );
      }else{
           el["on" + ev] = fn;//其他方法都无效，默认采用 DOM0 级方法，使用方括号语法将属性名指定为事件处理程序
        }
    };
    

再比如 `$(document).ready` 的用法：

    
    
    bindReady: function() {
        ...
        if ( document.addEventListener ) {
          // Use the handy event callback
          document.addEventListener( "DOMContentLoaded", DOMContentLoaded, false );
    
          // A fallback to window.onload, that will always work
          window.addEventListener( "load", jQuery.ready, false );
    
        // If IE event model is used
        } else if ( document.attachEvent ) {
    
          document.attachEvent( "onreadystatechange", DOMContentLoaded );
    
          // A fallback to window.onload, that will always work
          window.attachEvent( "onload", jQuery.ready );
    

再看一个例子，外观模式和模块化的结合：

    
    
    var module = (function() {
        var _private = {
            i: 5,
            get: function() {
                console.log( "current value:" + this.i);
            },
            set: function( val ) {
                this.i = val;
            },
            run: function() {
                console.log( "running" );
            },
            jump: function(){
                console.log( "jumping" );
            }
        };
    
        return {
            facade: function( args ) {
                _private.set(args.val);
                _private.get();
                if ( args.run ) {
                    _private.run();
                }
            }
        };
    }());
    
    
    // Outputs: "current value: 10" and "running"
    module.facade( {run: true, val: 10} );
    

在这个例子中，开发者只需要调用 module.facade( {run: true, val: 10}
)，调用后会触发模块当中私有方法，实现对数值的改写，我们并不需要明白 module 内部实现，只需要关心其封装即可。

### 适配器模式在前端中的应用

适配器模式在于适配两个及以上类接口不兼容的问题，和外观模式的核心思路类似。在 jQuery 中也广泛应用，我们知道 opacity
属性在不同浏览器中的表现方式不同。

在 Chrome 4+、FF2+、Saf3.1+、Opera 9+、IE9、iOS 3.2+、Android 2.1+ 中：

    
    
    opacity: 0.9
    

是常见用法，但是在 IE6-8，却是：

    
    
    filter: alpha(opacity=90)
    

jQuery 利用适配器模式，对这种差异进行了抹平：

    
    
    // 读
    $( ".container" ).css( { opacity: .5 } );
    
    // 取
    let opacity = $( ".container" ).css( { opacity: .5 } );
    

其内部实现为：

    
    
    get: function( elem, computed ) {
      // IE uses filters for opacity
      return ropacity.test( (
            computed && elem.currentStyle ?
                elem.currentStyle.filter : elem.style.filter) || "" ) ?
        ( parseFloat( RegExp.$1 ) / 100 ) + "" :
        computed ? "1" : "";
    },
    
    set: function( elem, value ) {
      var style = elem.style,
        currentStyle = elem.currentStyle,
        opacity = jQuery.isNumeric( value ) ?
              "alpha(opacity=" + value * 100 + ")" : "",
        filter = currentStyle && currentStyle.filter || style.filter || "";
    
      // IE has trouble with opacity if it does not have layout
      // Force it by setting the zoom level
      style.zoom = 1;
    
      // if setting opacity to 1, and no other filters
      //exist - attempt to remove filter attribute #6652
      if ( value >= 1 && jQuery.trim( filter.replace( ralpha, "" ) ) === "" ) {
    
        // Setting style.filter to null, "" & " " still leave
        // "filter:" in the cssText if "filter:" is present at all,
        // clearType is disabled, we want to avoid this style.removeAttribute
        // is IE Only, but so apparently is this code path...
        style.removeAttribute( "filter" );
    
        // if there there is no filter style applied in a css rule, we are done
        if ( currentStyle && !currentStyle.filter ) {
          return;
        }
      }
    
      // otherwise, set new filter values
      style.filter = ralpha.test( filter ) ?
        filter.replace( ralpha, opacity ) :
        filter + " " + opacity;
    }
    };
    

### 享元模式在前端中的应用

我个人认为享元模式非常重要，他是用于性能优化的一种常见模式。它依靠：

  * 主减少创建对象实例的数量
  * 运用共享技术来有效支持大量细粒度的对象

这两种方式减少内存占用，以提高性能。在 JavaScript
中，浏览器特别是移动端的浏览器所占有的内存并不算多，因此合理利用享元模式，达到节省内存的目的，就成了一件非常有意义的优化。

在 Java 中有一个关键字：implements，它用于接入接口 interfaces，这在 JavaScript
语言中并不存在，但是我们仍然可以模拟一个：

    
    
    Function.prototype.implementsFor = function( parentClassOrObject ){
        if ( parentClassOrObject.constructor === Function )
        {
            // Normal Inheritance
            this.prototype = new parentClassOrObject();
            this.prototype.constructor = this;
            this.prototype.parent = parentClassOrObject.prototype;
        }
        else
        {
            // Pure Virtual Inheritance
            this.prototype = parentClassOrObject;
            this.prototype.constructor = this;
            this.prototype.parent = parentClassOrObject;
        }
        return this;
    };
    

我们看：implementsFor 作用于一个构造函数，它接受一个父类（function）或者一个
object，并继承该父类构造函数（function）或者指定的 object。上段代码并不难理解，我们看一个应用实例：

    
    
    // Flyweight object
    var CoffeeOrder = {
    
      // Interfaces
      serveCoffee:function(context){},
        getFlavor:function(){}
    
    };
    
    
    // ConcreteFlyweight object that creates ConcreteFlyweight
    // Implements CoffeeOrder
    function CoffeeFlavor( newFlavor ){
    
        var flavor = newFlavor;
    
        // If an interface has been defined for a feature
        // implement the feature
        if( typeof this.getFlavor === "function" ){
          this.getFlavor = function() {
              return flavor;
          };
        }
    
        if( typeof this.serveCoffee === "function" ){
          this.serveCoffee = function( context ) {
            console.log("Serving Coffee flavor "
              + flavor
              + " to table number "
              + context.getTable());
          };
        }
    
    }
    
    
    // Implement interface for CoffeeOrder
    CoffeeFlavor.implementsFor( CoffeeOrder );
    
    
    // Handle table numbers for a coffee order
    function CoffeeOrderContext( tableNumber ) {
       return{
          getTable: function() {
             return tableNumber;
         }
       };
    }
    
    function CoffeeFlavorFactory() {
        var flavors = {},
        length = 0;
    
        return {
            getCoffeeFlavor: function (flavorName) {
    
                var flavor = flavors[flavorName];
                if (typeof flavor === "undefined") {
                    flavor = new CoffeeFlavor(flavorName);
                    flavors[flavorName] = flavor;
                    length++;
                }
                return flavor;
            },
    
            getTotalCoffeeFlavorsMade: function () {
                return length;
            }
        };
    }
    
    // Sample usage:
    // testFlyweight()
    
    function testFlyweight(){
    
    
      // The flavors ordered.
      var flavors = [],
    
      // The tables for the orders.
        tables = [],
    
      // Number of orders made
        ordersMade = 0,
    
      // The CoffeeFlavorFactory instance
        flavorFactory = new CoffeeFlavorFactory();
    
      function takeOrders( flavorIn, table) {
         flavors.push( flavorFactory.getCoffeeFlavor( flavorIn ) );
         tables.push( new CoffeeOrderContext( table ) );
         ordersMade++;
      }
    
       takeOrders("Cappuccino", 2);
       takeOrders("Cappuccino", 2);
       takeOrders("Frappe", 1);
       takeOrders("Frappe", 1);
       takeOrders("Xpresso", 1);
       takeOrders("Frappe", 897);
       takeOrders("Cappuccino", 97);
       takeOrders("Cappuccino", 97);
       takeOrders("Frappe", 3);
       takeOrders("Xpresso", 3);
       takeOrders("Cappuccino", 3);
       takeOrders("Xpresso", 96);
       takeOrders("Frappe", 552);
       takeOrders("Cappuccino", 121);
       takeOrders("Xpresso", 121);
    
       for (var i = 0; i < ordersMade; ++i) {
           flavors[i].serveCoffee(tables[i]);
       }
       console.log(" ");
       console.log("total CoffeeFlavor objects made: " + flavorFactory.getTotalCoffeeFlavorsMade());
    }
    

这个例子中，CoffeeFlavor 接入了 CoffeeOrder 的接口。接口的概念也许对于传统的 JavaScript
开发者有些陌生，我们再来看一个更加具有表现力的例子：在图书管理系统中，每本书都有以下特性：

  * ID
  * Title
  * Author
  * Genre
  * Page count
  * Publisher ID
  * ISBN

同时我们需要以下属性来追踪每一本书时，记录它是否可用、归还时间等：

  * checkoutDate
  * checkoutMember
  * dueReturnDate
  * availability

那么 Book 这个类看上去就像：

    
    
    var Book = function( id, title, author, genre, pageCount,publisherID, ISBN, checkoutDate, checkoutMember, dueReturnDate,availability ){
    
       this.id = id;
       this.title = title;
       this.author = author;
       this.genre = genre;
       this.pageCount = pageCount;
       this.publisherID = publisherID;
       this.ISBN = ISBN;
       this.checkoutDate = checkoutDate;
       this.checkoutMember = checkoutMember;
       this.dueReturnDate = dueReturnDate;
       this.availability = availability;
    
    };
    
    Book.prototype = {
    
      getTitle: function () {
         return this.title;
      },
    
      getAuthor: function () {
         return this.author;
      },
    
      getISBN: function (){
         return this.ISBN;
      },
    
      // For brevity, other getters are not shown
      updateCheckoutStatus: function( bookID, newStatus, checkoutDate, checkoutMember, newReturnDate ){
    
         this.id = bookID;
         this.availability = newStatus;
         this.checkoutDate = checkoutDate;
         this.checkoutMember = checkoutMember;
         this.dueReturnDate = newReturnDate;
    
      },
    
      extendCheckoutPeriod: function( bookID, newReturnDate ){
    
          this.id = bookID;
          this.dueReturnDate = newReturnDate;
    
      },
    
      isPastDue: function(bookID){
    
         var currentDate = new Date();
         return currentDate.getTime() > Date.parse( this.dueReturnDate );
    
       }
    };
    

这么看上去并没有什么问题，但是当图书增多时，对于系统的压力会逐渐增多。为此我们将书的属性分为两种：本身固有的和外在特性。本身固有的属性包括
title、author 等，外在特性包括 checkoutMember、dueReturnDate 等。这样一来，我们简化书的构造函数为：

    
    
    var Book = function ( title, author, genre, pageCount, publisherID, ISBN ) {
    
        this.title = title;
        this.author = author;
        this.genre = genre;
        this.pageCount = pageCount;
        this.publisherID = publisherID;
        this.ISBN = ISBN;
    
    };
    

我们将外在特性删去，check-outs 等信息将会被移动到一个新的类中，一个新的工厂函数也将出现：

    
    
    // Book Factory singleton
    var BookFactory = (function () {
      var existingBooks = {}, existingBook;
    
      return {
        createBook: function ( title, author, genre, pageCount, publisherID, ISBN ) {
    
          // Find out if a particular book meta-data combination has been created before
          // !! or (bang bang) forces a boolean to be returned
          existingBook = existingBooks[ISBN];
          if ( !!existingBook ) {
            return existingBook;
          } else {
    
            // if not, let's create a new instance of the book and store it
            var book = new Book( title, author, genre, pageCount, publisherID, ISBN );
            existingBooks[ISBN] = book;
            return book;
    
          }
        }
      };
    
    })();
    

在这个工厂函数中，我们将会检查当前需要创建的书籍是否已经存在，如果存在直接返回书实例；否则进行调用 Book
构造函数进行创建。这保证了所有的书都是唯一的，而不存在重复。

对于书的外在特性，我们创建 BookRecordManager 来维护每一本书的状态，并通过 bookId 与每一个本书进行关系创建：

    
    
    var BookRecordManager = (function () {
    
      var bookRecordDatabase = {};
    
      return {
        // add a new book into the library system
        addBookRecord: function ( id, title, author, genre, pageCount, publisherID, ISBN, checkoutDate, checkoutMember, dueReturnDate, availability ) {
    
          var book = BookFactory.createBook( title, author, genre, pageCount, publisherID, ISBN );
    
          bookRecordDatabase[id] = {
            checkoutMember: checkoutMember,
            checkoutDate: checkoutDate,
            dueReturnDate: dueReturnDate,
            availability: availability,
            book: book
          };
        },
        updateCheckoutStatus: function ( bookID, newStatus, checkoutDate, checkoutMember, newReturnDate ) {
    
          var record = bookRecordDatabase[bookID];
          record.availability = newStatus;
          record.checkoutDate = checkoutDate;
          record.checkoutMember = checkoutMember;
          record.dueReturnDate = newReturnDate;
        },
    
        extendCheckoutPeriod: function ( bookID, newReturnDate ) {
          bookRecordDatabase[bookID].dueReturnDate = newReturnDate;
        },
    
        isPastDue: function ( bookID ) {
          var currentDate = new Date();
          return currentDate.getTime() > Date.parse( bookRecordDatabase[bookID].dueReturnDate );
        }
      };
    
    })();
    

其实变动也比较明显，书目所有的外在特性都被从书本身的特性中抽离，现在被移动到 BookManager 的 BookDatabase
当中。对于书借入/借出的操作也移动到了 BookRecordManager 当中，因为这些方法需要直接操作书的外在特性。如此一来，比一本书拥有多项属性的大
object 模式更加高效，也更利于维护。

关于性能可以具体来看：如果有 30 本同样一本书的 copy，现有的模式下只存储了一个实例；同时对于书状态转移的函数，我们维护在 BookManager
当中，而不再出现在对象（原型）上，如果这些函数出现在每一个书实例当中，将会是更大的开销。

享元模式在前端还有更多的应用，比如事件代理就是一个很典型的体现：

    
    
    <div id="container">
       <div class="toggle" href="#">More Info (Address)
           <span class="info">
               This is more information
           </span></div>
       <div class="toggle" href="#">Even More Info (Map)
           <span class="info">
              <iframe src="http://www.map-generator.net/extmap.php?name=London&amp;address=london%2C%20england&amp;width=500...gt;"</iframe>
           </span>
       </div>
    </div>
    

我们集中将事件处理放到父容器上：

    
    
    var stateManager = {
    
      fly: function () {
    
        var self = this;
    
        $( "#container" )
              .unbind()
              .on( "click", "div.toggle", function ( e ) {
                self.handleClick( e.target );
              });
      },
    
      handleClick: function ( elem ) {
        $( elem ).find( "span" ).toggle( "slow" );
      }
    };
    

如此类似，前面课程提到过的 React 合成事件的池化机制，都体现了异曲同工之妙。

### 代理模式在前端中的应用

代理模式大家应该都不陌生，ES next 提供的 Proxy 让我们实现代理模式变得更加容易。关于 Proxy
的使用这些基础内容这里不过多赘述，直接来看一些代理模式的应用场景。

我们对函数进行代理，对函数的返回结果进行缓存。在函数执行时，优先使用缓存值，否则返回执行计算值：

    
    
    const getCacheProxy = (fn, cache = new Map()) => 
      new Proxy(fn, {
        apply(target, context, args) {
          const argsString = args.join(' ')
          if (cache.has(argsString)) {
            return cache.get(argsString)
          }
          const result = fn(...args)
          cache.set(argsString, result)
    
          return result
        }
      })
    

另外一个类似的实现：

    
    
    const createThrottleProxy = (fn, timer) => {
      let last = Date.now() - timer
      return new Proxy(fn, {
        apply(target, context, args) {
          if (Date.now() - last >= rate) {
            fn(args)
            last = Date.now()
          }
        }
      })
    };
    

这些内容在前面的课程都有渗透，相信读者已经不难理解了。我们再来看 jQuery 当中的例子：

    
    
    $( "button" ).on( "click", function () {
      // Within this function, "this" refers to the element that was clicked
      $( this ).addClass( "active" );
    });
    

通过 `$( this )` 可以获取到当前触发事件的元素，但是：

    
    
    $( "button" ).on( "click", function () {
      setTimeout(function () {
        // "this" doesn't refer to our element!
        $( this ).addClass( "active" );
      });
    });
    

但是这里的 `$( this )` 不再是预期之中的结果。为此，jQuery 提供了 .proxy() 方法，这是典型的代理模式体现。

    
    
    $( "button" ).on( "click", function () {
    
        setTimeout( $.proxy( function () {
            // "this" now refers to our element as we wanted
            $( this ).addClass( "active" );
        }, this), 500);
    
        // the last "this" we're passing tells $.proxy() that our DOM element
        // is the value we want "this" to refer to.
    });
    

来看一下 proxy 的实现：

    
    
    // Bind a function to a context, optionally partially applying any
    // arguments.
    proxy: function( fn, context ) {
      if ( typeof context === "string" ) {
        var tmp = fn[ context ];
        context = fn;
        fn = tmp;
      }
    
      // Quick check to determine if target is callable, in the spec
      // this throws a TypeError, but we will just return undefined.
      if ( !jQuery.isFunction( fn ) ) {
        return undefined;
      }
    
      // Simulated bind
      var args = slice.call( arguments, 2 ),
        proxy = function() {
          return fn.apply( context, args.concat( slice.call( arguments ) ) );
        };
    
      // Set the guid of unique handler to the same of original handler, so it can be removed
      proxy.guid = fn.guid = fn.guid || proxy.guid || jQuery.guid++;
    
      return proxy;
    }
    

### 装饰者模式在前端中的应用

装饰者模式如同代理模式一样，如今 JavaScript
也已经原生能够很好地进行支持了。简单来说就是在不改变原对象的基础上，对其对象进行包装和拓展，使原对象能够应对更加复杂的需求。这就有一点像高阶函数，因此在前端开发中非常多见：

    
    
    import React, { Component } from 'react'
    import {connect} from 'react-redux'
    class App extends Component {
     render() {
      //...
     }
    }
    export default connect(mapStateToProps,actionCreators)(App);
    

或者在 Ant design 中：

    
    
    class CustomizedForm extends React.Component {}
    
    CustomizedForm = Form.create({})(CustomizedForm)
    

当然 TypeScript 函数修饰符 @ 也是类似的。

借助装饰者模式，很容易衍生出 AOP 面向切面编程的概念：

    
    
    Function.prototype.before = function(fn) {
      const self = this
      return function() {
        fn.apply(new(self), arguments)
        return self.apply(new(self), arguments)
      }
    }
    
    Function.prototype.after = function(fn) {
      const self = this
      return function() {
        self.apply(new(self), arguments)
        return fn.apply(new(self), arguments)
      }
    }
    

其实面向切面编程和装饰者模式思想是完全一致的。典型场景就是对表单的验证，我们将把表单输入逻辑校验的 validata 函数融入到 before 逻辑当中：

    
    
    Function.prototype.before = function( beforefn ) {
      const self = this
      return function(){
        if ( beforefn.apply( this, arguments ) === false ) return 
        return self.apply( this, arguments )
      }
    }
    
    
    const validate = function(){
      // 表单验证逻辑
    }
    
    const formSubmit = function() {
      // 表达提交逻辑
      ajax( 'http:// xxx.com/login', param )
    }
    
    submitBtn.onclick = function() {
      formSubmit.before( validate )
    }
    

### 职责链模式在前端中的应用

顾名思义，职责链模式就是建立一个流程链条，一个请求从一端进入，并从一个职责根据需求，流转进入另一个对象，直到找到合适的处理程序。

听上去似乎有点“中间件”的意思，我们来看一个简单的应用：账户付款时绑定一个基本帐户类，它连接了多种付款方式：paypal
支付、比特币支付，并根据不同付款方式的金额额度和付款额，选择第一个合适的账户进行支付逻辑：

    
    
    class Account {
        next(account) {
            this.successor = account
        }
    
        pay(amount) {
            if (this.canPay(amount)) {
                console.log(`Paid ${amount} using ${this.name}`)
            } else if (this.successor) {
                console.log(`Cannot pay using ${this.name}. Proceeding...`)
                this.successor.pay(amount)
            } else {
                console.log('None of the accounts have enough balance')
            }
        }
    
        canPay(amount) {
            return this.balance >= amount
        }
    }
    
    class Bank extends Account {
        constructor(balance) {
            super()
            this.name = 'bank'
            this.balance = balance
        }
    }
    
    class Paypal extends Account {
        constructor(balance) {
            super()        
            this.name = 'Paypal'
            this.balance = balance
        }
    }
    
    class Bitcoin extends Account {
        constructor(balance) {
            super()        
            this.name = 'bitcoin'
            this.balance = balance
        }
    }
    

在使用时，我们先给三个账户充钱：

    
    
    const bank = new Bank(100)          // Bank with balance 100
    const paypal = new Paypal(200)      // Paypal with balance 200
    const bitcoin = new Bitcoin(300)    // Bitcoin with balance 300
    

并按顺序优先调用银行付款、PayPal 付款、比特币付款：

    
    
    bank.next(paypal)
    paypal.next(bitcoin)
    

最终付款行为：

    
    
    bank.pay(250)
    

输出：

    
    
    Cannot pay using bank. Proceeding...
    Cannot pay using Paypal. Proceeding...
    Paid 250 using bitcoin
    

### 策略模式在前端中的应用

策略模式能够让开发者基于具体场景，来切换不同的算法或者策略。本身这个模式比较简单，但是有一个比较有意思的应用：V8
引擎在实现排序时，根据排序长度的不同，动态合理选用排序策略，达到尽可能的性能优化，例如代码：

    
    
    const bubbleSort = target => {
        console.log('Sorting with bubble sort')
        // ...
        // ...
        return target
    }
    
    const quickSort = target => {
        console.log('Sorting with quick sort')
        // ...
        // ...
        return target
    }
    
    const sorter = target => {
        if(target.length > 5){
            return quickSort(target)
        } else {
            return bubbleSort(target)
        }
    }
    

在目标数组长度大于 5 时使用快排，否则使用冒泡排序。感兴趣的读者可以自行了解 V8 的实现，看看这个分界策落的阈值（这里的例子中使用了
5）是多少，以及思考为什么选取该阈值。

上述代码的使用：

    
    
    const long = [1, 5, 4, 3, 2, 8]
    const short = [1, 5, 4]
    
    const result1 = sorter(long)
    const result2 = sorter(short)
    

输出：

    
    
    Sorting with quick sort
    Sorting with bubble sort
    

由此看出：第一个部分是策略类，策略类封装了具体的算法，并负责具体的计算过程；第二个部分是环境类，这个环境类接受客户的请求，随后把请求委托给某一个策略类。另一个应用策略模式的例子是表单校验：

    
    
    class Validator {
      constructor() {
        this.cache = []
      }
    
      add(dom, rule, errorMsg) {
        let array = rule.split(':')
    
        this.cache.push(function(){
          var strategy = array.shift()
          array.unshift(dom.value)
          array.push(errorMsg)
    
          return strategies[strategy].apply(dom, array)
        })
      }
    
      start() {
        for (let i = 0, validatorFunc; validatorFunc = this.cache[i++]; i < this.cache.length) {
          const msg = validatorFunc()
          if (msg) return msg
        }
      }
    }
    
    const strategies = {
        isNonEmpty: function(value, errorMsg) {
            if (value='') {
                return errorMsg
            }
        },
        minLength: function(value,length, errorMsg) {
            if (value.length<length) {
                return errorMsg
            }
        },
        isMobile: function(value, errorMsg) {
            if (!/^1[3|5|8][0-9]$/.test(value)) {
                return errorMsg
            }
        }
    }
    
    const validataFunc = function(){
        let validator = new Validator()
        validator.add(registerForm.userName, 'isNonEmpty', '用户名不能为空’)
        validator.add(registerForm.password, 'inLength:6' ,'密码长度不能少于6位')
        validator.add(registerForm.phoneNumber, 'isMobile', '手机号码格式不正确’)
    
        const  errorMsg = validator.start()
        return errorMsgs
    }
    
    const registerForm = document.getElementById("registerForm")
    registerForm.onsubmit = function() {
        varerrorMsg = validataFunc()
        if (errorMsg) {
            alert(errorMsg)
            return false 
        }
    }
    

其中，validataFunc 是我们的环境类，而 Validator 和 strategies 构成我们的策略。

### 总结

这节课程讲解了：工厂模式、单例模式、建造者模式、外观模式、适配器模式、享元模式、代理模式、装饰者模式、职责链模式、策略模式等在前端中的实现和应用。同时，包括原型模式、观察者模式、迭代器模式在内，这些模式都非常贴近
JavaScript 原有语法，因此不再过多赘述。

实际上，设计模式很简单，我们应该做到的是需要应用时“胸中有数”，能够想到设计模式实现，而不需要一味死记硬背。



## 剖析无处不在的数据结构

数据结构是计算机中组织和存储数据的特定方式，它的目的是方便且高效地对数据进行访问和修改。数据结构表述了数据之间的关系，以及操作数据的一系列方法。数据又是程序的基本单元，因此无论是哪种语言、哪种领域，都离不开数据结构；另一方面，数据结构是算法的基础，其本身也包含了算法的部分内容。也就是说，想要掌握算法，先有一个巩固的数据结构基础是必要条件。

前端领域也到处体现着数据结构的应用，尤其是随着需求的复杂度上升，前端工程师越来越离不开数据结构。React、Vue
这些设计精巧的框架，在线文档编辑系统、大型管理系统，甚至一个简单的检索需求，都离不开数据结构的支持。是否能够掌握这个难点内容，将是进阶的重要考量。我们应该如何学习数据结构呢？

下图是本讲内容的提纲。

![](https://images.gitbook.cn/87934440-d04f-11e9-bec2-e1649ddaac83)

### 数据结构和学习方法概览

我通常将数据结构分为八大类：

  * 数组：Array
  * 堆栈：Stack
  * 队列：Queue
  * 链表：Linked Lists
  * 树：Trees
  * 图：Graphs
  * 字典树：Trie
  * 散列表（哈希表）：Hash Tables

这么多的类型，这节课该如何介绍呢？我认为，按部就班地只是实现各种数据结构的意义不大，这些内容读者都可以从算法书籍中找到。更重要地是应用，也只有在应用中，才能真正地记住并掌握特定的数据结构，才能在下次有类似场景时，能够想起来相关的数据结构实现。因此，这节课程我将从前端出发，从前端类库或者典型场景入手，结合数据结构来剖析其实现和应用。这需要读者首先对每种数据结构有一个大概认知，我们可以先来细化感知一下：

  * 栈和队列是类似数组的结构，非常多的初级题目要求用数组实现栈和队列，他们在插入和删除的方式上和数组有所差异，但是实现还是非常简单的；
  * 链表、树和图这种数据结构的特点是，其节点需要引用到其他节点，因此在增删时，需要注意对相关前驱和后继节点的影响；
  * 可以从堆栈和队列出发，构建出链表；
  * 树和图最为复杂，因为他们本质上是扩展了链表的概念；
  * 散列表的关键是理解散列函数，明白依赖散列函数实现保存和定位数据的过程；
  * 直观上认为，链表适合记录和存储数据；哈希表和字典树在检索数据以及搜索方面有更大的应用场景。

以上这些“直观感性”的认知并不是“恒等式”， **我们将在下面的学习中去印证这些“认知”，你将会看到熟悉的 React、Vue
框架的部分实现，将会看到典型的算法场景，也请读者做好基础知识的储备。**

### 堆栈和队列

栈和队列是一种操作受限的线性结构，它们非常简单，虽然 JavaScript 并没有原生内置这样的数据结构，但是我们可以轻松地模拟出来。

栈的实现，后进先出 LIFO（Last in、First out）：

    
    
    class Stack {
      constructor(...args) {
        this.stack = [...args]
      }
    
      // Modifiers
      push(...items) {
        return this.stack.push(... items)
      }
    
      pop() {
        return this.stack.pop()
      }
    
      // Element access
      peek() {
        return this.isEmpty() 
            ? undefined
            : this.stack[this.size() - 1]
      }
    
      // Capacity
      isEmpty() {
        return this.size() == 0
      }
    
      size() {
        return this.stack.length
      }
    }
    

队列的实现，先进先出 FIFO（First in、First out）：

    
    
    class Queue {
      constructor(...args) {
        this.queue = [...args]
      }
    
      // Modifiers
      enqueue(...items) {
        return this.queue.push(... items)
      }
    
      dequeue() {
        return this.queue.shift()
      }
    
      // Element access
      front() { 
        return this.isEmpty()
            ? undefined
            : this.queue[0]
      }
    
      back() {
        return this.isEmpty()
            ? undefined
            : this.queue[this.size() - 1]
      }
    
      // Capacity
      isEmpty() {
        return this.size() == 0
      }
    
      size() {
        return this.queue.length
      }
    }
    

关于栈和队列的实际应用比比皆是：

  * 浏览器的历史记录，因为回退总是回退“上一个”最近的页面，它需要遵循栈的原则；
  * 类似浏览器的历史记录，任何 undo/redo 都是一个栈的实现；
  * 在代码中，广泛应用的递归产生的调用栈，同样也是栈思想的体现，想想我们常说的“栈溢出”就是这个道理；
  * 同上，浏览器在抛出异常时，常规都会抛出调用栈信息；
  * 在计算机科学领域应用广泛，如进制转换、括号匹配、栈混洗、表达式求值等；
  * 队列的应用更为直观，我们常说的宏任务 / 微任务都是队列，不管是什么类型的任务，都是先进先执行；
  * 后端也应用广泛，如消息队列、RabbitMQ、ActiveMQ 等，能起到延迟缓冲的功效。

我们看到不管是栈还是队列，都是用数组来模拟的。数组是最基本的数据结构，但是它的价值是惊人的，这里稍微提一下 React hooks
的本质就是数组。给大家推荐文章：[React hooks: not magic, just
arrays](https://medium.com/@ryardley/react-hooks-not-magic-just-arrays-
cd4f1857236e)

另外，与性能后话相关，HTTP 1.1 有一个队头阻塞问题，这个原因就在于队列这样的数据结构：我们先看 HTTP 1.0，对于同一个 tcp 连接，HTTP
1.0 是将所有请求都放入队列当中，这么一来，在客户端，“先进先出”，只有前一个请求得到了响应，下一个请求才会发出。在 HTTP 1.1
中，这样的情况得到了改观，每一个链接都默认是长链接，因此对于同一个 tcp
链接，不必等到前一个响应回来。但是这只是解决了客户端的队头阻塞问题，事实上，HTTP 1.1
规定：服务端的响应返回顺序需要遵循其接收到相应的顺序，这样的问题是：如果第一个请求处理需要较长时间，响应较慢，也都会“拖累”其他后续请求的响应，这仍然是一种队头阻塞。

HTTP 2 采用了二进制分帧和多路复用等方法， 同域名下的通信都是在同一个连接上完成，并且这种链接是双向的，在这个链接上可以并行请求和响应而互不干扰。

这里延伸的有点多了，主要是读者需要明白队列和栈这种数据结构的应用，以及利弊。

### 链表（单向链表和双向链表）

堆栈和队列都可以用数组实现，链表同样和数组一样，都实现了 **按照一定的顺序**
存储元素，不同的地方在于链表不能像数组一样通过下标访问，而是每一个元素指向下一个元素。我们不再过多介绍链表方面的基础知识，对于链表仍不理解的读者可以先自行学习。

直观上我们就可以得出结论：链表不需要一段连续的存储空间，“指向下一个元素”的方式能够更大限度地利用内存。

根据上面结论可以继续总结，链表的优点在于：

  * 链表的插入和删除操作的时间复杂度是常数级的，我们只需要改变相关节点的指针指向即可；
  * 链表可以像数组一样顺序访问，查找元素的时间复杂度是线性的。

我们来看看链表的应用场景：

  * React 的核心算法 Fiber 的实现就是链表

关于此我们可以稍作展开。React 最早开始使用大名鼎鼎的 Stack reconciler 调度算法，关于此在之前的课程中已经有所涉及。Stack
reconciler 调度算法最大的问题在于： **它是像函数调用栈一样，递归地、自顶向下进行 diff 和 render 相关操作的** ，在 Stack
reconciler
执行的过程当中，该调度算法始终会占据浏览器主线程。也就是说在此期间，用户的交互所触发的布局行为、动画执行任务都不会被立即响应，从而影响用户体验。

因此 React Fiber 将渲染和更新过程进行了拆解，简单来说，就是每次检查虚拟 DOM 的一小部分，在检查间隙会检查“是否还有时间继续执行下一个虚拟
DOM 树上某个分支任务”，同时观察是否有更优先的任务需要响应，如果“没有时间执行下一个虚拟 DOM 树上某个分支任务”，且有更高优先级，React
就会让出主线程，直到主线程“不忙”的时候继续执行任务。

React Fiber 因此也很简单，它是将 Stack reconciler
过程分成块，一次执行一块，执行完一块需要将结果保存起来，根据是否还有空闲的响应时间（requestIdleCallback）来决定下一步策略。当所有的块都已经执行完，就进入提交阶段，这个阶段需要更新
DOM，它是一口气完成的。

以上是比较主观地介绍，我们来看更具体的实现。

为了达到“随意中断调用栈并手动操作调用栈”，React Fiber 就是专门用于 React 组件堆栈调用的重新实现，也就是说一个 Fiber
就是一个虚拟堆栈帧，一个 Fiber 的结构类似：

    
    
    function FiberNode(
      tag: WorkTag,
      pendingProps: mixed,
      key: null | string,
      mode: TypeOfMode,
    ) {
      // Instance
      // ...
      this.tag = tag;                       
    
      // Fiber
      this.return = null;
      this.child = null;
      this.sibling = null;
      this.index = 0;
    
      this.ref = null;
    
      this.pendingProps = pendingProps;
      this.memoizedProps = null;
      this.updateQueue = null;
      this.memoizedState = null;
      this.dependencies = null;
    
      // Effects
      // ...
      this.alternate = null; 
    }
    

这么看 Fiber 就是一个对象，通过 parent、children、sibling 维护一个树形关系，同时
parent、children、sibling 也都是一个 Fiber 结构，FiberNode.alternate
这个属性来存储上一次渲染过的结果，事实上整个 Fiber 模式就是一个链表。React
也借此，从依赖于内置堆栈的同步递归模型，变为具有链表和指针的异步模型了。

具体的渲染过程：

    
    
    function renderNode(node) {
       // 判断是否需要渲染该节点，如果 props 发生变化，则调用 render
       if (node.memoizedProps !== node.pendingProps) {
          render(node)
       }
    
       // 是否有子节点，进行子节点渲染
       if (node.child !== null) {
          return node.child
       // 是否有兄弟节点，进行兄弟点渲染
       } else if (node.sibling !== null){
          return node.sibling
       // 没有子节点和兄弟节点
       } else if (node.return !== null){
          return node.return
       } else {
          return null
       }
    }
    
    function workloop(root) {
       nextNode = root
       while (nextNode !== null && (no other high priority task)) {
          nextNode = renderNode(nextNode)
       }
    }
    

注意在 workloop 当中，while 条件 nextNode !== null && (no other high priority
task)，这是描述 Fiber 工作原理的关键伪代码。

当然这里是为了说明链表的数据结构，伪代码较为简略，也没有深入：

  * requestAnimationFrame(callback)
  * requestIdleCallback(callback)

的实现和应用。React Fiber 的介绍我们先到此为止，重点是体会链表数据结构的思想。

### 链表实现

实现链表，我们需要先对链表进行分类，常见的有：

  * 单链表：单链表是维护一系列节点的数据结构，其特点是：每个节点包含了数据，同时包含指向链表中下一个节点的指针。
  * 双向链表：不同于单链表，双向链表特点：每个节点分除了包含其数据以外，还包含了分别指向其前驱和后继节点的指针。

由于篇幅有原因，我们挑选更加复杂的双向链表进行实现，实现思路如下。

首先，根据双向链表的特点，我们实现一个节点构造函数（节点类）：

    
    
    class Node {
        constructor(data) {
            // data 为当前节点所储存的数据
            this.data = data
            // next 指向下一个节点
            this.next = null
            // prev 指向前一个节点
            this.prev = null
        }
    }
    

有了节点类，我们来初步实现双向链表类：

    
    
    class DoublyLinkedList {
        constructor() {
            // 双向链表开头
            this.head = null
            // 双向链表结尾
          this.tail = null
        }
    
        // ...
    }
    

接下来，需要实现双向链表原型上的一些方法，这些方法包括

  * add：在链表尾部添加一个新的节点
  * addAt：在链表指定位置添加一个新的节点
  * remove：删除链表指定数据项节点
  * removeAt：删除链表指定位置节点
  * reverse：翻转链表
  * swap：交换两个节点数据
  * isEmpty：查询链表是否为空
  * length：查询链表长度
  * traverse：遍历链表
  * find：查找某个节点的索引

add 方法：

    
    
    add(item) {
      // 实例化一个节点
      let node = new Node(item)
    
      // 如果当前链表还没有头
      if(!this.head) {
        this.head = node
        this.tail = node
      } 
      // 如果当前链表已经有了头，只需要在尾部加上该节点
      else {
        node.prev = this.tail
        this.tail.next = node
        this.tail = node
      }
    }
    

addAt 方法：

    
    
    addAt(index, item) {
       let current = this.head
       // 维护查找时当前节点的索引
       let counter = 1
       let node = new Node(item)
    
       // 如果在头部插入
       if (index === 0) {
         this.head.prev = node
         node.next = this.head
         this.head = node
       } 
       // 非头部插入，需要从头开始，找寻插入位置
       else {
         while(current) {
          current = current.next
          if( counter === index) {
            node.prev = current.prev
            current.prev.next = node
            node.next = current
            current.prev = node
          }
          counter++
        }
      }
    }
    

remove 方法：

    
    
    remove(item) {
      let current = this.head
    
      while (current) {
           // 找到了目标节点
        if (current.data === item ) {
          // 目标链表只有当前目标项，即目标节点即是链表头又是链表尾
          if (current == this.head && current == this.tail) {
            this.head = null
            this.tail = null
          } 
          // 目标节点为链表头
          else if (current == this.head ) {
            this.head = this.head.next
            this.head.prev = null
          } 
          // 目标节点为链表尾部
          else if (current == this.tail ) {
            this.tail = this.tail.prev;
            this.tail.next = null;
          } 
          // 目标节点在链表收尾之间，中部
          else {
            current.prev.next = current.next;
            current.next.prev = current.prev;
          }
       }
       current = current.next
      }
    }
    

removeAt 方法：

    
    
    removeAt(index) {
      // 都是从“头”开始遍历
      let current = this.head
      let counter = 1
    
      // 删除链表头部
      if (index === 0 ) {
       this.head = this.head.next
       this.head.prev = null
      } 
      else {
       while(current) {
        current = current.next
        // 如果目标节点在链表尾
        if (current == this.tail) {
         this.tail = this.tail.prev
         this.tail.next = null
        } 
        else if (counter === index) {
         current.prev.next = current.next
         current.next.prev = current.prev
         break
        }
        counter++
       }
      }
    }
    

reverse 方法：

    
    
    reverse() {
      let current = this.head
      let prev = null
    
      while (current) {
       let next = current.next
    
       // 前后倒置
       current.next = prev
       current.prev = next
    
       prev = current
       current = next
      }
    
      this.tail = this.head
      this.head = prev
    }
    

swap 方法，交换两个节点数据值：

    
    
    swap(index1, index2) {
      // 使 index1 始终小于 index2，方便后面查找交换
      if (index1 > index2) {
        return this.swap(index2, index1)
      }
    
      let current = this.head
      let counter = 0
      let firstNode
    
      while(current !== null) {
        // 找到第一个节点，先存起来
        if (counter === index1 ){
            firstNode = current
        } 
    
        // 找到第二个节点，进行数据交换
        else if (counter === index2) {
          // ES 提供了更简洁交换数据的方法，这里我们用传统方式实现，更为直观
          let temp = current.data
          current.data = firstNode.data
          firstNode.data = temp
        }
    
        current = current.next
        counter++
      }
      return true
    }
    

isEmpty 方法：

    
    
    isEmpty() {
      return this.length() < 1
    }
    

这里通过 DoublyLinkedList 类 length 的方法实现。马上看一下 length 方法：

    
    
    length() {
      let current = this.head
      let counter = 0
      while(current !== null) {
        counter++
        current = current.next
      }
      return counter
    }
    

length 方法通过遍历链表，返回链表的长度。

traverse 方法：

    
    
    traverse(fn) {
      let current = this.head
      while(current !== null) {
        fn(current)
        current = current.next
      }
      return true
    }
    

有了上面 length 方法的遍历实现，traverse 也就不难理解了，它接受一个遍历执行函数，在 while 循环中进行调用。

最后一个 search 方法：

    
    
    search(item) {
      let current = this.head
      let counter = 0
    
      while( current ) {
        if( current.data == item ) {
          return counter
        }
        current = current.next
        counter++
      }
      return false
    }
    

到此，我们就实现了所有 DoublyLinkedList
类双向链表的方法。仔细分析整个实现过程，可以发现：双向链表的实现并不复杂，在手写过程当中，需要开发者做到心中有表，考虑到当前节点的 next 和 prev
取值，逻辑上还是很简单的。

掌握了这些内容，在回想一下链表的应用，回想 React Fiber 的设计和实现，也许一切都变的不再神秘。

### 树

前端开发者应该对树这个数据结构丝毫不陌生，不同于之前介绍的所有数据结构，树是非线性的。因为树决定了其存储的数据直接有明确的层级关系，因此对于维护具有层级特性的数据，树是一个天然良好的选择。

在前面总领中，我们看到树有很多种分类，但是他们都具有以下特性：

  * 除了根节点以外，所有的节点都有一个父节点
  * 每一个节点都 **可以有** 若干子节点，如果没有子节点，那么称此节点为叶子节点
  * 一个节点所拥有的叶子节点的个数，称之为该节点的度，因此叶子节点的度为 0
  * 所有节点中，最大的度为整棵树的度
  * 树的最大层次称为树的深度

从应用上来看，我们前端开发离不开的 DOM 就是一个树状结构；同理，不管是 React 还是 Vue 的虚拟 DOM 也都是树。

我们从最基本的二叉树入手，来慢慢深入。

#### 二叉搜索树的实现和遍历

说二叉树最为基本，因为他的结构最简单，每个节点至多包含两个子节点。二叉树又非常有用：因为根据二叉树，我们可以延伸出二叉搜索树（BST）、平衡二叉搜索树（AVL）、红黑树（R/B
Tree）等。

二叉搜索树有以下特性：

  * 左子树上所有结点的值均小于或等于它的根结点的值
  * 右子树上所有结点的值均大于或等于它的根结点的值
  * 左、右子树也分别为二叉搜索树

根据其特性，我们实现二叉搜索树还是应该先构造一个节点类：

    
    
    class Node { 
      constructor(data) { 
        this.left = null
        this.right = null
        this.value = data
      } 
    } 
    

接着按照惯例，我们实现二叉搜索树的以下方法：

  * insertNode：根据一个父节点，插入一个子节点
  * insert：插入一个新节点
  * removeNode：根据一个父节点，移除一个子节点
  * remove：移除一个节点
  * findMinNode：获取子节点的最小值
  * searchNode：根据一个父节点，查找子节点
  * search：查找节点
  * preOrder：前序遍历
  * InOrder：中序遍历
  * PostOrder：后续遍历

    
    
    insertNode(root, newNode) {
      if (newNode.value < root.value) {
        (!root.left) ? root.left = newNode : this.insertNode(root.left, newNode)
      } else {
        (!root.right) ? root.right = newNode : this.insertNode(root.right, newNode)
      }
    }
    
    insert(value) {
        let newNode = new Node(value)
        if (!this.root) {
          this.root = newNode
        } else {
          this.insertNode(this.root, newNode)
        }
    }
    

理解这两个方法是理解二叉搜索树的关键，下面的其他方法也就“不在话下”。我们看，insertNode
方法先判断目标父节点和插入节点的值，如果插入节点的值更小，则考虑放到父节点的左边，接着递归调用 his.insertNode(root.left,
newNode)；如果插入节点的值更大，以此类推即可。

insert 方法只是多了一步构造 Node 节点实例，接下来区分有无父节点的情况，调用 this.insertNode 方法即可。

    
    
     removeNode(root, value) {
        if (!root) {
          return null
        }
    
        if (value < root.value) {
          root.left = this.removeNode(root.left, value)
          return root
        } else if (value > root.value) {
          root.right = tis.removeNode(root.right, value)
          return root
        } else {
          // 找到了需要删除的节点 
          // 如果当前 root 节点无左右子节点
          if (!root.left && !root.right) {
            root = null
            return root
          }
    
          // 只有左节点
          if (root.left && !root.right) {
            root = root.left
            return root
          } 
          // 只有右节点
          else if (root.right) {
            root = root.right
            return root
          }
    
          // 有左右两个子节点
          let minRight = this.findMinNode(root.right)
          root.value = minRight.value
          root.right = this.removeNode(root.right, minRight.value)
          return root
        }
      }
    
    remove(value) {
        if (this.root) {
          this.removeNode(this.root, value)
        }
    }
    

上述代码不难理解，可能最需要读者思考的就是：

    
    
    // 有左右两个子节点
    let minRight = this.findMinNode(root.right)
    root.value = minRight.value
    root.right = this.removeNode(root.right, minRight.value)
    return root
    

我来特殊说明一下：当需要删除的节点含有左右两个子节点时，因为我们要把当前节点删除，就需要找到合适的“补位”节点，这个“补位”节点一定在该目标节点的右侧树当中，因为这样才能保证“补位”节点的值一定大于该目标节点的左侧树所有节点，而该目标节点的左侧树不需要调整；同时为了保证“补位”节点的值一定要小于该目标节点的右侧树值，因此要找的“补位”节点其实就是该目标节点的右侧树当中最小的那个节点。

这个过程我们借助 this.findMinNode 方法实现：

    
    
    findMinNode(root) {
        if (!root.left) {
          return root
        } else {
          return this.findMinNode(root.left)
        }
    }
    

该方法不断递归，直到找到最左叶子节点即可。

查找方法：

    
    
    searchNode(root, value) {
        if (!root) {
          return null
        }
    
        if (value < root.value) {
          return this.searchNode(root.left, value)
        } else if (value > root.value) {
          return this.searchNode(root.right, value)
        }
    
        return root
    }
    
    search(value) {
        if (!this.root) {
          return false
        }
        return Boolean(this.searchNode(this.root, value))
    }
    

这也比较简单，其实就是对递归的运用。最能体现递归简便优势的其实是对于树的遍历：

前序遍历：

    
    
    preOrder(root) {
        if (root) {
          console.log(root.value)
          this.preOrder(root.left)
          this.preOrder(root.right)
        }
    }
    

中序遍历：

    
    
    inOrder(root) {
        if (root) {
          this.inOrder(root.left)
          console.log(root.value)
          this.inOrder(root.right)
        }
    }
    

后序遍历：

    
    
    postOrder(root) {
        if (root) {
          this.postOrder(root.left)
          this.postOrder(root.right)
          console.log(root.value)
        }
    }
    

前后中序遍历其实就在于 console.log(root.value) 方法执行的位置。

#### 字典树

字典树（Trie）是针对特定类型的搜索而优化的树数据结构。典型的例子是
autoComplete，也就是说它适合实现：通过部分值得到完整值的场景。字典树因此也是一种搜索树，我们有时候也叫做前缀树，因为任意一个节点的后代都存在共同的前缀。更多基础概念请读者先做了解。我们总结一下它的特点：

  * 字典树能做到高效查询和插入，时间复杂度为 O(k)，k 为字符串长度
  * 但是如果大量字符串没有共同前缀，那就很耗内存，读者可以想象一下最极端的情况，所有单词都没有共同前缀时，这颗字典树是什么样子
  * 字典树的核心就是减少没必要的字符比较，使查询高效率，也就是说用空间换时间，再利用共同前缀来提高查询效率

除了我们刚刚提到的 autoComplete 自动填充的情况，字典树还有很多其他应用场景：

  * 搜索
  * 输入法选项
  * 分类
  * IP 地址检索
  * 电话号码检索

#### 字典树的实现和遍历

字典树的实现也不复杂，我们慢慢一步步来，首先实现一个字典树上的节点：

    
    
    class PrefixTreeNode {
      constructor(value) {
        // 存储子节点
        this.children = {}
        this.isEnd = null
        this.value = value
      }
    }
    

一个字典树继承 PrefixTreeNode 类：

    
    
    class PrefixTree extends PrefixTreeNode {
      constructor() {
        super(null)
      }
    }
    

我们实现方法：

  * addWord：创建一个字典树节点
  * predictWord：给定一个字符串，返回字典树中以该字符串开头的所有单词

addWord 实现：

    
    
    addWord(str) {
        const addWordHelper = (node, str) => {
              // 当前 node 不含当前 str 开头的目标
            if (!node.children[str[0]]) {
                // 以当前 str 开头的第一个字母，创建一个 PrefixTreeNode 实例
                node.children[str[0]] = new PrefixTreeNode(str[0])
                if (str.length === 1) {
                    node.children[str[0]].isEnd = true
                } 
                else if (str.length > 1) {
                    addWordHelper(node.children[str[0]], str.slice(1))
                }
            }
        }
        addWordHelper(this, str)
    }
    

predictWord 实现：

    
    
    predictWord(str) {
        let getRemainingTree = function(str, tree) {
          let node = tree
          while (str) {
            node = node.children[str[0]]
            str = str.substr(1)
          }
          return node
        }
    
        // 该数组维护所有以 str 开头的单词
        let allWords = []
    
        let allWordsHelper = function(stringSoFar, tree) {
          for (let k in tree.children) {
            const child = tree.children[k]
            let newString = stringSoFar + child.value
            if (child.endWord) {
              allWords.push(newString)
            }
            allWordsHelper(newString, child)
          }
        }
    
        let remainingTree = getRemainingTree(str, this)
    
        if (remainingTree) {
          allWordsHelper(str, remainingTree)
        }
    
        return allWords
    }
    

### 图

图是由具有边的节点集合组成的数据结构，图可以是定向的或不定向的。因此图可以分为好多种类，这里不一一讲解，主要看图的应用场景：

  * LBS 地图服务以及 GPS 系统
  * 社交媒体网站的用户关系图
  * 前端工程化中的开发依赖图
  * 搜索算法使用图，保证搜索结果的相关性
  * 寻找降低运输和交付货物和服务成本的最佳途径

图也是应用最广泛的数据结构之一，真实场景中处处有图。更多概念还是需要读者先进行了解，尤其是图的几种基本元素：

  * 节点 Node
  * 边 Edge
  * |V| 图中顶点（节点）的总数
  * |E| 图中的连接总数（边）

#### 图的实现和遍历

这里我们主要实现一个有向图，Graph 类：

    
    
    class Graph {
      constructor() {
        this.AdjList = new Map()
      }
    }
    

使用 Map 数据结构表述图中顶点关系。

实现方法：

  * 添加顶点：addVertex
  * 添加边：addEdge
  * 打印图：print
  * 广度优先算法遍历
  * 深度优先算法

addVertex 方法：

    
    
    addVertex(vertex) {
      if (!this.AdjList.has(vertex)) {
        this.AdjList.set(vertex, [])
      } else {
        throw 'vertex already exist!'
      }
    }
    

创建顶点：

    
    
    let graph = new Graph();
    graph.addVertex('A')
    graph.addVertex('B')
    graph.addVertex('C')
    graph.addVertex('D')
    

其中 A、B、C、D 顶点都对应一个数组：

    
    
      'A' => [],
      'B' => [],
      'C' => [],
      'D' => []
    

该数组将用来存储边。我们设计图预计得到如下关系：

    
    
    Map {
      'A' => ['B', 'C', 'D'],
      'B' => [],
      'C' => ['B'],
      'D' => ['C']
    }
    

根据此描述，其实已经可以把图画出来了。addEdge 因此需要两个参数：一个是顶点，一个是连接对象 Node：

    
    
     addEdge(vertex, node) {
        if (this.AdjList.has(vertex)) {
          if (this.AdjList.has(node)){
            let arr = this.AdjList.get(vertex)
            if(!arr.includes(node)){
              arr.push(node)
            }
          }else {
            throw `Can't add non-existing vertex ->'${node}'`
          }
        } else {
          throw `You should add '${vertex}' first`
        }
    }
    

理清楚数据关系，我们就可以打印图了，其实就是一个很简单的 for...of 循环：

    
    
    print() {
      for (let [key, value] of this.AdjList) {
        console.log(key, value)
      }
    }
    

剩下的内容就是遍历图了。

广度优先算法（BFS），是一种利用队列实现的搜索算法。对于图，其搜索过程和 “湖面丢进一块石头激起层层涟漪”
类似。换成算法语言，就是从起点出发，对于每次出队列的点，都要遍历其四周的点。

因此 BFS 的实现步骤：

  * 起始节点作为起始，并初始化一个空对象：visited
  * 初始化一个空数组，该数组将模拟一个队列
  * 将起始节点标记为已访问
  * 将起始节点放入队列中
  * 循环直到队列为空

实现：

    
    
    createVisitedObject() {
      let map = {}
      for(let key of this.AdjList.keys()) {
        arr[key] = false
      }
      return map
    }
    
    bfs(initialNode) {
      // 创建一个已访问节点的 map
      let visited = this.createVisitedObject()
      // 模拟一个队列
      let queue = []
    
      // 第一个节点已访问
      visited[initialNode] = true
      // 第一个节点入队列
      queue.push(initialNode)
    
      while(queue.length) {
        let current = queue.shift()
        console.log(current)
    
         // 获得该节点的其他节点关系
        let arr = this.AdjList.get(current)
    
        for (let elem of arr) {
          // 如果当前节点没有访问过
          if (!visited[elem]) {
            visited[elem] = true
            q.push(elem)
          }
        }
      }
    }
    

那么对于深度优先搜索算法（DFS），我把它总结为：“不撞南墙不回头”，从起点出发，先把一个方向的点都遍历完才会改变方向。换成程序语言就是：“DFS
是利用递归实现的搜索算法”。

因此 DFS 过程：

  * 起始节点作为起始，创建访问对象
  * 调用辅助函数递归起始节点

实现代码：

    
    
    createVisitedObject() {
      let map = {}
      for (let key of this.AdjList.keys()) {
        arr[key] = false
      }
      return map
    }
    
     dfs(initialNode) {
        let visited = this.createVisitedObject()
        this.dfsHelper(initialNode, visited)
      }
    
      dfsHelper(node, visited) {
        visited[node] = true
        console.log(node)
    
        let arr = this.AdjList.get(node)
    
        for (let elem of arr) {
          if (!visited[elem]) {
            this.dfsHelper(elem, visited)
          }
        }
      }
    }
    

BFS 的重点在于队列，而 DFS 的重点在于递归，这是它们的本质区别。

#### 图在前端中的应用

图其实在前端中应用不算特别多，但绝对还是不容忽视的一部分。这里我举一个我现实中应用的例子——循环图。

在前端工程化发展的今天，理清项目中的依赖关系：比如查找项目中的循环依赖，可视化依赖都是图的应用，有助于开发者在宏观上把控工程化项目。在我们的项目中，我借助
[mermaidj](https://mermaidjs.github.io/#/) 画图工具，实现了项目依赖的完全可视化。并借助 npm script
来生成图片结果，相关 script 脚本：

    
    
    yarn graph
    

脚本：

    
    
    import glob from 'glob'
    import readJSON from 'XXX/utils/readJSON'
    
    const pkgs = glob.sync('packages/*/package.json').map(readJSON)
    
    const deps = {}
    
    for (const pkg of pkgs) {
      deps[pkg.name] = Object.keys(pkg.dependencies || []).filter(dep =>
        // ...
      )
    }
    
    const graph = { code: '', mermaid: { theme: 'default' } }
    
    graph.code += 'graph TD;'
    for (const name in deps) {
      for (const dep of deps[name]) {
        graph.code += `${name}-->${dep};`
      }
    }
    
    const base64 = Buffer.from(JSON.stringify(graph)).toString('base64')
    
    /* eslint-disable-next-line */
    console.log(
      `Open in browser: https://mermaidjs.github.io/mermaid-live-editor/#/edit/${base64}`
    )
    

上述代码，我首先获取到 packages/*/package.json 中声明的所有依赖，然后对依赖进行必要性过滤之后，维护到 deps 对象当中，按照
mermaid 需求，将 monorepo 项目中的每一个子项目名和依赖按照 → 的间隔维护为 graph.code，最后通过生成 base64 交给
mermaid 进行绘图，绘图过程会根据约定（→ 的标记），成生可视化的依赖图。

最终效果：

![enter image description
here](https://images.gitbook.cn/d92587a0-d04f-11e9-82a1-439033eb1f8a)

那么 mermaid 是如何对图进行绘制的呢？了解了课程前面实现图的代码，我们再看 mermaid 绘制图的部分源码实现：

    
    
    export const addVertices = function (vert, g, svgId) {
      const svg = d3.select(`[id="${svgId}"]`)
      const keys = Object.keys(vert)
    
      const styleFromStyleArr = function (styleStr, arr) {
        // Create a compound style definition from the style definitions found for the node in the graph definition
        for (let i = 0; i < arr.length; i++) {
          if (typeof arr[i] !== 'undefined') {
            styleStr = styleStr + arr[i] + ';'
          }
        }
    
        return styleStr
      }
    
      // Iterate through each item in the vertex object (containing all the vertices found) in the graph definition
      keys.forEach(function (id) {
        const vertex = vert[id]
    
        /**
         * Variable for storing the classes for the vertex
         * @type {string}
         */
        let classStr = ''
        if (vertex.classes.length > 0) {
          classStr = vertex.classes.join(' ')
        }
    
        /**
         * Variable for storing the extracted style for the vertex
         * @type {string}
         */
        let style = ''
        // Create a compound style definition from the style definitions found for the node in the graph definition
        style = styleFromStyleArr(style, vertex.styles)
    
        // Use vertex id as text in the box if no text is provided by the graph definition
        let vertexText = vertex.text !== undefined ? vertex.text : vertex.id
    
        // We create a SVG label, either by delegating to addHtmlLabel or manually
        let vertexNode
        if (conf.htmlLabels) {
          // TODO: addHtmlLabel accepts a labelStyle. Do we possibly have that?
          const node = { label: vertexText.replace(/fa[lrsb]?:fa-[\w-]+/g, s => `<i class='${s.replace(':', ' ')}'></i>`) }
          vertexNode = addHtmlLabel(svg, node).node()
          vertexNode.parentNode.removeChild(vertexNode)
        } else {
          const svgLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text')
    
          const rows = vertexText.split(/<br[/]{0,1}>/)
    
          for (let j = 0; j < rows.length; j++) {
            const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan')
            tspan.setAttributeNS('http://www.w3.org/XML/1998/namespace', 'xml:space', 'preserve')
            tspan.setAttribute('dy', '1em')
            tspan.setAttribute('x', '1')
            tspan.textContent = rows[j]
            svgLabel.appendChild(tspan)
          }
          vertexNode = svgLabel
        }
    
        // If the node has a link, we wrap it in a SVG link
        if (vertex.link) {
          const link = document.createElementNS('http://www.w3.org/2000/svg', 'a')
          link.setAttributeNS('http://www.w3.org/2000/svg', 'href', vertex.link)
          link.setAttributeNS('http://www.w3.org/2000/svg', 'rel', 'noopener')
          link.appendChild(vertexNode)
          vertexNode = link
        }
    
        let radious = 0
        let _shape = ''
        // Set the shape based parameters
        switch (vertex.type) {
          case 'round':
            radious = 5
            _shape = 'rect'
            break
          case 'square':
            _shape = 'rect'
            break
          case 'diamond':
            _shape = 'question'
            break
          case 'odd':
            _shape = 'rect_left_inv_arrow'
            break
          case 'lean_right':
            _shape = 'lean_right'
            break
          case 'lean_left':
            _shape = 'lean_left'
            break
          case 'trapezoid':
            _shape = 'trapezoid'
            break
          case 'inv_trapezoid':
            _shape = 'inv_trapezoid'
            break
          case 'odd_right':
            _shape = 'rect_left_inv_arrow'
            break
          case 'circle':
            _shape = 'circle'
            break
          case 'ellipse':
            _shape = 'ellipse'
            break
          case 'group':
            _shape = 'rect'
            break
          default:
            _shape = 'rect'
        }
        // Add the node
        g.setNode(vertex.id, { labelType: 'svg', shape: _shape, label: vertexNode, rx: radious, ry: radious, 'class': classStr, style: style, id: vertex.id })
      })
    }
    
    /**
     * Add edges to graph based on parsed graph defninition
     * @param {Object} edges The edges to add to the graph
     * @param {Object} g The graph object
     */
    export const addEdges = function (edges, g) {
      let cnt = 0
    
      let defaultStyle
      if (typeof edges.defaultStyle !== 'undefined') {
        defaultStyle = edges.defaultStyle.toString().replace(/,/g, ';')
      }
    
      edges.forEach(function (edge) {
        cnt++
        const edgeData = {}
    
        // Set link type for rendering
        if (edge.type === 'arrow_open') {
          edgeData.arrowhead = 'none'
        } else {
          edgeData.arrowhead = 'normal'
        }
    
        let style = ''
        if (typeof edge.style !== 'undefined') {
          edge.style.forEach(function (s) {
            style = style + s + ';'
          })
        } else {
          switch (edge.stroke) {
            case 'normal':
              style = 'fill:none'
              if (typeof defaultStyle !== 'undefined') {
                style = defaultStyle
              }
              break
            case 'dotted':
              style = 'stroke: #333; fill:none;stroke-width:2px;stroke-dasharray:3;'
              break
            case 'thick':
              style = 'stroke: #333; stroke-width: 3.5px;fill:none'
              break
          }
        }
        edgeData.style = style
    
        if (typeof edge.interpolate !== 'undefined') {
          edgeData.curve = interpolateToCurve(edge.interpolate, d3.curveLinear)
        } else if (typeof edges.defaultInterpolate !== 'undefined') {
          edgeData.curve = interpolateToCurve(edges.defaultInterpolate, d3.curveLinear)
        } else {
          edgeData.curve = interpolateToCurve(conf.curve, d3.curveLinear)
        }
    
        if (typeof edge.text === 'undefined') {
          if (typeof edge.style !== 'undefined') {
            edgeData.arrowheadStyle = 'fill: #333'
          }
        } else {
          edgeData.arrowheadStyle = 'fill: #333'
          if (typeof edge.style === 'undefined') {
            edgeData.labelpos = 'c'
            if (conf.htmlLabels) {
              edgeData.labelType = 'html'
              edgeData.label = '<span class="edgeLabel">' + edge.text + '</span>'
            } else {
              edgeData.labelType = 'text'
              edgeData.style = edgeData.style || 'stroke: #333; stroke-width: 1.5px;fill:none'
              edgeData.label = edge.text.replace(/<br>/g, '\n')
            }
          } else {
            edgeData.label = edge.text.replace(/<br>/g, '\n')
          }
        }
        // Add the edge to the graph
        g.setEdge(edge.start, edge.end, edgeData, cnt)
      })
    }
    

**那么根据我的脚本，用 → 表现的依赖关系，除了可视化以外，还有其他用处吗？**
其实肯定是有的，除了“花架子”，这个依赖图对于项目的部署构建也有非常重要的作用。比如在对 monorepo
项目进行构建时，因为子项目过多，导致构建时间过长。为此，我给出的方案是增量构建，如果这次改动只设计项目 A、项目 B，以及公共依赖 C，那么项目 C，项目
D 等其他项目在构建时只需要读取缓存构建结果即可。思路是很简单，但是一个直接问题是，如果检测说真正需要构建的项目呢？

举个例子，项目 A 依赖公共依赖 C，那么及时通过 git hook 拿到的 diff 表明项目 A 并没有代码变动，但是可能因为 C
变了，我们还需要重新构建项目 A（因为 A 依赖 C）。按照正常的思路，需要遍历整个项目，这样带来的问题是增加了回溯构建的可能：构建时先遍历到
A，读取缓存，再遍历到 C 时，不得不回退到 A，重新构建。解决思路就是使用一个拓扑图，根据拓扑图，按照一定的顺序进行遍历和编译构建即可。

这是我近期一个使用到拓扑图数据结构的经典场景。具体实施过程因为机密性，我不在贴代码了，对于读者来说，更重要地是体会思想，相信自己动手实现也不会困难。

### 散列表（哈希表）

散列表是一种以 key-value
形式存储数据的数据结构，可以把散列表理解为一种高级的数组，这种数组的下标可以是很大的整数，浮点数，字符串甚至结构体。这种数据结构非常有用，js 里的
Map/Set/WeakMap/WeakSet 在 v8 里都是通过散列表来实现的，再比如 LRU
Cache、数据库索引等非常多的场景也都能看到散列表的身影。

散列并不仅仅是一种技术，从某种意义上讲，它甚至是一种思想。接下来让我们一起揭开散列表神秘的面纱。

假如，我们要存储 key 为 6、2019、2333333 的三组数据，如果用数组来存，至少需要一个长度为 2333333
的数组来做这件事情，显然这种做法存在大量的空间浪费。

我们也可以像下图一样，准备一个长度为 10 的数组（bucket array），将每一个 key 通过一个散列函数（hash
function），映射到桶数组中的一位，将 key 相应的值直接存入即可。可以看到这种方式只需使用一个长度为 10 的数组，同时查找和插入的时间复杂度都是
O(1)。这就是散列表的核心思想。

![](https://images.gitbook.cn/52397840-c57e-11e9-9d70-f58ea827d9ae)

散列表中的几个概念：

  * 桶（bucket），用来直接存放或间接指向一个数据
  * 桶数组（bucket array）由桶组成的数组
  * 散列函数（hash function）将 key 转换为桶数组下标的函数

上面的例子比较简单，如果我们继续在之前的基础上再存储一个 key 为 9 的数据，通过 9 % 10 计算得出的也是落在下标为 9 的 bucket
上，此时有两个不同的 key 落在了同一个 bucket 上，这一现象被称为散列冲突。

散列冲突理论上是不可避免的，我们能做的优化主要从以下两个方面入手：

  * 精心设计桶数组长度及散列函数，尽可能降低冲突的概率
  * 发生冲突时，能对冲突进行排解

假设不用散列表直接用数组来存储需要的数组长度为 R，用散列表存储需要的桶数组长度为 M，需要存储的元素个数为 N，则一定存在以下关系 `N < M <<
R`，只有这样散列表才能既保持操作的高效同时起到节省空间的效果。

其中，N / M 称为散列表的装载因子，当装载因子超过一定的阈值时，需要对桶数组扩容并 rehash。

理想的散列函数遵循以下的设计原则：

  * 确定：同一 key 总是被映射至同一地址
  * 高效：插入/查找/删除 excepted-O(1) 时间复杂度
  * 满射：尽可能充分地覆盖整个桶数组空间
  * 均匀：key 映射到桶数组各位置的概率尽量接近

常用的散列函数如下。

**除余法**

`hash(key) = key % M`，直接对 key 按桶数组的长度取余，这种方法非常简单，但存在以下缺陷。

  * 存在不动点：无论桶数组长度 M 取何值，总有 `hash(0) = 0`，这与任何元素都有均等的概率被映射到任何位置的原则相违背。
  * 零阶均匀：`[0, R)` 的关键码，平均分配至 M 个桶；但相邻关键码的散列地址也必相邻。

**MAD 法 multiply-add-divide**

`hash(key) = (a x key + b) % M`，跟除余法相比，引入的变量 b 可以视作偏移量，可有效的消除不动点，另一个变量 a
扮演着步长的角色，也就是说原本相邻的关键码在经过散列后步长为 a，从而不再继续相邻。

**平方取中 mid-square**

取 `key^2` 的中间若干位，构成地址：

  * `hash(123) = 512` // 保留 key^2 = 123^2 = 15219 的中间 3 位
  * `hash(1234567) = 556` // 1234567^2 = 1524155677489

我们可以将一个数的平方运算，分解为一系列的左移操作以及若干次加法，从下图中不难看出，每一个数位都是由原关键码中的若干数位经求和得到的，因此两侧的数位由更少的原数位求和而得，越是居中的数位，则是由更多的原数位积累而得，因此截取居中的若干位，可使得原关键码的各数位都能对最终结果产生影响，从而实现更好的均匀性

![](https://images.gitbook.cn/c06093f0-c71b-11e9-9e56-8d3dec542204)

**多项式法**

在实际应用中，我们的 key
不一定都是整数形式，因此往往需要一个预处理将其转换为散列码(hashcode)，然后才可以对其进一步处理为桶数组的下标地址。整个过程可以描述为 key →
hashcode → bucket addr，多项式法就是一种有效的将字符串 key 转换为 hashcode 的方法 对于一个长度为 n
的字符串，其计算过程如下：

    
    
    hash(x0 x1 ... xn-1) = x0 * a^(n-1) + x1 * a^(n-2) ... + xn-2 * a + xn-1 
    // 如果上面的不是很理解，它其实等价于下面这样
    (...((x0 * a + x1) * a + x2) * a + ... xn-2) * a + xn-1)
    

这个多项式可以在 O(n) 而不是 O(n2) 的时间复杂度内计算出结果，具体证明的过程这里就不详细展开了。

在实际的工程中会采用如下这种近似多项式，但更快捷的做法：

    
    
    function hash(key) {
        let h = 0
        for (let n = key.length, i = 0; i != n; i++) {
            h = (h << 5 | h >> 27)
            h += key[i].charCodeAt()
        }
        return h >>> 0
    }
    

通过一个循环依次处理字符串的每一个字符，对于每一个字符将它转换为整数后累加，在累加之前对原有的累积值，都按照 h << 5 | h >> 27
这样的规则做一个数位变换

![bit-
operations](https://images.gitbook.cn/81040300-c747-11e9-a05e-8fabd2e19d71)

这一不断调整累加的过程，实际上可以是作为是对以上多项式计算的近似，只不过这里消除掉了相对耗时的乘法运算，至于如何理解和解释这种近似的效果，可以作为本文课后的一项作业。

除了上文讲到的方法外，还有非常多的散列函数的方法，如折叠法、位异或法、（伪）随机数法，此类方法林林总总，每种方法都有各自的特点及应用的场景，由于篇幅原因这里就不再展开了，感兴趣的读者可以在读者群中继续研究和探讨。

总之散列函数产生的关键码越是随机，越是没有规律就越好。

**冲突解决方法**

主要的处理散列表冲突的方法有开链法和探测法这两类。

  * **开链法（linked-list chaining / seperate chaining）**

每个桶存放一个指针，将冲突的 key 以链表的形式组织起来，这种处理方式最大的优点是能解决任意次数的冲突，但缺点也很明显，最极端的情况所有的 key
数据都落在一个桶上时，散列表将退化为一个链表，查找插入删除的复杂度都将变成 O(n)。

![](https://images.gitbook.cn/23cf29b0-c749-11e9-9e56-8d3dec542204)

  * **探测法（open addressing / closed hashing）**

探测法所有的冲突都在这块连续的空间中加以排解，而不用像开链法那样申请额外的空间。当存入一个 key
时，所有的桶都按照某种优先级关系排成一个序列，从本该属于该 key 的桶出发，顺次查看每一个桶直到找到可用的桶。每个 key
对应的这样的一个序列，称为试探序列或者查找链，在查找 key 时，沿查找链查找有两种结果，在桶中找到了查询的 key
也就是查找成功，还有的一种可能是找到一个空桶，则说明查找失败，没有这个 key。

最简单的试探序列的生成方法叫做线性试探（Linear
probing），具体做法是一旦发生冲突，则试探后一个紧邻的桶单元，直到成功或失败。这种做法的优点是无需附加的（指针、链表等）空间，缺点也很明显，以往的冲突会导致后续的冲突。

    
    
    [hash(key) + 1] % M
    [hash(key) + 2] % M
    [hash(key) + 3] % M
    ...
    

线性试探的问题根源在于大部分的试探位置都集中在某一个相对较小的局部，因此优化线性试探的方式就是适当的拉开各次探测的间距，平方试探（Quadratic
Probing）就是基于这一优化思路的具体实现方式，所谓平方试探顾名思义就是以平方数为距离，确定下一试探桶单元。

    
    
    [hash(key) + 1^2] % M
    [hash(key) + 2^2] % M
    [hash(key) + 3^2] % M
    ...
    

相对于线性试探，平方探测的确可以在很大程度上缓解数据聚集的现象，查找链上，各桶间距线性递增，一旦冲突，可从没地逃离是非之地。

### 散列表的实现

最后用 JavaScript 来模拟实现一下 hashtable，这里我们采用开链法来解决散列的冲突。

    
    
    // 单向链表节点
    class ForwardListNode {
        constructor(key, value) {
            this.key = key
            this.value = value
            this.next = null
        }
    }
    
    class Hashtable {
      constructor(bucketSize = 97) {
        this._bucketSize = bucketSize
        this._size = 0
        this._buckets = new Array(this._bucketSize)
      }
    
      hash(key) {
        let h = 0
        for (let n = key.length, i = 0; i != n; i++) {
          h = (h << 5 | h >> 27)
          h += key[i].charCodeAt()
        }
        return (h >>> 0) % this._bucketSize
      }
    
      // Modifiers
      put(key, value){
        let index = this.hash(key);
        let node = new ForwardListNode(key, value)
    
        if (!this._buckets[index]) {
          // 如果桶是空的，则直接把新节点放入桶中即可
          this._buckets[index] = node
        } else {
          // 如果桶不为空，则在链表头插入新节点
          node.next = this._buckets[index]
          this._buckets[index] = node
        }
        this._size++
        return index
      }  
    
      delete(key) {
        let index = this.hash(key)
        if (!this._buckets[index]) {
          return false
        }
    
        // 添加一个虚拟头节点，方便后面的删除操作
        let dummy = new ForwardListNode(null, null)
        dummy.next = this._buckets[index]
        let cur = dummy.next, pre = dummy
        while (cur) {
          if (cur.key === key) {
            // 从链表删除该节点
            pre.next = cur.next
            cur = pre.next
            this._size--
          } else {
            pre =  cur
            cur = cur.next
          }
        }
        this._buckets[index] = dummy.next
        return true
      }
    
      // Lookup
      find(key){
        let index = this.hash(key);
        // 如果对应的 bucket 为空，说明不存在此 key
        if (!this._buckets[index]) {
          return null
        }
    
        // 遍历对应桶的链表
        let p = this._buckets[index]
        while (p) {
          // 找到 key
          if (p.key === key) {
            return p.value
          }
          p = p.next
        }
        return null
      } 
    
      // Capacity
      size() {
          return this._size
      }
    
      isEmpty() {
          return this._size == 0
      }
    }
    

### 总结

这一节课我们介绍了和前端最为贴合的几种数据结构，虽然篇幅较长，但是内容算不上太难。一些基本概念并没有深入讲解，
因为数据结构更重要的是应用，我希望读者能够做到的是：在需要的场景，能够想到最为适合的数据结构处理问题。请读者务必掌握好这些内容，接下来的算法章节需要对数据结构有一个较为熟练地掌握和了解。



## 古老又新潮的函数式

函数式这个概念我们在以往的课程中其实已经有所涉及了，比如第 1-2、1-3 课介绍的闭包知识；比如 1-4 课《我们不背诵 API，只实现 API》中剖析的
5 种 compose 方法，以及 reduce 实现 pipe、runPromiseInSequence 等都是典型的函数式概念。

函数式其实很早就出现在了编程领域当中，近些年由于 React 的带动，在前端开发中重新“焕发活力”。

很多读者可能一听到函数式就眉头一皱，毕竟相比于面向对象等其他编程概念，它更加晦涩难懂。对于函数式的学习，也一定不是使用或者模仿 compose
那么简单。这一节课，我们就来梳理几个函数式概念。但是我认为单纯的概念介绍并没有意义，因此也准备了大量实战例题以及库的设计方案，与大家一起分享。

![enter image description
here](https://images.gitbook.cn/bbd9d5a0-d448-11e9-a4b6-d1d2b628f523)

### 函数式和高质量函数

函数式通常意味着高质量的代码，本小节的主标题之所以是“函数式和高质量函数”，而不是“函数式和高质量代码”，因为在函数式看来，一切都是函数，“函数是第一等公民”。围绕着函数，取代面向过程式的代码，往往能够有以下收益：

  * **表达力更加清晰** ，因为“一切都是函数”，通过函数的合理命名，函数原子的拆分，我们能够一眼看出来程序在做什么，以及做的过程；
  * **利于复用** ，因为“一切都是函数”，函数本身具有天然的复用能力；
  * **利于维护** ，纯函数和幂等性保证同样的输入就有同样的输出，在维护或者调试代码时，能够更加专注，减少因为共享带来的潜在问题。

我们下面来通过概念具体展开。

#### 纯函数

之前我们提到过：

> 一个函数如果输入参数确定，输出结果是唯一确定的，那么它就是纯函数。

并且纯函数不能修改外部变量，造成副作用，不能调用 Math.radom() 方法以及发送异步请求等，因为这些操作都不具有确定性。

根据定义我们知道纯函数的特点是：

  * 无状态
  * 无副作用
  * 无关时序
  * 幂等（指无论调用多少次，结果相同）

看代码举例：

    
    
    let array = [1,2,3,4]
    
    // array 的 slice 方法属于纯函数方法，它不对数组本身进行操作
    // array 的 splice 方法不属于纯函数方法，它对数组本身进行操作 
    
    const minusCount = () => {
        window.count--
    } 
    
    // minusCount 不是纯函数，它依赖并改变外部变量，具有副作用
    
    const setHtml = (node, html) => {
        node.innerHtml = html
    } 
    
    // setHtml 不是纯函数，同上                                                     
    

这样的纯函数不仅易于维护，逻辑清晰，而且具有更好的组合和测试性。之前的课程中我们多次提到，这里不再单独展开。

#### 高阶函数

高阶函数体现了“函数是第一等公民”，它是指这样的一类函数：该函数接受一个函数作为参数，返回另外一个函数。

没错，和高阶组件的概念类似。为什么会有这么一个“怪异”的高阶函数呢？来看一个例子：filterLowerThan10
这个函数接受一个数组作为参数，它会挑选出数组中数值小于 10 的项目，所有符合条件的值都会构成新数组被返回：

    
    
    const filterLowerThan10 = array => {
        let result = []
        for (let i = 0, length = array.length; i < length; i++) {
            let currentValue = array[i]
            if (currentValue < 10) result.push(currentValue)
        }
        return result
    }
    

另外一个需求，挑选出数组中非数值项目，所有符合条件的值都会构成新数组被返回：

    
    
    const filterNaN = array => {
        let result = []
        for (let i = 0, length = array.length; i < length; i++) {
            let currentValue = array[i]
            if (isNaN(currentValue)) result.push(currentValue)
        }
        return result
    }
    

这都是很基本的面向过程编程的代码。不够优雅的一点是 filterLowerThan10 和 filterNaN 都有遍历的逻辑，都存在了重复的 for
循环。本质上都是遍历一个列表，并用给定的条件过滤列表。我们能否用函数式的思想，将遍历和筛选解耦呢？

好在 JavaScript 对函数式较为友好，我们使用 filter 函数来完成，并进行一定程度的改造：

    
    
    const lowerThan10 = value => value < 10
    
    [12, 3, 4, 89].filter(lowerThan10)
    
    [12, 'sd', null, undefined, {}].filter(isNaN)
    

这非常简单，我们以此来热身进入状态。

另一个高阶函数的典型应用场景是函数缓存：

    
    
    const memorize = fn => {
        let cacheMap = {}
        return function(...args) {
            const cacheKey = args.join('_')
            if (cacheKey in cacheMap) {
                return cache[cacheKey]
            } 
            else {
                return cacheMap[cacheKey] = fn.apply(this || {}, args)
            }
        }
    }
    

高阶函数可以和 decorator 相结合，再来看一个实例，实现有限次数函数调用的装饰器：

    
    
     class MyClass {
        @callLimit getSum() {}
    }
    

实现：

    
    
    function callLimit(limitCallCount = 1, level = 'warn') {
        // 记录调用次数
        let count = 0
        return function(target, name, descriptor) {
            // 记录原始函数
            var fn = descriptor.value
            // 改写新函数
            descriptor.value = function(...args) {
                if (count < limitCallCount) {
                    count++
                    return fn.apply(this || {}, args)
                }
                if (console[level]) console[level](name, 'call limit')
                console.warn(name, 'call limit')
            }
        }          
    }
    

严格来说，这也不算是一个高阶函数的使用场景，但是体现了类似的思想。读者可以举一反三。

#### 组合

继续延伸我们的场景，如果输入比较复杂，想先过滤出小于 10 的项目需要先保证数组中每一项都是 Number 类型，那么可以：

    
    
    [12, 'sd', null, undefined, {}, 23, 45, 3, 6].filter(value=> !isNaN(value) && value !== null).filter(lowerThan10)s
    

这样的做法得益于 JavaScript filter 对函数式的友好支持，链式调用也在一定程度上实现了组合性。

更加通用的组合做法是使用 compose 方法，收益非常直观：

  * 单一功能的小函数更好维护
  * 通过组合，将单一功能的小函数串联起来，完成复杂的功能
  * 复用性更好，硬编码更少

#### point free

point free 是指一种函数式的编程风格，有时候也可以叫做 tacit programming。point 在这里的意思是指形参，那么 point
free，自然就是指没有行参了。这样做的目的是什么呢？没有参数，就意味着我们将注意力放在函数本身上。一般参数存在的意义是传递或者携带某个值，函数根据这个值，来得到另一个值。这样造成的困扰是我们不得不操作数据，同时要给参数命名。如果没有参数，不返回一个数据，那么
point free 的目的就是得到一个函数。

当然业务中不可能永远不存在参数，因此我们允许底层函数非 point free，而 point free
函数更像是一种上层封装，它灵活调度带有参数的的底层函数，通过 point free 和非 point free
的解耦，使得代码更具有声明式特征，更具有美感。

point free 是我们的追求，而非标准，过度使用某种模式往往让代码“变坏”，这里给大家介绍这种概念，“见多识广”和“矫枉过正”往往只有一线之隔。

### curry 化分析

curry 化也是一个常见的概念，维基百科对齐解释为：

>
在计算机科学中，柯里化（currying），又译为卡瑞化或加里化，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。这个技术由克里斯托弗·斯特雷奇以逻辑学家哈斯凯尔·加里命名的。

简单来说，就是在一个函数中预先填充几个参数，这个函数返回另一个函数，这个返回的新函数将其参数和预先填充的参数进行合并，再执行函数逻辑。

那我们上述代码举例：

    
    
    const filterLowerThan10 = array => {
        let result = []
        for (let i = 0, length = array.length; i < length; i++) {
            let currentValue = array[i]
            if (currentValue < 10) result.push(currentValue)
        }
        return result
    }
    

filterLowerThan10 还是硬编码写死了 10 这个阈值，我们用 curry 化的思想将其改造：

    
    
    const filterLowerNumber = number => {
        return array => {
            let result = []
            for (let i = 0, length = array.length; i < length; i++) {
                let currentValue = array[i]
                if (currentValue < number) result.push(currentValue)
            }
            return result
        }
    }
    
    const filterLowerThan10 = filterLowerNumber(10)
    
    
    filterLowerThan10([1, 3, 5, 29, 34])
    

#### curry 化面试题

再通过一到面试题加深理解。

> 实现 add 方法，要求：

    
    
    add(1)(2) == 3 // true
    
    add(1)(2)(3) == 6 // true
    

分析这道题：add
函数每次执行后一定需要保证返回一个函数，以供后续继续调用，且返回的这个函数还有返回自身，以支持连续调用。同时，为了满足例题条件，需要改写内部返回的函数
toString：

    
    
    const add = arg1 => {
       const fn = arg2 => {
            return fn
        }
        fn.toString = function () {
    
        }
        return fn
    
    }
    

为了进行“求和”操作，需要在 add 函数内部维护一个闭包变量 args，args 是个数组，记录了每次调用是传进来的参数，toString
方法体中对参数进行求和，fn 方法体中对数组 args 进行添加当前参数的操作：

    
    
    const add = arg1 => {
       let args = [arg1]
       const fn = arg2 => {
           args.push(arg2)
            return fn
        }
        fn.toString = function () {
            return args.reduce((prev, item) => prev + item, 0)
        }
        return fn
    }
    

注意这里只支持：

    
    
    add(1)(2)(3)
    

单个参数的调用，如果更加通用化，支持：

    
    
    add(1)(2, 3)(4)
    

需要我们改动为：

    
    
    const add = (...arg1) => {
       let args = [...arg1]
       const fn = (...arg2) => {
           args = [...args, ...arg2]
            return fn
        }
        fn.toString = function () {
            return args.reduce((prev, item) => prev + item, 0)
        }
        return fn
    }
    

实现：

    
    
    add(1)(2, 3)(4) == 10
    

还有一个细节，如果将 == 改为 ===，将会输出 false，这并不奇怪。因为 add 调用后的返回值类型始终为 Function，我们只是改写了其
toString 方法，利用了隐式转换规则而已。

#### 通用 curry 化

我们回到 filterLowerThan10 函数的案例中，从中感受到 curry 化的优势：

  * 提高复用性
  * 减少重复传递不必要的参数
  * 动态根据上下文创建函数

其中动态根据上下文创建函数，也是一种惰性求值的体现：

    
    
    const addEvent = (function() {
        if (window.addEventListener) {
            return function (type, element, handler, capture) {
                element.addEventListener(type, handler, capture)
            }
        }
        else if (window.attachEvent){
            return function (type, element, fn) {
                element.attachEvent('on' + type, fn)
            }
        }
    })()
    

这是一个典型兼容 IE9 浏览器事件 API 的例子，根据兼容性的嗅探，充分利用 curry 化思想，完成了需求。

那么我们如何编写一个通用化的 curry 函数呢？

    
    
    const curry = (fn, length) => {
        length = length || fn.length
        return function (...args) {
            if (args.length < length) {
                return curry(fn.bind(this, ...args), length - args.length)
            }
            else {
                return fn.call(this, ...args)
            }
        }
    }
    

这里我们利用 Function.length 获取函数预期需要的参数个数，并利用了 bind 方法绑定参数。

如果不想使用 bind，另一种常规思路是对每次调用时产生的参数进行存储：

    
    
    const curry = fn => {
        return tempFn = (...arg1) => {
            if (arg1.length >= fn.length) {
                return fn(...arg1)
            }
            else {
                return (...arg2) => tempFn(...arg1, ...arg2)
            }
        }
    }
    

简化为：

    
    
    const curry = fn =>
        judge = (...arg1) =>
            arg1.length >= fn.length
                ? fn(...arg1)
                : (...arg2) => judge(...arg1, ...arg2)
    

总之，实现原理就是：先用闭包把传入参数保存起来，当传入参数的数量足够执行函数时，就开始执行函数。抽象成步骤：

  * 先逐步接受参数，并进行存储，以供后续使用
  * 先不进行函数计算，延后执行
  * 在符合条件时，根据存储的参数，统一传给函数进行计算

#### 反 curry 化

反 curry 化与 curry 正好相反。反 curry 化在于扩大函数的适用性，使本来作为特定对象所拥有的功能函数可以被任意对象所使用。

说到“特定对象所拥有的功能函数可以被任意对象所使用”，有经验的读者可能会想到用于类型判断的
Object.prototype.toString.call(target)：

    
    
    const foo = () => ({})
    const bar = ''
    
    Object.prototype.toString.call(foo) === '[object Function]'
    // true
    
    Object.prototype.toString.call(bar) === '[object String]'
    // true
    

通过反 curry 化，我们将这个 Object 原型上的属性函数变得更加通用：

    
    
    const toString = Object.prototype.toString.unCurry
    

或者有一个 UI 组件 Toast：

    
    
    function Toast (options) {
        this.message = ''
    }
    
    Toast.prototype = {
        showMessage: function () {
            console.log(this.message)
        }
    }
    

这样的代码，使得 Toast 实例均可使用 showMessage 方法：

    
    
    new Toast({}).showMessage()
    

如果有一个变量对象：

    
    
    const obj = {
        message: 'uncurry test'
    }
    

如果想使用 Toast 原型上的 showMessage 方法：

    
    
    const unCurryShowMessaage = unCurry(Toast.prototype.showMessage)
    
    unCurryShowMessaage(obj)
    

就是使用反 curry 化的另一个场景了。

#### 反 curry 化实现

那么上述的 unCurry 方法应该如何实现呢？

我们来分析：unCurry 的参数是一个“希望被其他对象所调用的方法”，暂且称为 fn，unCurry
执行后返回一个新的函数，该函数的第一个参数是预期要执行方法的对象（obj），后面的参数是执行这个方法时需要传递的参数。

    
    
    function unCurry(fn) {
        return function () {
            var obj = [].shift.call(arguments)
            return fn.apply(obj, arguments)
        }
    }
    

改成 ES6 的写法：

    
    
    const unCurry = fn => (...args) => fn.call(...args)
    

以上是正常函数实现 uncurry 的实现。我们也可以将 uncurry 挂载在函数原型上：

    
    
    Function.prototype.unCurry = !Function.prototype.unCurry || function () {
        const self = this
        return function () {
            return Function.prototype.call.apply(self, arguments)
        }
    }
    

这里不太好理解的点在于：Function.prototype.call.apply(self,
arguments)，其实这个问题本课程的读者群里也有人问过，我们就一起来讨论下，拆开看就会非常清晰了。

  * 第一步：Function.prototype.call.apply(self, arguments) 可以看成 Fn.apply(self, arguments)，Fn 函数执行时，this 指向了 self。而根据代码，self 是调用 unCurry 的函数，执行结果就是 Fn(arguments)，只不过 this 被绑定在 self 上，用 callFn(arguments) 来表示。
  * 第二步：callFn(arguments) 解析，callFn 指的是：Function.prototype.call，call 方法第一个参数是用来指定 this 的，因此 callFn(arguments) 相当于 callFn(arguments[0], arguments[n - 1])。

因此，最终执行就相当于：callFn(arguments[0], arguments[n - 1])，也就是说反 curry
化后得到的函数，第一个参数是用来决定 this 指向的，也就是需要应用的目标对象，剩下的参数是函数执行所需要的参数。

当然，我们可以借助 bind 实现：

    
    
    Function.prototype.unCurry = function() {
      return this.call.bind(this)
    }
    

借助 bind，call/apply 实现过程相对抽象，读者可以根据示例尝试理解。这里允许我再赘述一下：

> call 中的 this 指的是调用它的函数，call 的内部实现中：第一个参数替换了这个函数中的
this，其余作为形参执行了函数。而我们的代码：Function.prototype.call.apply，使用 apply 之后，apply
的第一个参数更换了 call 中的 this。因此执行时，实际执行计算的的函数为 self。

这里再补充一个例子，供大家理解：

    
    
    const push = Array.prototype.push.unCurry()
    
    const test = { foo: 'lucas' }
    push(test, 'messi', 'ronaldo', 'neymar')
    console.log(test) 
    
    // {0: "messi", 1: "ronaldo", 2: "neymar", foo: "lucas", length: 3}
    

我们借助了数组的 push 方法，应用在对象上，test 对象多了类似数组的属性，键为数组索引。

### 偏函数（partial）

如果了解了 curry 化，那么偏函数（partial application）就很容易理解了。如果说 curry
化是将一个多参数函数转换成多个单参数函数，也就是 curry 化将 n 原函数转换 n 个一元函数，那么偏函数就是固定一个函数的一个或者多个参数，即将一个
n 元函数转换成一个 （n ﹣ k） 元函数：

curry 化：n = n * 1

partial：n = n/k * k

响应偏函数实现：

    
    
    const partial = (fn, ...rest) => (...args) => fn(...rest, ...args)   
    

使用 bind 版本实现：

    
    
    const partial = (fn, ...args) => fn.bind(null, ...args)
    

#### 函子（functor）

说到函子，大部分没有深入过函数式编程的读者可能有点陌生，而函子确实一个很重要的函数式编程思想。目前社区上介绍的并不算多，我们这里来进行一下了解。

我想先从链式调用说起，看以下代码：

    
    
    const addHelloPrefix = str => `Hello : ${str}`
    const addByeSuffix = str => `${str}, bye!`
    

addHelloPrefix 和 addByeSuffix 分别给所接收到的字符串添加固定的字符串前缀和后缀，我们可以这样使用：

    
    
    addByeSuffix(addHelloPrefix('lucas'))
    

得到返回结果："Hello : lucas, bye!"

如果我们想链式调用：

    
    
    'lucas'.addHelloPrefix().addByeSuffix()
    
    // VM176:1 Uncaught TypeError: "lucas".addHelloPrefix is not a function
    

得到报错信息，是因为字符串并不存在 addHelloPrefix 方法，因此调用失败。如果 'lucas'
这样的字符串是一个复杂类型，或者是一个类，也许问题就能解决：

    
    
    class Person {
        constructor(value) {
            this.value = value
        }
        addHelloPrefix() {
            return `Hello : ${this.value}`
        }
        addByeSuffix() {
            return `${this.value}, bye`
        }
    }
    

这样的 Person 声明并不足以完成链式调用，链式调用的关键是 addHelloPrefix 和 addByeSuffix
方法仍然返回该类实例，而不是字符串。我们改动如下：

    
    
    class Person {
        constructor(value) {
            this.value = value
        }
        addHelloPrefix() {
            return new Person(`Hello : ${this.value}`)
        }
        addByeSuffix() {
            return new Person(`${this.value}, bye`)
        }
    }
    

执行代码：

    
    
    new Person('lucas').addHelloPrefix().addByeSuffix()
    

输出：

    
    
    {value: "Hello : lucas, bye"}
    

这样一来，似乎举例目标更近了些。我们试图将上述操作变得完全通用，定义一个 Functor 类：

    
    
    class Functor {
        constructor(value) {
            this.value = value
        }
        static of(value) {
            return new Functor(value)
        }
        apply(fn) {
            return Functor.of(fn(this.value))
        }
    }
    

Functor 可以理解为函子雏形，我们看它做了什么：Functor 的 constructor 按照惯例接收数据；同时定义 Functor 一个静态方法
of，这个方法专门用来返回一个 Functor 实例对象；apply 方法接受一个 fn，使用 fn 对当前实例的 value 进行计算，得到新的
value 之后交给静态 of 方法，最终得到还有新 value 的实例。

这样一来，可以：

    
    
    Functor.of('lucas').apply(addHelloPrefix).apply(addByeSuffix)
    

仍然得到结果：

    
    
    {value: "Hello : lucas, bye!"}
    

我们总结一下：

  * Functor 可以理解为一个容器，这个容器中含有值 this.value.；
  * Functor 具有 apply 方法，该方法将容器里面的每一个值，应用到到另一个容器；
  * 上述所说的“应用到另一个容器”，是根据 of 方法，得到新的实例；
  * 所有运算，都是通过函子 Functor 来完成，这样一来，所有运算不直接针对值，而是针对这个值的容器 —— Functor；
  * 这样也保证了值的不可变性；
  * 函数式编程有个约定，函子 Functor 需要拥有一个 of 方法，用来生成新的容器。

#### Maybe 函子

在函字 Functor 的基础上，为了安全性，我们将函子里的空值过滤掉：

    
    
    class Maybe {
        constructor(value) {
            this.value = value
        }
        static of(value) {
            return new Maybe(value)
        }
        apply(fn) {
            return this.value ? Maybe.of(fn(this.value)) : new Maybe(null)
        }
    }
    

注意在 apply 方法中，对当前值 this.value 进行判断，如果非空，返回 Maybe.of(fn(this.value)) 调用，否则直接返回
Maybe(null)。

这就是简单的 Maybe 函子，为此我们总结一下：
**不同类型的函子，可以完成不同的功能。他们的共同点是：每个函子并没有直接去操作需要处理的数据（我们没有看到的 this.value 的直接写操作）而是通过
apply 接口应用 fn，并最终返回一个新的函子。**

### 总结

函数式编程博大精深，这一节课只是给大家介绍了 JavaScript 中结合函数式编程常用的概念，已经足够日常开发了。掌握这些概念的 JavaScript
实现是进阶所必需的要求。

此外读者还可以更多考虑函数式编程的性能负担以及框架类库函数式实现的话题，函数式结合 ES Next decorator 也可以玩出很多花样；Ramda.js
是一个典型的函数式类库，感兴趣的读者也可以深入研究。同时给大家推荐一本函数式编程的书《JS 函数式编程指南》，它特有免费的中文版：[mostly-
adequate-guide](https://llh911001.gitbooks.io/mostly-adequate-guide-
chinese/content/)。

总之，函数式的话题我们就到此结束，你可以研究得更深、更多，但理解本节课内容足够让读者有的放矢，在工程中合理使用。



## 那些年常考的前端算法（上）

在上一讲中，我们全面梳理了重要的数据结构，并用 JavaScript
对各种数据结构进行了实现和方法模拟。数据结构常与算法一起出现，两者相互依存密不可分。这一讲，我们来研究一下“那些年常考的前端算法”。

主要内容如下：

![enter image description
here](https://images.gitbook.cn/a80ed7e0-d827-11e9-a98d-91914e1a8fb9)

我们将通过三讲的内容来剖析算法问题。本讲先“轻松”一下，主要介绍前端和算法的关系，以及算法中的一些基本概念。

### 前端和算法

前端和算法有什么关系呢？我想先纠正两个常见的错误认知。

#### 关于算法的误解

  * 前端没有算法？

“前端没有算法”这种说法往往出自算法岗甚至后端读者，这种认知是错误的。前端不仅有算法，而且算法在前端开发中占据的地位也越来越重要。我们常提到的
Virtual dom diff、webpack 实现、React fiber、React
hooks、响应式编程、浏览器引擎工作方式等都有算法的影子。在业务代码中，哪怕写一个抽奖游戏，写一个混淆函数都离不开算法。

  * 算法重要不重要？

有读者认为，前端中算法只是提供了一些偏底层的能力和实现支持，我在业务开发中真正使用到算法的场景也很有限。事实上，不仅单纯的前端业务，哪怕对于后端业务来说，真正让你“徒手”实现一段算法的场景也不算多。但是据此得出算法不重要的说法还是太片面了。为什么高阶面试中总会问到算法呢？因为算法很好地反应了候选者编程思维和计算机素养；另一方面，如果我们想进阶，算法也是必须要攻克的一道难关。

#### 前端和算法简单举例

我就先举一个例子作为引子，一起先热热身，看看算法应用在前端开发中的一个小细节。

想必不少读者写过“抽奖”代码，或者“老虎机”转盘。其中可能会涉及到一个问题，就是：

> “如何将一个 JavaScript 数组打乱顺序？”

事实上乱序一个数组不仅仅是前端课题，那么这个问题在前端的背景下，有哪些特点呢？可能有读者首先想到使用数组的 sort API，再结合 Math.random
实现：

    
    
    [12,4,16,3].sort(function() {
        return .5 - Math.random();
    })
    

这样的思路非常自然，但也许你不知道：这不是真正意义上的完全乱序。

为此我们进行验证，对数组

    
    
    let letters = ['A','B','C','D','E','F','G','H','I','J']
    

使用 array.sort 方法进行了 10000 次乱序处理，并对乱序之后得到的新数组中，每一个字母出现的位置进行统计，并可视化输出：

    
    
    <body>
            <table id="results">
                <tr>
                    <th style="background-color:#ccccff">Results</th>
                    <th>slot 0</th>
                    <th>slot 1</th>
                    <th>slot 2</th>
                    <th>slot 3</th>
                    <th>slot 4</th>
                    <th>slot 5</th>
                    <th>slot 6</th>
                    <th>slot 7</th>
                    <th>slot 8</th>
                    <th>slot 9</th>
                </tr>
                <tr>
                    <th>A's</th><td class="strongbias">0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>
                </tr>
                <tr>
                    <th>B's</th><td>0</td><td class="strongbias">0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>
                </tr>
                <tr>
                    <th>C's</th><td>0</td><td>0</td><td class="bias">0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>
                </tr>
                <tr>
                    <th>D's</th><td>0</td><td>0</td><td>0</td><td class="bias">0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>
                </tr>
                <tr>
                    <th>E's</th><td>0</td><td>0</td><td>0</td><td>0</td><td class="bias">0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>
                </tr>
                <tr>
                    <th>F's</th><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td class="bias">0</td><td>0</td><td>0</td><td>0</td><td>0</td>
                </tr>
                <tr>
                    <th>G's</th><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td class="bias">0</td><td>0</td><td>0</td><td>0</td>
                </tr>
                <tr>
                    <th>H's</th><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td class="bias">0</td><td>0</td><td>0</td>
                </tr>
                <tr>
                    <th>I's</th><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td class="strongbias">0</td><td>0</td>
                </tr>
                <tr>
                    <th>J's</th><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td class="strongbias">0</td>
                </tr>
            </table>
            <div>
                <input type="button" value="recalculate" onclick="recalc()">
            </div>
        </body>
        <script>
            const recalc = () => {
                const countings = [
                    {A:0,B:0,C:0,D:0,E:0,F:0,G:0,H:0,I:0,J:0},
                    {A:0,B:0,C:0,D:0,E:0,F:0,G:0,H:0,I:0,J:0},
                    {A:0,B:0,C:0,D:0,E:0,F:0,G:0,H:0,I:0,J:0},
                    {A:0,B:0,C:0,D:0,E:0,F:0,G:0,H:0,I:0,J:0},
                    {A:0,B:0,C:0,D:0,E:0,F:0,G:0,H:0,I:0,J:0},
                    {A:0,B:0,C:0,D:0,E:0,F:0,G:0,H:0,I:0,J:0},
                    {A:0,B:0,C:0,D:0,E:0,F:0,G:0,H:0,I:0,J:0},
                    {A:0,B:0,C:0,D:0,E:0,F:0,G:0,H:0,I:0,J:0},
                    {A:0,B:0,C:0,D:0,E:0,F:0,G:0,H:0,I:0,J:0},
                    {A:0,B:0,C:0,D:0,E:0,F:0,G:0,H:0,I:0,J:0}
                ]
                let letters=['A','B','C','D','E','F','G','H','I','J'];
                for (let i = 0; i < 10000; i++) {
                    var r = ['A','B','C','D','E','F','G','H','I','J'].sort(function() {
                        return .5 - Math.random()
                    })
                    for(var j = 0; j <= 9; j++) {
                        countings[j][r[j]]++
                    }
                }
                for(var i = 0; i <= 9;i++) {
                    for(var j = 0;j <= 9;j++) {
                        document.getElementById('results').rows[i + 1].cells[j + 1].firstChild.data = countings[i][letters[j]]
                    }
                }
            }
            recalc()
        </script>
    

得到结果：

![1](https://images.gitbook.cn/75e69d10-d828-11e9-8fae-816b29059b0c)

不管点击按钮几次，你都会发现整体乱序之后的结果绝对不是“完全随机”。

比如，A 元素大概率出现在数组的头部，J 元素大概率出现在数组的尾部，所有元素大概率停留在自己初始位置。

这是为什么呢？

究其原因，在 Chrome v8 引擎源码中，可以清晰看到：

> v8 在处理 sort 方法时，使用了插入排序和快排两种方案。当目标数组长度小于 10（不同版本有差别）时，使用插入排序；反之，使用快排。

其实不管用什么排序方法，大多数排序算法的时间复杂度介于 O(n) 到 O(n2) 之间，元素之间的比较次数通常情况下要远小于
n(n-1)/2，也就意味着有一些元素之间根本就没机会相比较（也就没有了随机交换的可能），这些 sort 随机排序的算法自然也不能真正随机。

通俗地说，其实我们使用 array.sort 进行乱序，理想的方案或者说纯乱序的方案是：数组中每两个元素都要进行比较，这个比较有 50%
的交换位置概率。如此一来，总共比较次数一定为 n(n-1)。

而在 sort 排序算法中，大多数情况都不会满足这样的条件，因此当然不是完全随机的结果了。

那为了满足乱序一个数组的需求，我们应该怎么做呢？

Fisher–Yates shuffle
洗牌算法——会是一个更好的选择。这里，我们简单借助图形来理解，非常简单直观。接下来就会明白为什么这是理论上的完全乱序（图片来源于网络）。

首先我们有一个已经排好序的数组：

![2](https://images.gitbook.cn/d8ed90d0-d828-11e9-8797-4924c0d7c082)

**Step1** ：

这一步需要做的就是，从数组末尾开始，选取最后一个元素。

![3](https://images.gitbook.cn/fd022b20-d828-11e9-9143-0bdf45914741)

在数组一共 9 个位置中，随机产生一个位置，该位置元素与最后一个元素进行交换。

![4](https://images.gitbook.cn/68a6a040-d829-11e9-a98d-91914e1a8fb9)

![5](https://images.gitbook.cn/80791b30-d829-11e9-a98d-91914e1a8fb9)

![6](https://images.gitbook.cn/9dc03930-d829-11e9-9143-0bdf45914741)

**Step2：**

在上一步中，我们已经把数组末尾元素进行随机置换。

接下来，对数组倒数第二个元素动手。在除去已经排好的最后一个元素位置以外的 8 个位置中，随机产生一个位置，该位置元素与倒数第二个元素进行交换。

![7](https://images.gitbook.cn/f0037d10-d829-11e9-8797-4924c0d7c082)

![8](https://images.gitbook.cn/0aa48150-d82a-11e9-9143-0bdf45914741)

![9](https://images.gitbook.cn/252b1fc0-d82a-11e9-8797-4924c0d7c082)

**Step3：**

理解了前两步，接下来就是依次进行，如此简单。

![10](https://images.gitbook.cn/7cd8cd80-d82a-11e9-8fae-816b29059b0c)

明白了原理，代码实现也很简单：

    
    
    Array.prototype.shuffle = function() {
        var array = this;
        var m = array.length,
            t, i;
        while (m) {
            i = Math.floor(Math.random() * m--);
            t = array[m];
            array[m] = array[i];
            array[i] = t;
        }
        return array;
    }
    

### 算法的基本概念

在具体讲解各种算法前，我们有必要先掌握基本概念。搞定算法，需要读者优先了解数据结构以及各种结构的相关方法，这些内容上一讲中已经进行了梳理。另外一个重要概念就是算法复杂度了，它是评估一个算法优秀程度的重要考证。我们常说的时间复杂度和空间复杂度该如何理解呢？

#### 时间复杂度

我们先看一下时间复杂度的概念：

> 一个算法的时间复杂度反映了程序运行从开始到结束所需要的时间。把算法中基本操作重复执行的次数（频度）作为算法的时间复杂度。

但是时间复杂度的计算既可以“有理可依”，又可以靠“主观感觉”。通常我们认为：

  * 没有循环语句，时间复杂度记作 O(1)，我们称为常数阶；
  * 只有一重循环，那么算法的基本操作的执行频度与问题规模 n 呈线性增大关系，记作 O（n），也叫线性阶。

那么如何让时间复杂度的计算“有理可依”呢？来看几个原则：

  * 只看循环次数最多的代码
  * 加法法则：总复杂度等于量级最大的那段代码的复杂度
  * 乘法法则：嵌套代码的复杂度等于嵌套内外复杂度的乘积

我们来逐一分析：

    
    
    const cal = n => { 
       let sum = 0
       let i = 1
       for (; i <= n; ++i) {
         sum = sum + i
       }
       return sum
     }
    

执行次数最多的是 for 循环及里面的代码，执行了 n 次，应该“只看循环次数最多的代码”原则，因此时间复杂度为 O(n)。

    
    
    const cal = n => {
       let sum1 = 0
       let p = 1
    
       for (; p < 100; ++p) {
         sum1= sum1 + p
       }
    
       let sum2 = 0
       let q = 1
       for (; q < n; ++q) {
         sum2 = sum2 + q
       }
    
       let sum3 = 0
       let i = 1
       let j = 1
       for (; i <= n; ++i) {
         j = 1
         for (; j <= n; ++j) {
           sum3 = sum3 +  i * j
         }
       }
    
       return sum1 + sum2 + sum3
     }
    

上述代码分别对 sum1、sum2、sum3 求和：

  * 对于 sum1 求和，循环 100 次，常数执行时间，时间复杂度为 O(1)；
  * 对于 sum2 求和，循环规模为 n，时间复杂度为 O(n)；
  * 对于 sum3 求和，两层循环，时间复杂度为 O(n²)。

因此 O(1) + O(n) + O(n²)，取三段代码的最大量级，上面例子最终的时间复杂度为 O(n²)。

对于代码：

    
    
    const cal = n => {
       let ret = 0
       let i = 1
       for (; i < n; ++i) {
         ret = ret + f(i); // 注意  f(i)
       } 
     } 
    
    const f = n => {
      let sum = 0
      let i = 1
      for (; i < n; ++i) {
        sum = sum + i
      } 
      return sum
     }
    

方法 cal 循环里面调用 f 方法，而 f 方法里面也有循环，这时应用第三个原则——乘法原则，得到时间复杂度 O(n²)。

最后我们再看一个对数阶的概念：

    
    
    const aFun = n => {
      let i = 1;
      while (i <= n)  {
         i = i * 2
      }
      return i
    }
    
    const cal = n => { 
       let sum = 0
       for (let i = 1; i <= n; ++i) {
         sum = sum + aFun(n)
       }
       return sum
     }
    

这里的不同之处是 aFun 每次循环，i = i * 2，那么自然不再是全遍历。想想高中学过的等比数列：

    
    
    2^0 * 2^1 * 2^2 * 2^k * 2^x = n
    

因此，我们只要知道 x 值是多少，就知道这行代码执行的次数了，通过 2x = n 求解 x，数学中求解得 x = log2n 。即上面代码的时间复杂度为
O(log2n)。

但是不知道读者有没有发现：不管是以 2 为底，还是以 K 为底，我们似乎都把所有对数阶的时间复杂度都记为 O(logn)。这又是为什么呢？

事实上，基本的数学概念告诉我们：对数之间是可以互相转换的，log3n = log32 * log2n，因此 O(log3n) = O(C *
log2n)，其中 C=log32 是一个常量。所以全部以 2 为底，并没有什么问题。

总之，需要读者准确理解：由于 **时间复杂度** 描述的是 **算法执行时间与数据规模的增长变化趋势**
，因而常量、低阶、系数实际上对这种增长趋势不产生决定性影响，所以在做时间复杂度分析时忽略这些项。

#### 最好、最坏时间复杂度，平均时间复杂度，均摊时间复杂度

我们来看一段代码：

    
    
    const find = (array, x) => {
        let pos = -1
        let len = array.length
        for (let i = 0 ; i < n; ++i) {
            if (array[i] === x) {
                pos = i
            }
        }
        return pos
    }
    

上面的代码有一层循环，循环规模和 n 成线性关系。因此时间复杂度为 O(n)，我们改动代码为：

    
    
    const find = (array, x) => {
        let pos = -1
        let len = array.length
        for (let i = 0 ; i < n; ++i) {
            if (array[i] === x) {
                pos = i
            }
        }
        return pos
    }
    

在找到第一个匹配元素后，循环终止，那么时间复杂度就不一定是 O(n) 了，因此就有了最好时间复杂度、最坏时间复杂度的区别。针对上述代码最好时间复杂度就是
O(1)、最坏时间复杂度还是 O(n)。

最好时间复杂度、最坏时间复杂度其实都是极端情况，我们可以从统计学角度给出一个平均时间复杂度。在上述代码中，平均时间复杂度的计算方式应该是：

    
    
    (1/(n+1)) * 1 + (1/(n+1)) * 2 + ... + (1/(n+1)) * n + (1/(n+1)) * n
    

得到结果为：n(n+3)/2(n+1)

因为变量 x 出现在数组中的位置分别有 0 —— n－1 种情况，对应需要遍历的次数；除此之外，还有变量 x 不出现在数组中，这种情况仍然后遍历完数组。

上述结果简化之后仍然得到 O(n)。

我们再来看一段代码：

    
    
    let array = new Array(n)
    let count = 0
    function insert(val) {
        let len = array.length
        if (count === len) {
            let sum = 0
            for (let i = 0; i < len; i++) {
                sum = sum + array[i]
            }
            array[0] = sum
            count = 1
        }
        array[count] = val
        ++count
    }
    

这段代码逻辑很简单：我们实现了一个往数组中插入数据的功能。但是多了些判断：当数组满了之后，即 count === len 时，采用 for
循环对数组进行求和，求和完毕之后：先清空数组，然后将求和之后的结果放到数组的第一个位置，最后再将新的数据插入。

这是一段非常典型的代码，我们来看它的时间复杂度：

  * 最好时间复杂度

数组中有空闲，count !== len，直接执行插入操作，复杂度为 O(1)。

  * 最好时间复杂度

数组已满，count === len，需要先遍历一遍再求和，复杂度为 O(n)。

  * 平均时间复杂度

假设数组长度为 n，数组空闲时，复杂度为 O(1)；数组已满，复杂度为 O(n)。采用平均加权方式：

    
    
    (1/(n+1)) * 1 + (1/(n+1)) * 1 + ... + (1/(n+1)) * n
    

公式求和仍为 O(1)，主观上想：我们的操作是在进行了 n 个 O(1) 的插入操作后，此时数组满了，执行一次 O(n)
的求和和清空操作。这样一来，其实前面的 n 个O (1) 和最后的 1 个 O(n) 其实是可以抵消掉的，这是一种均摊时间复杂度的概念。

这种均摊的概念是有实际应用场景的。例如，C++ 里的 vector 动态数组的自动扩容机制，每次往 vector 里 push 值的时候会判断当前 size
是否等于 capacity，一旦元素超过容器限制，则再申请扩大一倍的内存空间，把原来 vector 里的值复制到新的空间里，触发扩容的这次 push
操作的时间复杂度是 O(n)，但均摊到前面 n 个元素后，可以认为时间复杂度是 O(1) 常数。

最后总结一下，常见时间复杂度：

  * O(1)：基本运算 +、-、*、/、%、寻址
  * O(logn)：二分查找，跟分治（Divide & Conquer）相关的基本上都是 logn
  * O(n)：线性查找
  * O(nlogn)：归并排序，快速排序的期望复杂度，基于比较排序的算法下界
  * O(n²)：冒泡排序，插入排序，朴素最近点对
  * O(n³)：Floyd 最短路，普通矩阵乘法
  * O(2ⁿ)：枚举全部子集
  * O(n!)：枚举全排列

O(logn) 近似于是常数的时间复杂度，当 n 为 $2^{32}$ 的规模时 logn 也只是 32 而已；
对于顺序执行的语句或者算法，总的时间复杂度等于其中最大的时间复杂度。例如，O(n²) + O(n) 可直接记做 O(n²)。

#### 空间复杂度

空间复杂度表示算法的存储空间与数据规模之间的增长关系。常见的空间复杂度：O(1)、O(n)、O(n²)，像 O(logn)、O(nlogn)
这样的对数阶复杂度平时都用不到。有的题目在空间上要求 in-place（原地），是指使用 O(1) 空间，在输入的空间上进行原地操作，比如字符串反转。但
in-place 又不完全等同于常数的空间复杂度，比如数组的快排认为是 in-place 交换，但其递归产生的堆栈的空间是可以不考虑的，因此 in-
place 相对 O(1) 空间的要求会更宽松一点。

对于时间复杂度和空间复杂度，开发者应该有所取舍。在设计算法时，可以考虑“牺牲空间复杂度，换取时间复杂度的优化”，反之依然。空间复杂度我们不再过多介绍。

### 总结

本讲我们介绍了算法的基本概念，重点就是时间复杂度和空间复杂度分析，同时剖出了一个“乱序数组”算法进行热身。算法的大门才刚刚打开，请读者继续保持学习。



## 那些年常考的前端算法（中）

上一讲我们剖析了算法的一些基本概念。这一讲将围绕 v8 引申出的算法进行分析，同时做一些常见、典型考题。主要内容如下：

![enter image description
here](https://images.gitbook.cn/a80ed7e0-d827-11e9-a98d-91914e1a8fb9)

### v8 sort 排序的奥秘和演进

前一讲，我带大家分析了“如何将一个 JavaScript 数组打乱顺序？”，其中提到了 sort 这个 API，具体有这样的一段描述：

> v8 在处理 sort 方法时，使用了插入排序和快排两种方案。当目标数组长度小于 10（不同版本有差别）时，使用插入排序；反之，使用快排。

如果细心的读者可能会到 v8 源代码中找寻相关的算法逻辑，那么你一定会大失所望。因为根本找不到 10
这样的常量，更没有插入排序和快排两种方案的切换，甚至连实现的预言都不是 JavaScript 或者 C++，这是为什么呢？

原来，在新的 v8 版本中（具体 V8 6.9）已经使用了一种名叫 Torque 的开发语言重构，并在 7.0 改进了 sort
算法。也就是说，现在社区上几乎所有的 V8 排序源码分析都已经过时了。

Torque 是 v8 团队专门为了开发 v8 引擎而开发的语言，他的后缀名是 tq。作为一种高级语言，Torque 依靠
CodeStubAssembler 编译器来转换为汇编代码。

在新的版本中，v8 也采用了一种名叫 Timsort 的全新算法，这套算法最开始于 2002 被 Tim Peters 在 Python 语言中使用。

从这个演进过程中，我们分为三大块来看。

### 快排和插入排序

排序算法多种多样，社区上的分析也比较多。这里我们挑选 v8 sort 排序中“露脸”的快速排序和插入排序进行讲解。

不知道读者是否有这样的困扰：我们看一遍算法，理解了，可是过两天又完全记不得具体讲了什么。针对于此，我们应该结合算法的特点，加以应用，才能深入记忆。排序算法同样如此，对于每一种算法，我们应该先记住其思想，再记住其实现。不过要知道：“排序没有想象中那么简单”。

#### 快速排序

**快速排序的特点就是分治** 。如何体现分治策略呢？我们首先在数组中选取一个基准点，叫做
pivot，根据这个基准点：把比基准点小的数组值放在基准点左边，把比基准点大的数组值放在基准点右边。这样一来，基于基准点，左边分区的值都小于基准点，右边分区的值都大于基准点，然后针对左边分区和右边分区进行同样的操作，直到最后排序完成。

最简单的实现：

    
    
    const quickSort = array => {
      if (array.length < 2) {
        return array.slice()
      }
    
      // 随机找到 pivot
      let pivot = array[Math.floor(Math.random() * array.length)]
    
      let left = []
      let middle = []
      let right = []
    
      for (let i = 0; i < array.length; i++) {
        var value = array[i]
        if (value < pivot) {
          left.push(value)
        }
    
        if (value === pivot) {
          middle.push(value)
        }
    
        if (value > pivot) {
          right.push(value)
        }
      }
    
      // 递归进行
      return quickSort(left).concat(middle, quickSort(right))
    }
    

这种实现方法有不少优化点，其中之一就是我们可以在原数组上进行操作，而不产生一个新的数组：

    
    
    const quickSort = (array, start, end) => {
      start = start === undefined ? 0 : start
      end = end === undefined ? arr.length - 1 : end;
    
      if (start >= end) {
        return
      }
    
      let value = array[start]
    
      let i = start
      let j = end
    
      while (i < j) {
        // 找出右边第一个小于参照数的下标并记录
        while (i < j && array[j] >= value) {
          j--
        }
    
        if (i < j) {
          arr[i++] = arr[j]
        }
    
        // 找出左边第一个大于参照数的下标，并记录
        while (i < j && array[i] < value) {
          i++
        }
    
        if (i < j) {
          arr[j--] = arr[i]
        }
      }
    
      arr[i] = value
    
      quickSort(array, start, i - 1)
      quickSort(array, i + 1, end)
    }
    

调用方式：

    
    
    let arr = [0, 12, 43, 45, 88, 1, 69]
    quickSort(arr, 0, arr.length - 1)
    console.log(arr)
    

我们该如何理解 in place 的快排算法呢？

首先使用双指针，指针开始遍历，当右边发现一个小于参照数（即
array[start]）的时候，就将该值赋值给起始位置。赋值完之后，那么右边这个位置就空闲了。这时在左边发现比参照数大的值时，就赋值给这个刚刚空闲出来的右边位置。以此类推，直到
i 不再小于 j。经过这一轮操作之后，所有比参照数小的都到了数组的左边，所有比参照数大的都到了数组右边，而数组中间被赋值为参照数。

我们再来分析另外一个优化点。之前的课程中提到了尾递归调用优化，那么上面的快排能否使用尾递归进行优化呢？

我们进行观察，上面的实现最后两行：

    
    
    quickSort(array, start, i - 1)
    quickSort(array, i + 1, end)
    

如果能形成以下的形式：

    
    
    return quickSort()
    

那么就实现了尾递归调用优化。为此，我们需要一个 stack 来进行参数信息的传递：

    
    
     const quickSort = (array, stack) => {
      let start = stack[0]
      let end = stack[1]
    
      let value = array[start]
    
      let i = start
      let j = end
    
      while (i < j) {
        while (i < j && array[j] >= value) {
          j--
        }
        if (i < j) {
          array[i++] = array[j]
        }
    
        while (i < j && array[i] < value) {
          i++
        }
    
        if (i < j) {
          array[j--] = array[i]
        }
      }
    
      arr[i] = value
    
      // 移除已经使用完的下标
      stack.shift()
      stack.shift() 
    
      // 存入新的下标
      if (i + 1 < end) {
        stack.unshift(i + 1, end)
      }
      if (start < i - 1) {
        stack.unshift(start, i - 1)
      }
    
      if (stack.length == 0) {
        return;
      }
    
      return quickSort(array, stack)
    }
    

最后，关于快速排序的优化点还有一个最重要的方向就是对 pivot 元素的选取。通过上面的分析，我们发现快速排序的算法核心在于选择一个
pivot，将经过比较交换的数组按基准分解为两个数区进行后续递归。

那么试想，如果我们对一个已经有序的数组进行排序，恰好每次选择 pivot 时总是选择第一个或者最后一个元素，那么每次都会有一个数区是空的，递归的层数将达到
n，最后导致算法的时间复杂度退化为 O(n²)。因此 pivot 的选择非常重要。

在早期 v8 使用快速排序时，采用了三数取中（median-of-three）的 pivot
优化方案：除了头尾两个元素再额外选择一个元素参与基准元素的竞争。具体 v8 源代码为：

    
    
    var GetThirdIndex = function(a, from, to) {
        var t_array = new InternalArray();
        // Use both 'from' and 'to' to determine the pivot candidates.
        var increment = 200 + ((to - from) & 15);
        var j = 0;
        from += 1;
        to -= 1;
        for (var i = from; i < to; i += increment) {
            t_array[j] = [i, a[i]];
            j++;
        }
        t_array.sort(function(a, b) {
            return comparefn(a[1], b[1]);
        });
        var third_index = t_array[t_array.length >> 1][0];
        return third_index;
    };
    
    var QuickSort = function QuickSort(a, from, to) {
        ......
        while (true) {
            ......
            if (to - from > 1000) {
                third_index = GetThirdIndex(a, from, to);
            } else {
                third_index = from + ((to - from) >> 1);
            }
        }
        ......
    };
    

由此看出，这所谓的第三个竞争元素产生方式为：

  * 当数组长度小于等于 1000 时，选择折半位置的元素作为目标元素
  * 当数组长度超过 1000 时，每隔 200-215 个（非固定，跟着数组长度而变化）左右的值，去选择一个元素来先确定一批候选元素。接着在这批候选元素中进行一次排序，将所得的中位值作为目标元素

三数取中（median-of-three）当中，最后选取的是三个元素的中位值作为 pivot。

#### 插入排序

插入排序我们还是从特点入手：它先将待排序序列的第一个元素看做一个有序序列，当然了，就一个元素，那么它一定是有序的；而把第二个元素到最后一个元素当成是未排序序列；对于未排序的序列进行遍历，将扫描到的每个元素插入有序序列的适当位置，保证有序序列依然有序，那么直到所有数据都完成，我们也就完成了排序。

如果待插入的元素与有序序列中的某个元素相等，那么我们统一先将待插入元素插入到相等元素的后面。

我们的实现：

    
    
    const insertsSort = array => {
        const length = arr.length
        let preIndex
        let current
    
        for (let i = 1; i < length; i++) {
            preIndex = i - 1
            current = array[i]
    
            while (preIndex >= 0 && array[preIndex] > current) {
                array[preIndex + 1] = array[preIndex]
                preIndex--
            }
    
            array[preIndex + 1] = current
        }
        return array
    }
    

那么上述实现的插入排序有优化空间吗？

这是一定的，优化空间主要有这么几个方向：

  * 在遍历未排序序列时，将当前元素插入到有序序列过程中，可以使用二分法减少查找次数（因为是向有序序列插入）
  * 使用链表，将有序数组转为链表这种数据结构，那么插入操作的时间复杂度为 O(1)，查找复杂度变为 O(n)
  * 使用排序二叉树，将有序数组转为排序二叉树结构，然后中序遍历该二叉树，不过这种方式需要额外空间。

采用二分法的优化实现：

    
    
    const insertSort = array => array.reduce(insert, [])
    
    const insert = (sortedArray, value) => {
      const length = sortedArray.length
    
      if (length === 0) {
        sortedArray.push(value)
        return sortedArray
      }
    
      let i = 0
      let j = length
      let mid
    
      // 先判断是否为极端值
      if (value < sortedArray[i]) {
        // 直接插入到数组的最头
        return sortedArray.unshift(value), sortedArray
      }
      if (value >= sortedArray[length - 1]) {
           // 直接插入到数组的最尾
        return sortedArray.push(value), sortedArray
      }
    
      // 开始二分查找
      while (i < j) {
        mid = ((j + i) / 2) | 0
    
        if (i == mid) {
          break
        }
    
        if (value  < sortedArray[mid]) {
          j = mid
        }
    
        if (value === sortedArray[mid]) {
          i = mid
          break
        }
    
        if (value > sortedArray[mid]) {
          i = mid
        }
      }
    
      let midArray = [value]
      let lastArray = sortedArray.slice(i + 1)
    
      sortedArray = sortedArray
        .slice(0, i + 1)
        .concat(midArray)
        .concat(lastArray)
    
      return sortedArray
    }
    

到此我们介绍完了两种排序方法。事实上，光排序就是一门很深的学问，也涉及到了算法和数据结构的方方面面，我们将继续通过排序，了解更多算法内容。

### 排序的稳定性

事实上，除了 v8 引擎，其他引擎也有不同的 sort 排序规则。比如 SpiderMoney 早期内部实现了归并排序，Chakra
的数组排序算法实现的也是快速排序。Firefox（Firebird）最初版本实现的数组排序算法是堆排序，这也是一种不稳定的排序算法，Mozilla
开发组内部针对这个问题进行了一系列讨论之后，Firefox3 将归并排序作为了数组排序的新实现。

我们知道，快速排序是一种不稳定的排序算法，而归并排序是一种稳定的排序算法。什么是排序的稳定性呢？

> 简单说，就是能保证排序前 2 个相等的数其在序列的前后位置顺序和排序后它们两个的前后位置顺序相同。形式化一下，如果 array[i] =
array[j]，array[i] 原来在位置前，排序后 array[i] 还是要在 array[j] 位置前。

在很多情况下，不稳定的排序也不会造成影响。但是在一些场景中，可能就会“有毒”。比如对于一个数组对象，场景是：

> 某市的机动车牌照拍卖系统，最终中标的规则为：按价格进行倒排序；相同价格则按照竞标顺位（即价格提交时间）进行正排序。

如果采用不稳定排序，那么结果就有可能不符合预期。

那么如果一些浏览器引擎实现的排序采用了不稳定排序算法应该怎么办呢？方案：

> 将待排序数组进行预处理，为每个待排序的对象增加自然序属性，不与对象的其他属性冲突即可。自定义排序比较方法
compareFn，总是将自然序作为前置判断相等时的第二判断维度。

示例代码：

    
    
    const HELPER = Symbol('helper')
    
    const getComparer = compare => 
       (left, right) => {
            let result = compare(left, right)
    
            return result === 0 ? left[HELPER] - right[HELPER] : result
        }
    
    const sort = (array, compare) => {
        array = array.map(
            (item, index) => {
                if (typeof item === 'object') {
                    item[HELPER] = index
                }
    
                return item
            }
        );
    
        return array.sort(getComparer(compare))
    }
    

近些年来，随着浏览器计算能力的进一步提升，项目正在往富客户端应用方向转变，前端在项目中扮演的角色也越来越重要。算法意识是一个不得忽视的话题。

### Timsort 实现

好了，我们再把话题收回来。那么 v8 采用的 Timsort 算法到底是什么呢？Timsort 结合了归并排序和插入排序，效率更高。Pyhton 自从
2.3 版，Java SE7 和 Android以来也一直采用 Timsort 算法排序。

我们看一下 JSE7 中对 Timsort 的描述：

> A stable, adaptive, iterative mergesort that requires far fewer than n lg(n)
comparisons when running on partially sorted arrays, while offering
performance comparable to a traditional mergesort when run on random arrays.
Like all proper mergesorts, this sort is stable and runs O(n log n) time
(worst case). In the worst case, this sort requires temporary storage space
for n/2 object references; in the best case, it requires only a small constant
amount of space.

Timsort 是稳定且自适应的算法。如果需要排序的数组中存在部分已经排序好的区间，它的时间复杂度会小于 nlogn，它的最坏时间复杂度是
O(nlogn）。在最坏情况下，Timsort 算法需要的临时空间是 n/2，在最好情况下，它只需要一个很小的常量存储空间。

Timsort 算法为了减少对升序部分的回溯和对降序部分的性能倒退，将输入按其升序和降序特点进行了分区。

那么具体的过程：排序输入的单位不是一个个单独的数字，而是一个个分区。其中每一个分区叫一个 run。针对这些 run 序列，每次拿一个 run
出来按规则进行合并。每次合并会将两个 run 合并成一个 run。合并的结果保存到栈中。合并直到消耗掉所有的 run，这时将栈上剩余的 run
合并到只剩一个 run 为止。这时这个仅剩的 run 便是排好序的结果。

这样一来 Timsort 的具体实施规则就是：

  * 如果数组长度小于某个值，直接用二分插入排序算法
  * 找到各个 run，并入栈
  * 按规则合并 run

理解 run 将会是关键，请看图：

![1](https://images.gitbook.cn/1eec6920-db4f-11e9-a268-91dece478f6a)

具体实现我参考部分 [timsort](https://github.com/bellbind/stepbystep-timsort) 内容：

    
    
    Array.prototype.timsort = function(comp) {
        var global_a = this
        var MIN_MERGE = 32;
        var MIN_GALLOP = 7
        var runBase = [];
        var runLen = [];
        var stackSize = 0;
        var compare = comp;
        sort(this, 0, this.length, compare);
    
        function sort(a, lo, hi, compare) {
            if (typeof compare != "function") {
                throw new Error("Compare is not a function.");
                return
            }
            stackSize = 0;
            runBase = [];
            runLen = [];
            rangeCheck(a.length, lo, hi);
            var nRemaining = hi - lo;
            if (nRemaining < 2) return;
            if (nRemaining < MIN_MERGE) {
                var initRunLen = countRunAndMakeAscending(a, lo, hi, compare);
                binarySort(a, lo, hi, lo + initRunLen, compare);
                return
            }
            var ts = [];
            var minRun = minRunLength(nRemaining);
            do {
                var runLenVar = countRunAndMakeAscending(a, lo, hi, compare);
                if (runLenVar < minRun) {
                    var force = nRemaining <= minRun ? nRemaining : minRun;
                    binarySort(a, lo, lo + force, lo + runLenVar, compare);
                    runLenVar = force
                }
                pushRun(lo, runLenVar);
                mergeCollapse();
                lo += runLenVar;
                nRemaining -= runLenVar
            } while (nRemaining != 0);
            mergeForceCollapse()
        }
    
        function binarySort(a, lo, hi, start, compare) {
            if (start == lo) start++;
            for (; start < hi; start++) {
                var pivot = a[start];
                var left = lo;
                var right = start;
                while (left < right) {
                    var mid = (left + right) >>> 1;
                    if (compare(pivot, a[mid]) < 0) right = mid;
                    else left = mid + 1
                }
                var n = start - left;
                switch (n) {
                    case 2:
                        a[left + 2] = a[left + 1];
                    case 1:
                        a[left + 1] = a[left];
                        break;
                    default:
                        arraycopy(a, left, a, left + 1, n)
                }
                a[left] = pivot
            }
        }
    
        function countRunAndMakeAscending(a, lo, hi, compare) {
            var runHi = lo + 1;
            if (compare(a[runHi++], a[lo]) < 0) {
                while (runHi < hi && compare(a[runHi], a[runHi - 1]) < 0) {
                    runHi++
                }
                reverseRange(a, lo, runHi)
            } else {
                while (runHi < hi && compare(a[runHi], a[runHi - 1]) >= 0) {
                    runHi++
                }
            }
            return runHi - lo
        }
    
        function reverseRange(a, lo, hi) {
            hi--;
            while (lo < hi) {
                var t = a[lo];
                a[lo++] = a[hi];
                a[hi--] = t
            }
        }
    
        function minRunLength(n) {
            var r = 0;
            return n + 1
        }
    
        function pushRun(runBaseArg, runLenArg) {
            runBase[stackSize] = runBaseArg;
            runLen[stackSize] = runLenArg;
            stackSize++
        }
    
        function mergeCollapse() {
            while (stackSize > 1) {
                var n = stackSize - 2;
                if (n > 0 && runLen[n - 1] <= runLen[n] + runLen[n + 1]) {
                    if (runLen[n - 1] < runLen[n + 1]) n--;
                    mergeAt(n)
                } else if (runLen[n] <= runLen[n + 1]) {
                    mergeAt(n)
                } else {
                    break
                }
            }
        }
    
        function mergeForceCollapse() {
            while (stackSize > 1) {
                var n = stackSize - 2;
                if (n > 0 && runLen[n - 1] < runLen[n + 1]) n--;
                mergeAt(n)
            }
        }
    
        function mergeAt(i) {
            var base1 = runBase[i];
            var len1 = runLen[i];
            var base2 = runBase[i + 1];
            var len2 = runLen[i + 1];
            runLen[i] = len1 + len2;
            if (i == stackSize - 3) {
                runBase[i + 1] = runBase[i + 2];
                runLen[i + 1] = runLen[i + 2]
            }
            stackSize--;
            var k = gallopRight(global_a[base2], global_a, base1, len1, 0, compare);
            base1 += k;
            len1 -= k;
            if (len1 == 0) return;
            len2 = gallopLeft(global_a[base1 + len1 - 1], global_a, base2, len2, len2 - 1, compare);
            if (len2 == 0) return;
            if (len1 <= len2) mergeLo(base1, len1, base2, len2);
            else mergeHi(base1, len1, base2, len2)
        }
    
        function gallopLeft(key, a, base, len, hint, compare) {
            var lastOfs = 0;
            var ofs = 1;
            if (compare(key, a[base + hint]) > 0) {
                var maxOfs = len - hint;
                while (ofs < maxOfs && compare(key, a[base + hint + ofs]) > 0) {
                    lastOfs = ofs;
                    ofs = (ofs << 1) + 1;
                    if (ofs <= 0) ofs = maxOfs
                }
                if (ofs > maxOfs) ofs = maxOfs;
                lastOfs += hint;
                ofs += hint
            } else {
                var maxOfs = hint + 1;
                while (ofs < maxOfs && compare(key, a[base + hint - ofs]) <= 0) {
                    lastOfs = ofs;
                    ofs = (ofs << 1) + 1;
                    if (ofs <= 0) ofs = maxOfs
                }
                if (ofs > maxOfs) ofs = maxOfs;
                var tmp = lastOfs;
                lastOfs = hint - ofs;
                ofs = hint - tmp
            }
            lastOfs++;
            while (lastOfs < ofs) {
                var m = lastOfs + ((ofs - lastOfs) >>> 1);
                if (compare(key, a[base + m]) > 0) lastOfs = m + 1;
                else ofs = m
            }
            return ofs
        }
    
        function gallopRight(key, a, base, len, hint, compare) {
            var ofs = 1;
            var lastOfs = 0;
            if (compare(key, a[base + hint]) < 0) {
                var maxOfs = hint + 1;
                while (ofs < maxOfs && compare(key, a[base + hint - ofs]) < 0) {
                    lastOfs = ofs;
                    ofs = (ofs << 1) + 1;
                    if (ofs <= 0) ofs = maxOfs
                }
                if (ofs > maxOfs) ofs = maxOfs;
                var tmp = lastOfs;
                lastOfs = hint - ofs;
                ofs = hint - tmp
            } else {
                var maxOfs = len - hint;
                while (ofs < maxOfs && compare(key, a[base + hint + ofs]) >= 0) {
                    lastOfs = ofs;
                    ofs = (ofs << 1) + 1;
                    if (ofs <= 0) ofs = maxOfs
                }
                if (ofs > maxOfs) ofs = maxOfs;
                lastOfs += hint;
                ofs += hint
            }
            lastOfs++;
            while (lastOfs < ofs) {
                var m = lastOfs + ((ofs - lastOfs) >>> 1);
                if (compare(key, a[base + m]) < 0) ofs = m;
                else lastOfs = m + 1
            }
            return ofs
        }
    
        function mergeLo(base1, len1, base2, len2) {
            var a = global_a;
            var tmp = a.slice(base1, base1 + len1);
            var cursor1 = 0;
            var cursor2 = base2;
            var dest = base1;
            a[dest++] = a[cursor2++];
            if (--len2 == 0) {
                arraycopy(tmp, cursor1, a, dest, len1);
                return
            }
            if (len1 == 1) {
                arraycopy(a, cursor2, a, dest, len2);
                a[dest + len2] = tmp[cursor1];
                return
            }
            var c = compare;
            var minGallop = MIN_GALLOP;
            outer: while (true) {
                var count1 = 0;
                var count2 = 0;
                do {
                    if (compare(a[cursor2], tmp[cursor1]) < 0) {
                        a[dest++] = a[cursor2++];
                        count2++;
                        count1 = 0;
                        if (--len2 == 0) break outer
                    } else {
                        a[dest++] = tmp[cursor1++];
                        count1++;
                        count2 = 0;
                        if (--len1 == 1) break outer
                    }
                } while ((count1 | count2) < minGallop);
                do {
                    count1 = gallopRight(a[cursor2], tmp, cursor1, len1, 0, c);
                    if (count1 != 0) {
                        arraycopy(tmp, cursor1, a, dest, count1);
                        dest += count1;
                        cursor1 += count1;
                        len1 -= count1;
                        if (len1 <= 1) break outer
                    }
                    a[dest++] = a[cursor2++];
                    if (--len2 == 0) break outer;
                    count2 = gallopLeft(tmp[cursor1], a, cursor2, len2, 0, c);
                    if (count2 != 0) {
                        arraycopy(a, cursor2, a, dest, count2);
                        dest += count2;
                        cursor2 += count2;
                        len2 -= count2;
                        if (len2 == 0) break outer
                    }
                    a[dest++] = tmp[cursor1++];
                    if (--len1 == 1) break outer;
                    minGallop--
                } while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);
                if (minGallop < 0) minGallop = 0;
                minGallop += 2
            }
            this.minGallop = minGallop < 1 ? 1 : minGallop;
            if (len1 == 1) {
                arraycopy(a, cursor2, a, dest, len2);
                a[dest + len2] = tmp[cursor1]
            } else if (len1 == 0) {
                throw new Error("IllegalArgumentException. Comparison method violates its general contract!");
            } else {
                arraycopy(tmp, cursor1, a, dest, len1)
            }
        }
    
        function mergeHi(base1, len1, base2, len2) {
            var a = global_a;
            var tmp = a.slice(base2, base2 + len2);
            var cursor1 = base1 + len1 - 1;
            var cursor2 = len2 - 1;
            var dest = base2 + len2 - 1;
            a[dest--] = a[cursor1--];
            if (--len1 == 0) {
                arraycopy(tmp, 0, a, dest - (len2 - 1), len2);
                return
            }
            if (len2 == 1) {
                dest -= len1;
                cursor1 -= len1;
                arraycopy(a, cursor1 + 1, a, dest + 1, len1);
                a[dest] = tmp[cursor2];
                return
            }
            var c = compare;
            var minGallop = MIN_GALLOP;
            outer: while (true) {
                var count1 = 0;
                var count2 = 0;
                do {
                    if (compare(tmp[cursor2], a[cursor1]) < 0) {
                        a[dest--] = a[cursor1--];
                        count1++;
                        count2 = 0;
                        if (--len1 == 0) break outer
                    } else {
                        a[dest--] = tmp[cursor2--];
                        count2++;
                        count1 = 0;
                        if (--len2 == 1) break outer
                    }
                } while ((count1 | count2) < minGallop);
                do {
                    count1 = len1 - gallopRight(tmp[cursor2], a, base1, len1, len1 - 1, c);
                    if (count1 != 0) {
                        dest -= count1;
                        cursor1 -= count1;
                        len1 -= count1;
                        arraycopy(a, cursor1 + 1, a, dest + 1, count1);
                        if (len1 == 0) break outer
                    }
                    a[dest--] = tmp[cursor2--];
                    if (--len2 == 1) break outer;
                    count2 = len2 - gallopLeft(a[cursor1], tmp, 0, len2, len2 - 1, c);
                    if (count2 != 0) {
                        dest -= count2;
                        cursor2 -= count2;
                        len2 -= count2;
                        arraycopy(tmp, cursor2 + 1, a, dest + 1, count2);
                        if (len2 <= 1) break outer
                    }
                    a[dest--] = a[cursor1--];
                    if (--len1 == 0) break outer;
                    minGallop--
                } while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);
                if (minGallop < 0) minGallop = 0;
                minGallop += 2
            }
            this.minGallop = minGallop < 1 ? 1 : minGallop;
            if (len2 == 1) {
                dest -= len1;
                cursor1 -= len1;
                arraycopy(a, cursor1 + 1, a, dest + 1, len1);
                a[dest] = tmp[cursor2]
            } else if (len2 == 0) {
                throw new Error("IllegalArgumentException. Comparison method violates its general contract!");
            } else {
                arraycopy(tmp, 0, a, dest - (len2 - 1), len2)
            }
        }
    
        function rangeCheck(arrayLen, fromIndex, toIndex) {
            if (fromIndex > toIndex) throw new Error("IllegalArgument fromIndex(" + fromIndex + ") > toIndex(" + toIndex + ")");
            if (fromIndex < 0) throw new Error("ArrayIndexOutOfBounds " + fromIndex);
            if (toIndex > arrayLen) throw new Error("ArrayIndexOutOfBounds " + toIndex);
        }
    }
    

具体操作较为复杂，这里建议大家更多的了解这个知识点，而具体实现一般不作要求。

我们来看一下 v8 在采用 Timsort 之后，得到的一些 benchmark：

![2](https://images.gitbook.cn/3eb83630-db4f-11e9-b7e8-efbebe7dfdf6)

![3](https://images.gitbook.cn/55bb5330-db4f-11e9-9f9d-c526a5f387ab)

![4](https://images.gitbook.cn/6a0bfa60-db4f-11e9-b7e8-efbebe7dfdf6)

更多内容，可以参考 v8 官方博客：[Getting things sorted in V8](https://v8.dev/blog/array-
sort)

### 实战例题

从这里开始，我们来“刷”一些实战例题。

#### 交换星号

题目：一个字符串中只包含 * 和数字，请把 * 号都放开头。

思路：使用两个指针，从后往前扫字符串，遇到数字则赋值给后面的指针，继续往后扫，遇到 * 则不处理。

    
    
    const isNumeric = n => !isNaN(parseFloat(n)) && isFinite(n);
    
    /**
     * @param {string}
     * @return {string}
     */
    const solution = s => {
        const n = s.length
        let a = s.split('')
        let j = n - 1
    
        for (let i = n - 1; i >= 0; --i)
            if (isNumeric(a[i])) a[j--] = a[i]
    
        for (; j >= 0; --j) a[j] = '*'
        return a.join('')
    }
    

这样一来，我们逆序操作数组，遇见数字则向后置，遍历完一遍后，所有的数字都已经在后边了，同时把前边的数组项用 * 填充。

#### Longest Substring Without Repeating Characters

题意：给定一个字符串，返回它最长的不包含重复的子串长度。例如，输入 abcabcbb 输出 3（对应 abc）。

思路：

  * 暴力枚举起点和终点，并判断重复，时间复杂度是 O(n²)；
  * 通过双指针、滑动窗口，动态维护窗口 [i..j)，使窗口内字符不重复。

我们看第二种思路解法，保证窗口 [i..j) 之间没有重复字符：

  * 首先 i, j 两个指针均指向字符串头部，如果没有重复字符，则 j 不断向右滑动，直到出现重复字符；
  * 如果出现了重复的字符，重复字符出现在第 str[j] 处，这时候开始移动指针 i，找到另一个重复的字读出现在 str[i] 处，那么能保证 [0, i] 以及 [i, j] 子字符串是不重复的，更新临时结果为 Math.max(result, j - i)。

**时间复杂度 O(n)**

实现：

    
    
    const lengthOfLongestSubstring = str => {
        let result = 0
        let len = str.length
    
        // 记录当前区间内出现的字符
        let mapping = {}
    
        for (let i = 0, j = 0; ; ++i) {
    
            // j 右移的过程
            while (j < len && !mapping[str[j]])
                mapping[str[j++]] = true
            result = Math.max(result, j - i)
    
            if (j >= len)
                break;
    
            // 出现了重复字符，i 开始进行右移的过程，同时将移出的字符在 mapping 中重置
            while (str[i] != str[j])
                mapping[str[i++]] = false
            mapping[str[i]] = false
    
        }
    
        return result
    };
    

举这个例子的目的是为了展示滑动窗口的思想，通过滑动窗口一般能实现 O(n) 的时间复杂度和 O(1) 的空间复杂度。

### 总结

这一讲我们主要介绍了几种排序算法和最先进的
Timsort，相信凭借这些内容，在前端排序上你可以“鄙视”面试官了。当然算法的坑还是很深的，我们要保持好的心态。最后部分介绍了两个算法题，算是抛砖引玉，下一讲，让我们针对算法面试，刷一刷算法。



## 那些年常考的前端算法（下）

前面课程，我们总结了前端和算法的关系，在上一讲中，也已经通过两道题目开启了“刷算法”的热身。算法是面试中必不可少的部分，尤其对于高阶职位来说，算法题目是面试环节的“最难”和“最关键”的环节。

算法说难也不难，我们大可不必“谈虎色变”，有策略地“刷算法题”将会使你更有信心。我认为在课程中一味地“秀算法”，找最高深最偏的算法分析没有任何意义。这里我总结出一些经典的算法题目，我常用来考察候选者以及我作为面试者遇到的一些题目来讲解。

主要内容如下：

![enter image description
here](https://images.gitbook.cn/a80ed7e0-d827-11e9-a98d-91914e1a8fb9)

### 爬楼梯

题目：假设我们需要爬一个楼梯，这个楼梯一共有 N 阶，可以一步跨越 1 个或者 2 个台阶，那么爬完楼梯一共有多少种方式？

示例：输入 2（标注 N = 2，一共是 2 级台阶）；

输出：2 （爬完一共两种方法：一次跨两阶 + 分两次走完，一次走一阶）

示例：输入 3；输出 3（1 阶 + 1 阶 + 1 阶；1 阶 + 2 阶；2 阶 + 1 阶）

思路：最直接的想法其实类似 Fibonacci 数列，使用递归比较简单。比如我们爬 N 个台阶，其实就是爬 N － 1 个台阶的方法数 + 爬 N － 2
个台阶的方法数。

解法：

    
    
    const climbing = n => {
        if (n == 1) return 1
        if (n == 2) return 2
        return climbing(n - 1) + climbing(n - 2)
    }
    

我们来分析一下时间复杂度：递归方法的时间复杂度是高度为 n−1 的不完全二叉树节点数，因此近似为 O(2^n)，具体数学公式不再展开。

我们来尝试进行优化。实际上，上述的计算过程肯定都包含了不少重复计算，比如 climbing(N) + climbing(N － 1) 后会计算
climbing(N － 1) + climbing(N － 2)，而实际上 climbing(N － 1) 只需要计算一次就可以了。

优化方案：

    
    
    const climbing = n => {
        let array = []
        const step = n => {
            if (n == 1) return 1
            if (n == 2) return 2
            if (array[n] > 0) return array[n]
    
            array[n] = step(n - 1) + step(n - 2)
            return array[n]
        }
        return step(n)
    }
    

我们使用了一个数组 array 来储存计算结果，时间复杂度为 O(n)。

另外一个优化方向是：所有递归都可以用循环来代替。

    
    
    const climbing = n => {
        if (n == 1) return 1
        if (n == 2) return 2
    
        let array = []
        array[1] = 1
        array[2] = 2
    
        for (let i = 3; i<= n; i++) {
            array[i] = array[i - 1] + array[i - 2]
        }
        return array[n]
    }
    

时间复杂度仍然为 O(n)，但是我们优化了内存的开销。

因此这道题看似“困难”，其实就是一个 Fibonacci
数列。很多算法题目都是类似的，也许第一次读题会觉得没有思路，但是隐藏在题目后边的解决方案，其实就是我们常见的知识。

### Combination Sum

这个算法，让我们来聚焦“回溯”这两个字，题目出处 [Combination
Sum](https://juejin.im/post/5d1ca2c5e51d4550bf1ae8cd)。

题目：给定一组不含重复数字的非负数组和一个非负目标数字，在数组中找出所有数加起来等于给定的目标数字的组合。

示例：输入

    
    
    const array = [2, 3, 6, 7]
    const target = 7
    

输出：

    
    
    [
      [7],
      [2,2,3]
    ]
    

我们直接来看优化后的思想：回溯解决问题的套路就是先用“笨办法”，遍历所有的情况来找出问题的解，在这个遍历过程当中，以深度优先的方式搜索解空间，并且在搜索过程中用剪枝函数避免无效搜索。

回到这个问题，我们先通过图来遍历所有情况：

![5](https://images.gitbook.cn/4a7e0ec0-db51-11e9-a268-91dece478f6a)

对于这个题目，事实上我们思考，数组 [2, 2, 3] 和 [2, 3, 2] 实际是重复的，因此可以删除掉重复的项，优化递归树为：

![6](https://images.gitbook.cn/63ca0a50-db51-11e9-9f9d-c526a5f387ab)

我们该如何用代码描述上述过程呢？这时候需要一个临时数组 tmpArray，进入递归前 push 一个结果，

最终答案：

    
    
    const find = (array, target) => {
        let result = []
    
        const dfs = (index, sum, tmpArray)  => {
            if (sum === target) {
                result.push(tmpArray.slice())
            }
    
            if (sum > target) {
                return
            }
    
            for (let i = index; i < array.length; i++) {
                tmpArray.push(array[i])
    
                dfs(i, sum + array[i], tmpArray)
    
                tmpArray.pop()
            }
        }
    
        dfs(0, 0, [])
    
        return result    
    }
    

如果读者存在理解问题，建议打断点调试一下。回溯是一个非常常见的思想，这也是一个典型的回溯常考题目。

另外，该题有另一个变种：

> 从一个数组中找出 N 个数，其和为 M 的所有可能。

这里我们指定数组元素个数的和，需要这个和为指定值。

举例：从数组 [1, 2, 3, 4] 中选取 2 个元素，求和为 5 的所有可能。答案是两组组合: [1, 4] 和 [2, 3]。

这里我们介绍一种借助“二进制”实现的解法，可以用 0 和 1 来表示数组中相应的元素是否被选中。因此，对于一个长度为 4 的数组来说：

  * 0000 表示没有选择数组中的任何元素
  * 0100 表示选择了数组中第 1 位元素

以此类推，数组长度为 4，那么上述情况一共有 16 种可能（Math.pow(length, 2)）。

而这道题目中，只需要选择指定数组元素个数的和，还是对于数组长度为 4 的情况：只需要考虑 0011 等 1 的个数累加为 0 case，而不需要考虑类似
0111 这样的 case。

针对符合个数的所有情况，我们进行数组项目的求和，判断是否等于指定值的情况即可：

    
    
    const find = (array, target, sum) => {
      const len = array.length
      let result = []
    
      for (let i = 0; i < Math.pow(2, len); i++) {
        if (getCount(i) == target) {
          let s = 0 
          let temp = []
          for (let j = 0; j < len; j++) {
            if (i & 1 << (len - 1 -j)) {
              s += array[j]
              temp.push(array[j])
            }
          }
          if (s == sum) {
            result.push(temp)
          }
        }
      }
      return result
    }
    
    function getCount(i) {
      let count = 0;
      while (i) {
       if (i & 1){
        ++count
       }
       i >>= 1
      }
      return count
    }
    

### remove duplicates from sorted array

题目：对一个给定一个排序数组去重，同时返回去重后数组的新长度。

难点：这道题并不困难，但是需要临时加一些条件，即需要原地操作，在使用 O(1) 额外空间的条件下完成。

示例：

输入：

    
    
    let array = [0,0,1,1,1,2,2,3,3,4]
    

输出：

    
    
    console.log(removeDuplicates(array))
    // 5
    
    console.log(array)
    // 0, 1, 2, 3, 4
    

这道题既然规定 in-place 的操作，那么可以考虑算法中的另一个重要思想：双指针。

![7](https://images.gitbook.cn/33808a30-df3a-11e9-87f9-6dac5837a5da)

使用快慢指针：

  * 开始时，快指针和慢指针都指向数组中的第一项
  * 如果快指针和慢指针指的数字相同，则快指针向前走一步
  * 如果快指针和慢指针指的数字不同，则两个指针都向前走一步，同时快指针指向的数字赋值给慢指针指向的数字
  * 当快指针走完整个数组后，慢指针当前的坐标加 1 就是数组中不同数字的个数

代码很简单：

    
    
    const removeDuplicates = array => {
        const length = array.length
    
        let slowPointer = 0
    
        for (let fastPointer = 0; fastPointer < length; fastPointer ++) {
            if (array[slowPointer] !== array[fastPointer]) {
                slowPointer++
                array[slowPointer] = array[fastPointer]
            }
        }
    }
    

这道题目如果不要求 O(n) 的时间复杂度， O(1) 的空间复杂度，那么会非常简单。如果进行空间复杂度要求，尤其是 in-place
操作，开发者往往可以考虑双指针的思路。

### 求众数

这也是一道简单的题目，关键点在于如何优化。

题目：给定一个大小为 N 的数组，找到其中的众数。众数是指在数组中出现次数大于 N/2 的元素。

可能大家都会想到使用一个额外的空间，记录元素出现的次数，我们往往用一个 map 就可以轻易地实现。那优化点在哪里呢？答案就是投票算法。

    
    
    const find = array => {
        let count = 1
        let result = array[0]
    
        for (let i = 0; i < array.lenght; i++) {
            if (count === 0) result = array[i]
    
            if (array[i] === result) {
                count++
            }
            else {
                count--
            }
        }
    
        return result
    }
    

### 有效括号

有效括号这个题目和前端息息相关，在之前课程模版解析时，其实都需要类似的算法进行模版的分析，进而实现数据的绑定。我们来看题目：

举例：输入 "()"

输出：true

举例：输入 "()[]{}"

输出：true

举例：输入 "{[]}"

输出：false

举例：输入 "([)]"

输出：false

这道题目的解法非常典型，就是借助栈实现，将这些括号自右向左看做栈结构。我们把成对的括号分为左括号和右括号，需要左括号和右括号一一匹配，通过一个 Object
来维护关系：

    
    
    let obj = {
        "]": "[",
        "}": "{",
        ")": "(",
    }
    

如果编译器中在解析时，遇见左括号，我们就入栈；如果是右括号，就取出栈顶元素检查是否匹配。如果匹配，就出栈；否则，就返回 false。

    
    
    const isValid = str => {
        let stack = []
        var obj = {
            "]": "[",
            "}": "{",
            ")": "(",
        }
    
        for (let i = 0; i < str.length; i++) {
            if(str[i] === "[" || str[i] === "{" || str[i] === "(") {
                stack.push(str[i])
            } 
            else {
                let key = stack.pop()
                if(obj[key] !== str[i]) {
                    return false
                }
            }
        }
    
        if (!stack.length) {
            return true
        }
    
        return false
    };
    

### LRU 缓存算法

看了这么多小算法题目，我们来换一个口味，现在看一个算法的实际应用。

> LRU（Least Recently
Used）算法是缓存淘汰算法的一种。简单地说，由于内存空间有限，需要根据某种策略淘汰不那么重要的数据，用以释放内存。LRU
的策略是最早操作过的数据放最后，最晚操作过的放开始，按操作时间逆序，如果达到上限，则淘汰末尾的项。

整个 LRU 算法有一定的复杂度，并且需要很多功能扩展。因此在生产环境中建议直接使用成熟的库，比如 npm 搜索 lru-cache。

这里我们尝试实现一个微型体统级别的 LRU 算法：

> 运用你所掌握的数据结构，设计和实现一个 LRU（最近最少使用）缓存机制。它应该支持以下操作：获取数据 get 和 写入数据 put 。

获取数据 get(key) － 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 －1。

写入数据 put(key, value) －
如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。

我们先来整体思考：尽量满足 O(1) 的时间复杂度中完成获取和写入的操作，那么可以使用一个 Object 来进行存储，如果 key 不是简单类型，可以使用
Map 实现：

    
    
    const LRUCache = function(capacity) {
      // ...
      this.map = {};
      // ...
    };
    

在这个算法中，最复杂的应该是淘汰策略，淘汰数据的时间复杂度必须是 O(1) 的话，我们一定需要额外的数据结构来完成 O(1)
的淘汰策略。那应该用什么样的数据结构呢？答案是双向链表。

链表在插入与删除操作上，都是 O(1) 时间的复杂度，唯一有问题的查找元素过程比较麻烦，是 O(n)。但是这里我们不需要使用双向链表实现查找逻辑，因为
map 已经很好的弥补了缺陷。

赘述一下： **我们在写入值的时候，判断缓存容量是否已经达到上限，如果缓存容量达到上限时，应该删除最近最少使用的数据值，从而为以后的新的数据值留出空间。**

结合链表的话，我们将刚刚写入的目标值设置为链表的首项，超过限制，就删除链表的尾项。

最终实现：

    
    
    const LRUCache = function(capacity) {
      this.map = {}
      this.size = 0
      this.maxSize = capacity
    
      // 链表初始化，初始化只有一个头和尾
      this.head = {
        prev: null,
        next: null
      }
      this.tail = {
        prev: this.head,
        next: null
      }
    
      this.head.next = this.tail
    };
    
    LRUCache.prototype.get = function(key) {
      if (this.map[key]) {
        const node = this.extractNode(this.map[key])
    
        // 最新访问，将该节点放到链表的头部
        this.insertNodeToHead(node)
    
        return this.map[key].val
      } 
      else {
        return -1
      }
    }
    
    LRUCache.prototype.put = function(key, value) {
      let node
    
      if (this.map[key]) {
        // 该项已经存在，更新值
        node = this.extractNode(this.map[key])
        node.val = value
      } 
      else {
        // 如该项不存在，新创造节点
        node = {
          prev: null,
          next: null,
          val: value,
          key,
        }
    
        this.map[key] = node
        this.size++
      }
    
      // 最新写入，将该节点放到链表的头部
      this.insertNodeToHead(node)
    
      // 判断长度是否已经到达上限
      if (this.size > this.maxSize) {
        const nodeToDelete = this.tail.prev
        const keyToDelete = nodeToDelete.key
        this.extractNode(nodeToDelete)
        this.size--
        delete this.map[keyToDelete]
      }
    };
    
    // 插入节点到链表首项
    LRUCache.prototype.insertNodeToHead = function(node) {
      const head = this.head
      const lastFirstNode = this.head.next
    
      node.prev = head
      head.next = node
      node.next = lastFirstNode
      lastFirstNode.prev = node
    
      return node
    }
    
    // 从链表中抽取节点
    LRUCache.prototype.extractNode = function(node) {
      const beforeNode = node.prev
      const afterNode = node.next
    
      beforeNode.next = afterNode
      afterNode.prev = beforeNode
    
      node.prev = null
      node.next = null
    
      return node
    }
    

### 链表相关题目

在之前的课程中，我们介绍了链表这种数据结构。链表应用非常广泛，这里来熟悉两个常见的对链表的操作算法。

#### 反转链表

题目：对一个单链表进行反转

输入：1→2→3→4→5→NULL

输出：5→4→3→2→1→NULL

最直观的解法是使用三个指针，把头节点变成尾节点点，进行遍历：下一个节点
拼接到当前节点的头部，以此类推。这种方法的实现我们不再手写，而是重点关注一下递归解法。

递归解法就要先判断递归终止条件，当下一个节点为 null，找到尾节点时，将其返回。我们从后往前进行：

    
    
    const reverseList = head => {
       // 到了尾节点，则返回尾节点
       if (head == null || head.next == null) {
           return head
       }
       else {
           let newhead = reverseList(head.next)
           // 将当前节点的一下节点的 next 指向，指向为当前节点
           head.next.next = head
           // 暂时情况当前节点的 next 指向
           head.next = null
    
           return newhead
       }
    }
    

#### 删除链表的倒数第 N 个节点

题目：给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。

输入：1→2→3→4→5，和 n = 2

输出：1→2→3→5

这道题目的关键是如何优雅地找到倒数第 N 个节点。

我们当然可以使用两次循环，第一次循环得到整个链表的长度 L，那么需要删除的节点就位于 L - N + 1 位置处，第二次遍历到相关位置进行操作即可。

这道题其实是可以用一次遍历来解决的。我们需要使用双指针，快指针 fast 先前进 N，找到需要删除的节点；然后慢指针 slow 从 head 开始，和快指针
fast 一起前进，直到 fast 走到末尾。 此时 slow 的下一个节点就是要删除的节点，也就是倒数第 N 个节点。需要注意的是，如果快指针移动 N
步之后，已经到了尾部，那说明需要删除的就是头节点。

    
    
    const removeNthFromEnd = (head, n) => {
        if (head === null) {
            return head
        }
    
        if (n === 0) {
            return head
        }
    
        let fast = head
        let slow = head
    
        // 快指针前进 N 步
        while (n > 0) {
            fast = fast.next
            n--
        }
    
        // 快指针移动 N 步之后，已经到了尾部，那说明需要删除的就是头节点
        if (fast === null) {
            return head.next
        }
    
        while (fast.next != null ){
            fast = fast.next
            slow = slow.next
        }
    
        slow.next=slow.next.next
        return head
    }
    

这两道关于链表的题目都重点考察了对你链表结构的理解，其中是用到了多个指针，这也是解决链表题目的关键。

### 算法学习

本节课内容到这里，我们只是列举了一些算法题目，也算不上“题海战术”，但问题都比较典型。可是面对这些相对零散的内容，我们应该如何入手学习呢？只是一味的刷题，似乎效率低下而无趣。

我认为对于算法的学习，需要做到“分门别类”，按照不同类别的算法思想，遵循循序渐进的进步路线，才会“越来越有感觉”。我把算法的一些基础思想进行了归并：

  * 枚举
  * 模拟
  * 递归/分治
  * 贪心
  * 排序
  * 二分
  * 倍增
  * 构造
  * 前缀和/差分

我们来简单总结一下这些算法基础思想。

#### 枚举

枚举是基于已有知识来猜测，印证答案的一种问题求解策略。当拿到一道题目时，枚举这种“暴力解法”最容易想到。这其中重点是：

  * 建立简洁的数学模型
  * 想清楚枚举哪些要素
  * 尝试减少枚举空间

举个例子：

> 一个数组中的数互不相同，求其中和为 0 的数对的个数

最笨的方法：

    
    
    for (int i = 0; i < n; ++i)
      for (int j = 0; j < n; ++j)
        if (a[i] + a[j] == 0) ++ans;
    

我们来看看如何操作进行优化。如果 (a, b) 是答案，那么 (b, a) 也是答案，因此对于这种情况只需统计一种顺序之后的答案，最后再乘 2 就好了。

    
    
    for (int i = 0; i < n; ++i)
      for (int j = 0; j < i; ++j)
        if (a[i] + a[j] == 0) ++ans;
    

如此一来，就减少了 j 的枚举范围，减少了这段代码的时间开销。然而这还不是最优解。

我们思考：两个数是否都一定要枚举出来呢？其实枚举第一个数之后，题目的条件已经帮我们确定了其他的要素（另一个数），如果能找到一种方法直接判断题目要求的那个数是否存在，就可以省掉枚举后一个数的时间了。代码实现很简单，我们就不动手实现了。

#### 模拟

模拟。顾名思义，就是用计算机来模拟题目中要求的操作，我们只需要按照题面的意思来写就可以了。模拟题目通常具有码量大、操作多、思路繁复的特点。

这种题目往往考察开发者的“逻辑转化为代码”的能力。一道典型题目是：[魔兽世界](http://bailian.openjudge.cn/practice/3750/)。

#### 递归 & 分治

递归的基本思想是某个函数直接或者间接地调用自身，这样就把原问题的求解转换为许多性质相同但是规模更小的子问题。

递归和枚举的区别在于：枚举是横向地把问题划分，然后依次求解子问题，而递归是把问题逐级分解，是纵向的拆分。比如请尝试回答这几个问题：

> 孙悟空身上有多少根毛？答：一根毛加剩下的毛。 你今年几岁？答：去年的岁数加一岁，1999 年我出生。

递归代码最重要的两个特征：结束条件和自我调用。

    
    
    int func(传入数值) {
      if (终止条件) return 最小子问题解;
      return func(缩小规模);
    }
    

写递归的技巧，“明白一个函数的作用并相信它能完成这个任务，千万不要试图跳进细节”。
千万不要跳进这个函数里面企图探究更多细节，否则就会陷入无穷的细节无法自拔，人脑能压几个栈啊。

先举个最简单的例子：遍历二叉树。

    
    
    void traverse(TreeNode* root) {
      if (root == nullptr) return;
      traverse(root->left);
      traverse(root->right);
    }
    

这几行代码就足以遍历任何一棵二叉树了。对于递归函数 traverse(root) ，我们只要相信：给它一个根节点
root，它就能遍历这棵树，因为写这个函数不就是为了这个目的吗？

那么遍历一棵 N 叉数呢？

    
    
    void traverse(TreeNode* root) {
      if (root == nullptr) return;
      for (child : root->children) traverse(child);
    }
    

总之，还是那句话：给它一个根节点 root，它就能遍历这棵树，不管你是几个叉。

典型题目：

> 给一棵二叉树，和一个目标值，节点上的值有正有负，返回树中和等于目标值的路径条数

这道题目解法很多，也比较典型。这里我们只谈思想，具体实现就不展开。

分治算法可以分三步走：分解 -> 解决 -> 合并。

  * 分解原问题为结构相同的子问题
  * 分解到某个容易求解的边界之后，进行递归求解
  * 将子问题的解合并成原问题的解

归并排序是最典型的分治算法。

    
    
    void mergeSort(一个数组) {
      if (可以很容易处理) return
      mergeSort(左半个数组)
      mergeSort(右半个数组)
      merge(左半个数组, 右半个数组)
    }
    

分治算法的套路就是前面说的三步走：分解 -> 解决 -> 合并：先左右分解，再处理合并，回溯就是在退栈，就相当于后序遍历了。至于 merge
函数，相当于两个有序链表的合并。

LeetCode 有[递归专题练习](https://leetcode.com/explore/learn/card/recursion-i/)
LeetCode 上有[分治算法的专项练习](https://leetcode-cn.com/tag/divide-and-
conquer/?utm_source=LCUS&utm_medium=ip_redirect_o_uns&utm_campaign=transfer2china)

#### 贪心

贪心算法顾名思义就是只看眼前，并不考虑以后可能造成的影响。可想而知，并不是所有的时候贪心法都能获得最优解。

最常见的贪心有两种。一种是：「将 XXX 按照某某顺序排序，然后按某种顺序（例如从小到大）处理」。另一种是：「我们每次都取 XXX 中最大/小的东西，并更新
XXX」，有时「XXX 中最大/小的东西」可以优化，比如用优先队列维护。这两种方式分别对应了离线的情况以及在线的情况。

相关题目：

  * [工作调度Work Scheduling](https://www.luogu.org/problem/P2949)
  * [修理牛棚 Barn Repair](https://www.luogu.org/problem/P1209)
  * [皇后游戏](https://www.luogu.org/problem/P2123)

#### 二分

以二分搜索为例，它是用来在一个有序数组中查找某一元素的算法。它每次考察数组当前部分的中间元素，如果中间元素刚好是要找的，就结束搜索过程；如果中间元素小于所查找的值，那么左侧的只会更小，不会有所查找的元素，只需要到右侧去找就好了；如果中间元素大于所查找的值，同理，右侧的只会更大而不会有所查找的元素，所以只需要到左侧去找。

在二分搜索过程中，每次都把查询的区间减半，因此对于一个长度为 n 的数组，至多会进行 log(n) 次查找。

一定需要注意的是，这里的有序是广义的有序，如果一个数组中的左侧或者右侧都满足某一种条件，而另一侧都不满足这种条件，也可以看作是一种有序。

二分法把一个寻找极值的问题转化成一个判定的问题（用二分搜索来找这个极值）。类比枚举法，我们当时是枚举答案的可能情况，现在由于单调性，我们不再需要一个个枚举，利用二分的思路，就可以用更优的方法解决「最大值最小」、「最小值最大」。这种解法也成为是「二分答案」，常见于解题报告中。

比如：[砍树问题](https://www.luogu.org/problem/P1873)，我们可以在 1 到 1000000000（10
亿）中枚举答案，但是这种朴素写法肯定拿不到满分，因为从 1 跑到 10 亿太耗时间。我们可以对答案进行 1 到 10
亿的二分，其中，每次都对其进行检查可行性（一般都是使用贪心法）。

依照此思想，我们还有三分法等展开算法。

#### 倍增

倍增法，通过字面意思来看就是翻倍。这个方法在很多算法中均有应用，其中最常用的就是 RMQ 问题和求 LCA。

RMQ 是英文 Range Maximum/Minimum Query 的缩写，表示区间最大（最小）值。解决 RMQ 问题的主要方法有两种，分别是 ST
表和线段树，具体请参见 ST 表和 线段树内容。

#### 构造

构造针对的问题的答案往往具有某种规律性，使得在问题规模迅速增大的时候，仍然有机会比较容易地得到答案。

这种思想我们接触的比较少，主要体现了数学解题方法啊。比较典型的有：

  * [Luogu P3599 Koishi Loves Construction](https://www.luogu.org/problemnew/show/P3599)
  * [Vladik and fractions](http://codeforces.com/problemset/problem/743/C)
  * [AtCoder Grand Contest 032 B](https://atcoder.jp/contests/agc032/tasks/agc032_b)

这里我们不再介绍，感兴趣的同学可以进行研究。

#### 前缀和 & 差分

前缀和是一种重要的预处理，能大大降低查询的时间复杂度。我们可以简单理解为“数列的前 n 项的和”。其实前缀和几乎都是基于容斥原理。

比如这道题目：

> 有 N 个的正整数放到数组 A 里，现在要求一个新的数组 B，新数组的第 i 个数 B[i]是原数组 A 第 0 到第 i 个数的和。

对于这道题，我们有两种做法：

  * 把对数组 A 的累加依次放入数组 B 中。
  * 递推： B[i] = B[i-1] + A[i]

我们看第二种方法采用前缀和的思想，无疑更加优秀。

其他相关题目：

  * [前缀和](https://www.luogu.org/problem/U53525)
  * [前缀和的逆](https://www.luogu.org/problem/U69096)
  * [最大の和](https://www.luogu.org/problem/AT2412)
  * [Subsequences Summing to Sevens](https://www.luogu.org/problem/P3131)

更复杂些，可以延伸出：基于 DP 计算高维前缀和，树上前缀和。

最后，差分是一种和前缀和相对的策略。这种策略是求相邻两数的差。相关题目：

  * [树状数组 3 ：区间修改，区间查询](https://loj.ac/problem/132)
  * [地毯](https://www.luogu.org/problem/P3397)
  * [最大流](https://www.luogu.org/problem/P3128)

#### 思想归并

我列举了 9
中算法基本思想，并配上多到典型题目。实际上，读者可以根据自身情况酌情进行了解，在解题外更重要的是体会这些算法思想。比如我留一个小作业：在这三节课中所有讲到的算法中，你能按照这
9 种思想进行归类么？

请动手尝试，我认为我们可以有解不出来的题目，但是对于算法思想的理解至关重要。

### 总结

到此我们关于算法的三节课就结束了。整体来说，算法需要应试。算法就像弹簧一样，只要你有信心，态度正确，不畏难，一定就可以攻克它。

从今天起，下一个决心，制定一个计划，通过不断练习，提升自己解算法题的能力。当然学习数据结构和算法不仅仅对面试有帮助，对于程序的强健性、稳定性、性能来说，算法虽然只是细节，但却是最重要的一部分之一。比如
AVL 或者 B+ 树，可能除了在学校的大作业，一辈子也不会有机会实现一个出来，但你学会了分析和比较类似算法的能力, 有了搜索树的知识，你才能真正理解为什么
InnoDB 索引要用 B+ 树，你才能明白 like "abc%" 会不会使用索引，而不是人云亦云、知其然不知其所以然。

这一节课我挑选的典型算法都不算困难，但都能体现算法的思想闪光点，适合类推。但实话说，这节课的内容相对零散，算法的思想却是可以归类的，也留给大家一个作业，将上述算法进行思想归类，并在每个归类下再找一道题目进行扩充。这样的学习方法一定会让你有所收获，在全部课程结束后，我也会和大家针对这个“作业”，进行交流，也分享出我的更多算法心得。



## 分析一道“微信”面试题

前一段时间，一道疑似“微信”招聘的面试题出现，可能有不少读者已经了解过了。这道题乍一看挺难，但是细细分析却还算简单，我们甚至可以用多种手段解题，用不同思想来给出答案。

网上零零碎碎的有一些解答，但是缺乏全面梳理。我认为通过这道题，有必要将前端多重知识点“融会贯通”，在这里和大家分享。

本讲知识点如下：

![enter image description
here](https://images.gitbook.cn/bfedc2e0-de9e-11e9-9f8b-d5f483bb0ebd)

### 题意分析

我们来先看看题目：

> 实现一个 LazyMan，按照以下方式调用时，得到相关输出：

    
    
    LazyMan("Hank")
    // Hi! This is Hank!
     
    LazyMan("Hank").sleep(10).eat("dinner")
    // Hi! This is Hank!
    // 等待10 秒..
    // Wake up after 10
    // Eat dinner~
     
    LazyMan("Hank").eat("dinner").eat("supper")
    // Hi This is Hank!
    // Eat dinner~
    // Eat supper~
     
    LazyMan("Hank").sleepFirst(5).eat("supper")
    // 等待 5 秒
    // Wake up after 5
    // Hi This is Hank!
    // Eat supper
    

当面试者拿到这道题目的时候，乍看题干可能会有点慌张。其实很多面试失败是“自己吓唬自己”，在平时放松状态下写代码，也许解题不在话下。

下面我们就从接到题目开始，剖析应该如何进行分析：

  * 可以把 LazyMan 理解为一个构造函数，在调用时输出参数内容
  * LazyMan 支持链式调用
  * 链式调用过程提供了以下几个方法：sleepFirst、eat、sleep
  * 其中 eat 方法输出参数相关内容：Eat + 参数
  * sleep 方法比较特殊，链式调用将暂停一定时间后继续执行，看到这里也许应该想到 setTimeout
  * sleepFirst 最为特殊，这个任务或者这个方法的 **优先级最高** ；调用 sleepFirst 之后，链式调用将暂停一定时间后继续执行。请再次观察题干，尤其是最后一个 demo，sleepFirst 的输出优先级最高，调用后先等待 5 秒输出 Wake up after 5，再输出 Hi This is Hank!

我们应该如何解这个题目呢，从拿到需求开始进行分析：

  * 先从最简单的，我们可以封装一些基础方法，比如 log 输出、封装 setTimeout 等
  * 因为 LazyMan 要实现一系列调用， **且调用并不是顺序执行的，比如如果 sleepFirst 出现在调用链时，优先执行；同时任务并不是全部都同步执行的** ，因此 **我们应该实现一个任务队列** ，这个队列将调度执行各个任务
  * 因此每次调用 LazyMan 或链式执行时，我们应该将相关调用方法加入到（push）任务队列中，储存起来，后续统一被调度
  * 在写入任务队列时，如果当前的方法为 sleepFirst，那么需要将该方法放到队列的最头处，这应该是一个 unshift 方法

这么一分析，这道题就“非常简单”了。

我们来试图解剖一下这道题目的考察点：

  * 面向对象思想与设计，包括类的使用等
  * 对象方法链式调用的理解和设计
  * 小部分设计模式的设计
  * 因为存在“重复逻辑”，考察代码的解耦和抽象能力
  * 逻辑的清晰程度以及其他编程思维

### 常规思路解答

基于以上思路，我们给出较为常规的答案，其中代码已经加上了必要的注释：

    
    
    class LazyManGenerator {
      constructor(name) {
        this.taskArray = []
    
        // 初始化时任务
        const task = () => {
          console.log(`Hi! This is ${name}`)
          // 执行完初始化时任务后，继续执行下一个任务
          this.next()
        }
    
        // 将初始化任务放入任务队列中
        this.taskArray.push(task)
    
        setTimeout(() => {
          this.next()
        }, 0)
      }
    
      next() {
          // 取出下一个任务并执行
        const task = this.taskArray.shift()
        task && task()
      }
    
      sleep(time) {
        this.sleepTask(time, false)
        // return this 保持链式调用
        return this
      }
    
      sleepFirst(time) {
        this.sleepTask(time, true)
        return this
      }
    
      sleepTask(time, prior) {
        const task = () => {
          setTimeout(() => {
            console.log(`Wake up after ${time}`)
            this.next()
          }, time * 1000)
        }
    
        if (prior) {
          this.taskArray.unshift(task)
        } else {
          this.taskArray.push(task)
        }
      }
    
      eat(name) {
        const task = () => {
          console.log(`Eat ${name}`)
          this.next()
        }
    
        this.taskArray.push(task)
        return this
      }
    }
    
    function LazyMan(name) {
      return new LazyManGenerator(name)
    }
    

简单分析一下：

  * LazyMan 方法返回一个 LazyManGenerator 构造函数的实例
  * 在 LazyManGenerator constructor 当中，我们维护了 taskArray 用来存储任务，同时将初始化任务放到 taskArray 当中
  * 还是在 LazyManGenerator constructor 中，将任务的逐个执行即 next 调用放在 setTimeout 中，这样就能够保证在开始执行任务时，taskArray 数组已经填满了任务
  * 我们来看看 next 方法，取出 taskArray 数组中的首项，进行执行
  * eat 方法将 eat task 放到 taskArray 数组中，注意 eat task 方法需要调用 this.next() 显式调用“下一个任务”；同时返回 this，完成链式调用
  * sleep 和 sleepFirst 都调用了 sleepTask，不同在于第二个参数：sleepTask 第二个参数表示是否优先执行，如果 prior 为 true，则使用 unshift 将任务插到 taskArray 开头

这个解法最容易想到，也相对来说容易，主要是面向过程。关键点在于对于 setTimeout 任务队列的准确理解以及 return this
实现链式调用的方式。

事实上，sleepTask 应该作为 LazyManGenerator 类的私有属性出现，因为 ES class 暂时 private
属性没有被广泛实现，这里不再追求实现。

### 设计模式解答

关于这道题目的解答，网上最流行的是一种发布订阅模式的方案。相关代码出处：[lazyMan](https://github.com/wall-
wxk/blogDemo/blob/master/2017/01/22/lazyMan.html)。

但是其实仔细看其实现，也是上一环节中常规解法的变种。虽然说是发布订阅模式，但是其实仍然是 next 思想执行下一个任务的思路，该实现 publish 和
subscribe 方法分别是完成执行任务和注册任务逻辑。我认为这样的代码实现有一点“过度设计”之嫌，更像是往发布订阅模式上去靠，整体流程不够自然。

当然读者仍可参考，并有自己的思考，这里我不再更多分析。

### 再谈流程控制和队列、中间件启发

这道题目我们给出解法并不算完，更重要也更有价值的是思考、延伸。微信题目较好地考察了候选者的流程控制能力，而流程控制在前端开发者面前也非常重要。

我们看上述代码中的 next 函数，它负责找出 stack 中的下一个函数并执行：

    
    
    next() {
        // 取出下一个任务并执行
        const task = this.taskArray.shift()
        task && task()
    }
    

NodeJS 中 connect 类库，以及其他框架的中间件设计也都离不开类似思想的 next。比如生成器自动执行函数 co、redux、koa
也通过不同的实现，可以让 next 在多个函数之间执行完后面的函数再折回来执行 next，较为巧妙。我们具体来看一下。

#### senchalabs connect 和 express

具体场景：在 Node 环境中，有 parseBody、checkIdInDatabase 等相关中间件，他们组成了 middlewares 数组：

    
    
    const middlewares = [
      function middleware1(req, res, next) {
        parseBody(req, function(err, body) {
          if (err) return next(err);
          req.body = body;
          next();
        });
      },
      function middleware2(req, res, next) {
        checkIdInDatabase(req.body.id, function(err, rows) {
          if (err) return next(err);
          res.dbResult = rows;
          next();
        });
      },
      function middleware3(req, res, next) {
        if (res.dbResult && res.dbResult.length > 0) {
          res.end('true');
        }
        else {
          res.end('false');
        }
        next();
      }
    ]
    

当一个请求打开时，我们需要链式调用各个中间件：

    
    
    const requestHandler = (req, res) => {
      let i = 0
    
      function next(err) {
        if (err) {
          return res.end('error:', err.toString())
        }
    
        if (i < middlewares.length) {
          middlewares[i++](req, res, next)
        } else {
          return
        }
      }
    
      // 初始执行第一个中间件
      next()
    }
    

基本思路和面试题解法一致：

  * 将所有中间件（任务处理函数）储存在一个 list 中
  * 循环依次调用中间件（任务处理函数）

senchalabs/connect 这个库做了很好的封装，是 express 等框架设计实现的原始模型。这里我们简单分析一下
senchalabs/connect 这个库的实现。

用法：

首先使用 createServer 方法创建 app 实例，

    
    
    const app = createServer()
    

对应源码：

    
    
    function createServer() {
      function app(req, res, next){ app.handle(req, res, next); }
      merge(app, proto);
      merge(app, EventEmitter.prototype);
      app.route = '/';
      app.stack = [];
      return app;
    }
    

我们看 app 实例“继承”了 EventEmitter 类，实现事件发布订阅，同时 stack 数组来维护各个中间件任务。

接着使用 app.use 来添加中间件：

    
    
    app.use('/api', function(req, res, next) {//...})
    

源码实现：

    
    
    proto.use = function use(route, fn) {
      var handle = fn;
      var path = route;
    
      // default route to '/'
      if (typeof route !== 'string') {
        handle = route;
        path = '/';
      }
    
      // wrap sub-apps
      if (typeof handle.handle === 'function') {
        var server = handle;
        server.route = path;
        handle = function (req, res, next) {
          server.handle(req, res, next);
        };
      }
    
      // wrap vanilla http.Servers
      if (handle instanceof http.Server) {
        handle = handle.listeners('request')[0];
      }
    
      // strip trailing slash
      if (path[path.length - 1] === '/') {
        path = path.slice(0, -1);
      }
    
      // add the middleware
      debug('use %s %s', path || '/', handle.name || 'anonymous');
      this.stack.push({ route: path, handle: handle });
    
      return this;
    };
    

通过 if...else 逻辑区分出三种不同的 fn 类型：

  * fn 是一个普通的 function(req,res[,next]){} 函数
  * fn 是一个普通的 httpServer
  * fn 是一个普通的是另一个 connect 的 app 对象（sub app 特性）

对于这三种类型，分别转换为 function(req, res, next) {} 的形式，具体我们不再分析。最重要的执行过程是：

    
    
    this.stack.push({ route: path, handle: handle })
    

以及返回：

    
    
    return this
    

以上就完成了中间件即任务的注册，我们有：

    
    
    app.stack = [function1, function2, function3, ...];
    

接下来看看任务的调度和执行。使用方法：

    
    
    app.handle(req, res, out)
    

handle 源码实现：

    
    
    proto.handle = function handle(req, res, out) {
      var index = 0;
      var protohost = getProtohost(req.url) || '';
      var removed = '';
      var slashAdded = false;
      var stack = this.stack;
    
      // final function handler
      var done = out || finalhandler(req, res, {
        env: env,
        onerror: logerror
      });
    
      // store the original URL
      req.originalUrl = req.originalUrl || req.url;
    
      function next(err) {
        // ...
      }
    
      next();
    };
    

源码导读：out 参数是关于 sub app 的特性，这个特性可以暂时忽略，我们暂时不关心。handle 实现我们并不陌生，它构建 next
函数，并触发第一个 next 执行。

next 实现：

    
    
    function next(err) {
        if (slashAdded) {
          req.url = req.url.substr(1);
          slashAdded = false;
        }
    
        if (removed.length !== 0) {
          req.url = protohost + removed + req.url.substr(protohost.length);
          removed = '';
        }
    
        // next callback
        var layer = stack[index++];
    
        // all done
        if (!layer) {
          defer(done, err);
          return;
        }
    
        // route data
        var path = parseUrl(req).pathname || '/';
        var route = layer.route;
    
        // skip this layer if the route doesn't match
        if (path.toLowerCase().substr(0, route.length) !== route.toLowerCase()) {
          return next(err);
        }
    
        // skip if route match does not border "/", ".", or end
        var c = path.length > route.length && path[route.length];
        if (c && c !== '/' && c !== '.') {
          return next(err);
        }
    
        // trim off the part of the url that matches the route
        if (route.length !== 0 && route !== '/') {
          removed = route;
          req.url = protohost + req.url.substr(protohost.length + removed.length);
    
          // ensure leading slash
          if (!protohost && req.url[0] !== '/') {
            req.url = '/' + req.url;
            slashAdded = true;
          }
        }
    
        // call the layer handle
        call(layer.handle, route, err, req, res, next);
    }
    

源码导读：

  * 取出下一个中间件

    
    
    var layer = stack[index++]
    

  * 如果当前请求路由和 handler 不匹配，则跳过：

    
    
    if (path.toLowerCase().substr(0, route.length) !== route.toLowerCase()) {
      return next(err);
    }
    

  * 若匹配，则执行 call 函数，call 函数实现：

    
    
    function call(handle, route, err, req, res, next) {
      var arity = handle.length;
      var error = err;
      var hasError = Boolean(err);
    
      debug('%s %s : %s', handle.name || '<anonymous>', route, req.originalUrl);
    
      try {
        if (hasError && arity === 4) {
          // error-handling middleware
          handle(err, req, res, next);
          return;
        } else if (!hasError && arity < 4) {
          // request-handling middleware
          handle(req, res, next);
          return;
        }
      } catch (e) {
        // replace the error
        error = e;
      }
    
      // continue
      next(error);
    }
    

注意：我们使用了 try...catch 包裹逻辑，这是很必要的容错思维，这样第三方中间件的执行如果出错，不至于打挂我们的应用。

较为巧妙的一点是：function(err, req, res, next){} 形式为错误处理函数，function(req, res, next){}
为正常的业务逻辑处理函数。因此通过 Function.length 来判断当前 handler 是否为容错函数，来做到参数的传入。

call 函数是 next 函数的核心，它是一个执行者，并在最后的逻辑中继续执行 next 函数，完成中间件的顺序调用。

NodeJS 的框架 express，实际就是 senchalabs connect 的升级版，通过对 connect
源码的学习，我们应该更加清楚流程的调度和控制，再去看 express 就轻而易举了。

Senchalabs connect 用流程控制库的回调函数及中间件的思想来解耦回调逻辑；Koa 则是用generator 方法解决回调问题（最新版使用
async/await）。事实上，也可以用事件、Promise 的方式实现，下一环节，我们就分析 Koa 的洋葱模型。

#### Koa 的洋葱模型

对 Koa 中间的洋葱模型的分析文章上不少，著名的洋葱圈图示我也不在自己画了，具体使用不再介绍，不了解的读者请先自行学习。

我想先谈一下面向切面编程（AOP），在 JavaScript 语言为例，一个简单的示例：

    
    
    Function.prorotype.before = function (fn) {
      const self = this
      return function (...args) {
        console.log('')
        let res = fn.call(this)
        if (res) {
          self.apply(this, args)
        }
      }
    }
    
    Function.prototype.after = function (fn) {
      const self = this
      return function (...args) {
        let res = self.apply(this, args)
        if (res) {
          fn.call(this)
        }
      }
    }
    

这样的代码实现，是我们能够在执行某个函数 fn 之前，先执行某段逻辑；在某个函数 fn
之后，再去执行另一段逻辑。其实是一种简单中间件流程控制的体现。不过这样的 AOP 有一个问题：无法实现异步模式。

那么如何实现 Koa 的异步中间件模式呢？即某个中间件执行到一半，交出执行权，之后再回来继续执行。我们直接看源码分析，这段源码实现了 Koa
洋葱模型中间件：

    
    
    function compose(middleware) {
      return function *(next) {(
        if (!next) next = noop();
    
        var i = middleware.length;
    
        while (i--) {
          next = middleware[i].call(this, next);
          console.log('isGenerator:', (typeof next.next === 'function' && typeof next.throw === 'function')); // true
        }
    
        return yield *next;
      }
    }
    
    function *noop(){}
    

其中，一个中间件的写法类似：

    
    
    app.use(function *(next){
      var start = new Date;
      yield next;
      var ms = new Date - start;
      this.set('X-Response-Time', ms + 'ms');
    });
    

这是一个很简单的记录 response time 的中间件，中间件跳转的信号是 yield next。

较新版本的 Koa 已经改用 async/await 实现，思路也是完全一样的，当然看上去更加优雅：

    
    
    function compose (middleware) {
      if (!Array.isArray(middleware)) throw new TypeError('Middleware stack must be an array!')
      for (const fn of middleware) {
        if (typeof fn !== 'function') throw new TypeError('Middleware must be composed of functions!')
      }
    
      return function (context, next) {
        let index = -1
        return dispatch(0)
    
        function dispatch (i) {
          if (i <= index) return Promise.reject(new Error('next() called multiple times'))
          index = i
          let fn = middleware[i]
          if (i === middleware.length) {
            fn = next
          }
          if (!fn) return Promise.resolve()
          try {
            return Promise.resolve(fn(context, function next () {
              return dispatch(i + 1)
            }))
          } catch (err) {
            return Promise.reject(err)
          }
        }
      }
    }
    

我们来重点解读一下这个版本的实现：

  * compose 传入的 middleware 参数必须是数组，否则抛出错误
  * middleware 数组的每一个元素必须是函数，否则抛出错误
  * compose 返回一个函数，保存对 middleware 的引用
  * compose 返回函数的第一个参数是 context，所有中间件的第一个参数就是传入的 context
  * compose 返回函数的第二个参数是 next 函数，next 是实现洋葱模型的关键
  * index 记录当前运行到第几个中间件
  * 执行第一个中间件函数：return dispatch(0)
  * dispatch 函数中，参数 i 如果小于等于 index，说明一个中间件中执行了多次 next，我们进行报错，由此可见一个中间件函数内部不允许多次调用 next 函数
  * 取出中间件函数 fn = middleware[i]
  * 如果 i === middleware.length，说明执行到了圆心，将 next 赋值给 fn
  * 因为 async 需要后面是 Promise，我们包一层 Promise
  * next 函数是固定的，它可以执行下一个中间件函数

    
    
    function next () {
      return dispatch(i + 1)
    }
    

如果读者不好理解，可以参考应用示例：

    
    
    async function middleware1(ctx, next) {
      console.log('1')
      await next()
      console.log('2')
    };
    
    async function middleware2(ctx, next) {
      console.log('3')
      await next()
      console.log('4')
    };
    

如果读者还是难以理解，我给出一个简版逻辑：

    
    
    function compose (middleware) {
      return dispatch(0) 
      function dispatch(i) {
        fn = middleware[i]
        if(!fn) return
        return fn(() => dispatch(i + 1))
      }
    }
    

#### co 库不再神秘

说到流程控制，也少不了大名鼎鼎的 co 库。co 函数库是 TJ 大神基于 ES6 generator 的异步解决方案，因此这里需要读者熟练掌握 ES6
generator。目前虽然 co 库可能不再“流行”，但是了解其实现，模拟类似场景也是非常有必要的。

我们这里不解读其源码，而是实现一个类似的自动执行 generator 的方案：

    
    
    const runGenerator = generatorFunc => {
      const it = generatorFunc()
      iterate(it)
    
      function iterate (it) {
        step()
    
        function step(arg, isError) {
          const {value, done} = isError ? it.throw(arg) : it.next(arg)
    
          let response
    
          if (!done) {
            if (typeof value === 'function') {
              response = value() 
            } else {
              response = value  
            }
    
            Promise.resolve(response).then(step, err => step(err, true))
          }
        }
      }
    }
    

代码解读：

  * runGenerator 函数接受一个生成器函数 generatorFunc
  * 运行 generatorFunc 得到结果，并通过 iterate 函数，迭代该生成器结果
  * iterate 函数中执行 step 函数，step 函数的第一个参数 arg 是上一个 yield 右表达式的“求出的值”，即下面对应的 response
  * 这里需要考虑 response 的求值过程，它通过 value 计算得来，value 是 yield 右侧的值，它有这么几种情况：
  * yield new Promise()，value 是一个 promise 实例，那么 response 就是该 Promise 实例 resolve 后的值
  * yield () => {return value}，value 是一个函数，那么 response 就是执行该函数后的返回值
  * yield value，value 是一个普通值，那么 response 就是该值
  * 我们最终统一利用 Promise.resolve 的特性，对 response 进行处理，并递归（迭代）调用 step
  * 同时利用 step 函数 arg 参数，赋值给上一个 yield 的左表达式值，并返回下一个 yield 右表达式的值

执行代码：

    
    
    function* gen1() {
      yield console.log(1)
      yield console.log(2)
      yield console.log(3)
    }
    
    runGenerator(gen1)
    

或者：

    
    
    function* gen2() {
      var value1 = yield Promise.resolve('promise')
      console.log(value1)
    
      var value2 = yield () => Promise.resolve('thunk')      
      console.log(value2)
    
      var value3 = yield 2
      console.log(value3)
    }
    
     runGenerator(gen2);
    

最后还是附上 co 的实现：

    
    
    function co(gen) { // co 接受一个 generator 函数
        var ctx = this
        var args = slice.call(arguments, 1)
    
        return new Promise(function(resolve, reject) { // co 返回一个 Promise 对象
            if(typeof gen === 'function') gen = gen.apply(ctx, args) // gen 为 generator 函数，执行该函数
            if(!gen || typeof gen.next !== 'function') return resolve(gen) // 不是则返回并更新 Promise状态为 resolve
    
            onFulfilled() // 将generator 函数的 next 方法包装成 onFulfilled，主要是为了能够捕获抛出的异常
    
            /**
              * @param {Mixed} res
              * @return {Promise}
              * @api private
             */
            function onFulfilled(res) {
                var ret;
                try {
                    ret = gen.next(res)
                } catch (err) {
                    return reject(err)
                }
                next(ret)
            }
    
            /**
              * @param {Error} err
              * @return {Promise}
              * @api private
             */
            function onRejected(err) {
                var ret
                try {
                    ret = gen.throw(err)
                } catch (err) {
                    return reject(err)
                }
                next(ret)
            }
    
            /**
              * Get the next value in the generator,
             * return a promise.
             *
             * @param {Object} ret
             * @return {Promise}
             * @api private
             */
            function next(ret) {
                if(ret.done) return resolve(ret.value)
                var value = toPromise.call(ctx, ret.value) // if (isGeneratorFunction(obj) || isGenerator(obj)) return co.call(this, obj);
                if(value && isPromise(value)) return value.then(onFulfilled, onRejected)
                return onRejected(new TypeError('You may only yield a function, promise, generator, but the following object was passed: ' + String(ret.value) + '"'))
            }
        })
    }
    

如果读者对于以上内容理解有困难，那么我建议还是从 generator 等最基本的概念切入，不必心急，慢慢反复体会。

### 总结

这道“著名”的“微信”面试题，绝不只是网上分析的几行代码答案那么简单，本讲我们从这道题目出发，分析了几种解决方案。更重要的是，在解决方案的基础上，我们重点剖析了
JavaScript 处理任务流程、控制触发逻辑的方方面面。也许在小型传统页面应用中，这样“相对复杂”的处理场景并不多见，但是在大型项目、富交互项目、后端
NodeJS 中非常重要，尤其是中间件思想、洋葱模型是非常典型的编程思路，希望读者能认真体会。

最后我们分析了 generator 以及 Koa 中间件实现原理，也许读者在平时基础业务开发中接触不到这些知识，但是请想一想 redux-saga
的实现、中间件的编写，其实都是这些内容运用体现。进阶即是如此，如果不掌握好这些“难啃”的知识，那么永远无法写出优秀的框架和解决方案。



## 离不开的网络基础

开启本讲之前，我想先问一句：“网络基础对于前端程序员重不重要”？其实答案是毫无疑问的，如果读者仍然对此有怀疑，那可能你还是刚入行的程序员，相信随着工作经验的增加，你会越来越能意识到网络基础的重要性。事实上，具备必要的网络基础，是对于一个程序员的要求，绝不仅仅是对前端工程师的要求，更何况在
Node.js 发展当下，学好网络知识更是对于前途发展意义重大。

网络基础其实并不难，但绝不仅仅是一讲的内容就能“融会贯通”的，系统性地学习还需要回炉到大学课本。本讲，我从网络基础概念和场景应用两大方面来讲解，主要内容如下：

![1](https://images.gitbook.cn/568aafc0-e263-11e9-a074-f5ff05024c30)

### 网络基础知识

有一个说法——“大厂前端面试对 HTTP 的要求比 CSS 还要高”，确实从面试的频率上，以 HTTP
为核心的网络基础考察绝对是重点。这些考察点其实并不难，都是基础概念，我们先从几个高频考点入手。

更为基础的内容，比如计算机网络体系结构，OSI 七层协议等我们不再提及，必要知识需要读者先行了解。

#### TCP 和 UDP

TCP 和 UDP 是运输层的两种协议，什么是运输层呢？

> 运输层（Transport
Layer）就是负责向两台主机进程之间的通信提供通用的数据传输服务，应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。

对于 TCP 和 UDP 这两种协议的理解，我们可以主要从其特点和区别来掌握。

传输控制协议 TCP（Transmisson Control Protocol）是一种 **面向连接的、可靠的** 数据传输服务。如何理解可靠呢？通过
TCP
协议传送数据可以无差错、不丢失、不重复、并且按序到达；如何理解面向连接呢？就像我们打电话一样，通过拿起电话和挂掉电话来表示连接的建立和中断。此外，TCP
的特点有：

  * TCP 提供全双工通信，也就是说双方在连接建立之后，都可以在任何时候进行数据发送
  * TCP 两端连接都设有缓存，在发送和接收时都可以利用缓存临时存放数据
  * TCP 是面向字节流的

用户数据协议 UDP（User Datagram Protocol）是一种 **无连接的、不保证数据传输的可靠性** 的运输层协议。其特点：

  * UDP 无连接
  * UDP 不保证可靠性，因此不需要维持复杂的链接状态
  * UDP 是面向报文的
  * UDP 没有拥塞控制
  * UDP 支持一对一、一对多、多对一和多对多的交互通信

因此根据 TCP 和 UDP 的特点，可以选择不同的协议进行场景应用，比如对于直播、实时视频会议，你认为哪种协议更加适合呢？

因为 UDP 传输速度更快、效率更高，UDP
没有拥塞控制，所以网络出现拥塞不会使源主机的发送速率降低，且直播、实时视频会议丢失一两帧内容对于应用并没有体验性的影响，因此，UDP
对于直播、实时视频会议的场景会更加适合。

**这些内容对应的面试考点：**

  * 比较 TCP 和 UDP
  * TCP 和 UDP 的应用场景
  * TCP 如何保证传输的可靠性

前两项考点我们已经有所涉及，现在针对 TCP 如何保证传输的可靠性进行展开。TCP 保证传输的可靠性主要手段有以下几个。

  * 数据包校验：如果接收端校验出包有错，则进行丢弃且不进行相应。
  * 对失序数据包重排序：TCP 协议会对失序数据包进行排序，然后再交给应用层。
  * 丢弃重复数据。
  * 应答机制：当接收端接收到数据之后，将发送确认信息。
  * 超时重发：当发送端发出数据后，它启动一个定时器，如果超出计时器的时限，将重发这个报文段。
  * 流量控制：前面提到过，TCP 连接的每一方都有固定大小的缓冲空间，可防止接收端缓冲区溢出，这就是流量控制。TCP 使用可变大小的滑动窗口协议来进行流量控制。

最后再补充一点单工/半双工/双工数据通信的概念区分：

  * 单工数据传输是数据只能在一个方向上传输；
  * 半双工数据传输允许数据在两个方向上传输，但是，在某一时刻，只允许数据在一个方向上传输，它实际上是一种切换方向的单工通信；
  * 全双工数据通信允许数据同时在两个方向上传输，因此，全双工通信是两个单工通信方式的结合，它要求发送设备和接收设备都有独立的接收和发送能力。

#### 三次握手和四次挥手

上面我们说到 TCP 是面向连接的，那么这个连接过程就涉及到著名的三次握手和四次挥手了。也许对于这些名词我们已经“听烂了”，但是你是否有真正的掌握呢？

三次握手，简单来说是指当建立一个 TCP 连接时，整个建立过程需要客户端和服务端一共交互三个包，三次握手的目的是连接服务器的指定端口，建立 TCP
连接，并同步连接双方的序列号和确认号并交换 TCP 窗口大小信息。

![1](https://images.gitbook.cn/f192a820-e267-11e9-bb4c-7169754434c1)

具体来说 **第一次握手**

开始建立连接时，客户端向服务器发出连接请求报文，报文首部中的同部位 SYN = 1，同时选择一个初始序列号 seq = x ，这时客户端进程进入了 SYN-
SENT （同步已发送状态）状态，等待服务器确认。

**第二次握手**

服务器收到 syn 包后，如果同意连接，则发出确认报文；确认报文 ACK = 1，SYN = 1，确认号是 ack = x +
1，同时也要为自己初始化一个序列号 seq = y，此时服务器进程进入了 SYN-RCVD（同步收到）状态。

**第三次握手**

客户端收到服务器的 SYN + ACK 包，要向服务器给出确认。确认报文的 ACK = 1，ack = y + 1，自己的序列号 seq = x +
1。此时，TCP 连接建立，客户端进入 ESTABLISHED （已建立连接）状态。

四次挥手是指，TCP 连接的终端需要客户端和服务端总共发送四个包，客户端或者服务器端均可主动发起挥手动作。

![2](https://images.gitbook.cn/08126450-e268-11e9-9514-611dbba450a7)

具体来说， **第一次挥手**

客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部 FIN = 1，其序列号为 seq = u（等于前面已经传送过来的数据最后一个字节的序号加
1）。此时，客户端进入 FIN-WAIT-1（终止等待 1）状态。

**第二次挥手**

服务器收到连接释放报文，发出确认报文，ACK = 1，ack = u + 1，并且带上自己的序列号 seq =
v（客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受），此时，服务端就进入了 CLOSE-WAIT（关闭等待）状态。

**第三次挥手**

服务器将最后的数据发送完毕后，就向客户端发送连接中断报文，FIN = 1，ack = u +
1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为 seq = w，此时，服务器就进入了 LAST-
ACK（最后确认）状态，等待客户端的确认。

**第四次挥手**

客户端收到服务器的连接释放报文后，必须发出确认，ACK = 1，ack = w + 1，而自己的序列号是 seq = u + 1。此时，客户端就进入了
TIME-WAIT（时间等待）状态。

服务器只要收到了客户端发出的确认，立即进入 CLOSED 状态。同样，撤销 TCB 后，就结束了这次的 TCP 连接（注意此时 TCP
连接还没有释放，必须经过 2MSL（最长报文段寿命）的时间后，当客户端撤销相应的 TCB 后，才进入 CLOSED
状态）。服务器只要收到了客户端发出的确认，立即进入 CLOSED 状态。同样，撤销 TCB 后，就结束了这次的 TCP 连接。

**这些内容对应的面试考点：**

  * 三次握手和四次挥手过程
  * 三次握手和四次挥手的必要性，不做行不行？

#### HTTP 响应常见状态码

HTTP 响应常见状态码这里只做一个速查总结。

  * 100-199：表示成功接收请求, 要求客户端继续提交下一次请求才能完成整个处理过程，常见的有 101（客户要求服务器转换 HTTP 协议版本）、100（客户必须继续发出请求）
  * 200-299：表示成果接收请求并已完成整个处理过程
  * 300-399：需要客户进一步细化需求，以进一步完成请求，常用的有 301（永久重定向）、302（临时重定向）、304（缓存相关）
  * 400-499：请求出错，包含语法错误或者无法正确执行逻辑，常用的有 404（无对应资源）、401（权限问题）、403 （服务器拒绝请求）
  * 500-599：服务器端程序处理出现错误，常见的有 502（错误网关）、504（网关超时）、505（HTTP 版本不受支持）

列举更加具体的状态码说明，出自：[HTTP Status
Code](https://juejin.im/entry/586b5b7dac502e12d62b4f33)

    
    
    100     //继续 请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分
    101     //切换协议  请求者已要求服务器切换协议，服务器已确认并准备切换
    
    200     //成功  服务器已经成功处理了请求，通常，这表示服务器提供了请求的网页
    201     //已创建  请求成功并且服务器创建了新的资源
    202     //已接受  服务器已接受请求，但尚未处理
    203     //非授权信息  服务器已经成功处理了请求，但返回的信息可能来自另一来源
    204     //无内容  服务器成功处理了请求，但没有返回任何内容
    205     //重置内容  服务器成功处理了请求，但没有返回任何内容
    206     //部分内容  服务器成功处理了部分 GET 请求
    
    300     //多种选择  针对请求，服务器可执行多种操作。服务器可根据请求者（user agent）选择一项操作，或提供操作列表供请求者选择
    301     //永久移动  请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置
    302     //临时移动  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求
    303     //查看其他位置  请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码
    304     //未修改  自动上次请求后，请求的网页未修改过。服务器返回此响应，不会返回网页的内容
    305     //使用代理  请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理
    307     //临时性重定向  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有的位置来进行以后的请求
    
    
    400     //错误请求  服务器不理解请求的语法
    401     //未授权  请求要求身份验证。对于需要登录的网页，服务器可能返回此响应
    403     //禁止  服务器拒绝请求
    404     //未找到  服务器找不到请求的网页
    405     //方法禁用  禁用请求中指定的方法
    406     //不接受  无法使用请求的内容特性响应请求的网页
    407     //需要代理授权  此状态码与401（未授权）类似，但指定请求者应当授权使用代理
    408     //请求超时  服务器等候请求时发生超时
    409     //冲突  服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息
    410     //已删除  如果请求的资源已永久删除，服务器就会返回此响应
    411     //需要有效长度  服务器不接受不含有效内容长度标头字段的请求
    412     //未满足前提条件  服务器未满足请求者在请求者设置的其中一个前提条件
    413     //请求实体过大  服务器无法处理请求，因为请求实体过大，超出了服务器的处理能力
    414     //请求的URI过长  请求的URI（通常为网址）过长，服务器无法处理
    415     //不支持媒体类型  请求的格式不受请求页面的支持
    416     //请求范围不符合要求  如果页面无法提供请求的范围，则服务器会返回此状态码
    417     //未满足期望值  服务器未满足“期望”请求标头字段的要求
    
    500     //服务器内部错误  服务器遇到错误，无法完成请求
    501     //尚未实施  服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码
    502     //错误网关  服务器作为网关或代理，从上游服务器无法收到无效响应
    503     //服务器不可用  服务器目前无法使用（由于超载或者停机维护）。通常，这只是暂时状态
    504     //网关超时  服务器作为网关代理，但是没有及时从上游服务器收到请求
    505     //HTTP 版本不受支持  服务器不支持请求中所用的 HTTP 协议版本
    

**这些内容对应的面试考点：**

  * 状态码的熟悉程度
  * 缓存相关状态码
  * Restful 相关内容

#### HTTP 请求方法

常见的 HTTP 请求方法有以下几个。

  * GET 方法：该方法发送请求来取得服务器上的资源，一般来说 GET 方法应该只用于数据的读取，而不应当用于会产生副作用的非幂等的操作中。
  * POST 方法：该方法向将指定资源的最新数据传送给服务器取代指定的资源的内容，POST 方法是非幂等的方法，因为这个请求可能会创建新的资源或 / 和修改现有资源。
  * PUT 方法：类似 POST 方法，该方法指定了资源在服务器上的位置，进行数据提交或数据更新
  * PARTCH 方法：该方法出现的较晚，它在 2010 年的 RFC 5789 标准中被定义。一般用于资源的部分更新，而 PUT 一般用于资源的整体更新。另外，当资源不存在时，PATCH 会创建一个新的资源，而 PUT 只会对已在资源进行更新。
  * HEAD 方法：该方法只请求页面的首部，也就是说服务端的返回不含内容部分。这个方法，允许我们可以不传输全部内容的情况下，就可以获取服务器的响应头信息。HEAD 方法常被用于客户端查看服务器的性能。
  * DELETE 方法：该方法删除服务器上的某资源或者数据。
  * OPTIONS 方法：该方法用于获取指定服务能够支持的方法。当请求成功时，客户端会得到相关头部信息，指定了服务能够支持的方法，比如“GET、POST”等。JavaScript 的 XMLHttpRequest 对象进行 CORS 跨域资源共享时，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限。
  * TRACE 方法：被用于激发一个远程的，应用层的请求消息回路，该方法主要用于 HTTP 请求的测试或诊断。
  * CONNECT 方法：HTTP/1.1 协议预留的，能够将连接改为管道方式的代理服务器。通常用于 SSL 加密服务器的链接与非加密的 HTTP 代理服务器的通信。

我们再从 HTTP 方法的安全性和幂等性角度来进行总结：

  * 安全性是说 **多次调用不会产生副作用** ，换句话说， **安全的方法不会修改资源状态；**
  * 幂等性，是指该方法 **多次调用返回的效果（形式）一致** ，客户端可以重复调用并且期望同样的结果。

![3](https://images.gitbook.cn/25525660-e268-11e9-9514-611dbba450a7)

**这些内容对应的面试考点：**

  * GET/POST 区别
  * OPTIONS 理解，以及跨域相关内容
  * Restful 相关内容

#### 如何理解 HTTP 协议是无状态的

综合以上内容，我们来分析一个面试常考题目：如何理解 HTTP 协议是无状态的？

我们之所以说 HTTP 协议是无状态的，其实指的是客户端和服务器的通信，每个请求之间是独立的，指的是 HTTP 协议对于独立的请求是没有记忆能力的。

通俗点说，我们的应用发送一个请求，和下一次再打开该应用，发送同一个请求，这些请求之间没有任何联系。 **HTTP 是一个无状态的面向连接的协议**
，但是无状态不代表 HTTP 不能保持 TCP 连接，更不能代表 TCP 不是面向连接的。

#### 其他概念

这一讲不再做更多 HTTP 内容的介绍，更多 HTTP 的知识会在《HTTP 的深思：我从何而来，去向何处》中继续说明。我们来看一些更多的概念。

#### 域名系统

域名系统（Domain Name System，DNS）是因特网的一项核心服务，它作为可以将域名和 IP
地址相互映射的一个分布式数据库，能够使人更方便地访问互联网，而不用去记住能够被机器直接读取的 IP 数串。

比如我们经常访问的网站，其域名就相当于其门牌地址，比如 IBM 公司的域名是 www.ibm.com；Cisco 公司的域名是
www.cisco.com。因此对每一个网站进行访问时，都需要对域名和对应的 IP 地址进行映射，具体过程：

  * 先过浏览器搜索自己的 DNS 缓存（可以使用 chrome://net-internals/#dns 来进行查看）
  * 上一步未找到对应缓存的 IP 地址时，搜索操作系统中的 DNS 缓存
  * 上一步未找到对应缓存的 IP 地址时，操作系统将域名发送至 LDNS（本地区域名服务器），LDNS 查询 自己的 DNS 缓存（一般查找成功率在 80% 左右），查找成功则返回结果，失败则发起一个迭代 DNS 解析请求，为什么说这是迭代的 DNS 解析请求呢？这个过程
    * LDNS 向 Root Name Server（根域名服务器，如 com、net、org 等解析顶级域名服务器的地址）发起请求，此处，Root Name Server 返回 com 域的顶级域名服务器地址
    * LDNS 向 com 域的顶级域名服务器发起请求，返回 baidu.com 域名服务器地址
    * LDNS 向 baidu.com 域名服务器发起请求，得到 www.baidu.com 的 IP 地址 LDNS 将得到的 IP 地址返回给操作系统，同时自己也将 IP 地址缓存起来
  * 操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来

DNS 解析整个过程，分为：递归查询过程和迭代查询过程。

读者可以通过：

    
    
    cat /etc/resolv.conf 
    

获取本机 DNS 配置，我的内容为：

![4](https://images.gitbook.cn/b319a7f0-e268-11e9-b138-7fd562c24e16)

再通过：

    
    
    dig +trace XXX.com
    

来查看完整的分级查询过程：

![5](https://images.gitbook.cn/c7d211a0-e268-11e9-bb4c-7169754434c1)

**这些内容对应的面试考点：**

  * 域名系统相关工作方式
  * 顶级域名、一级域名、二级域名概念

最后，需要说明的是 DNS 使用无连接的 UDP
协议来进行查询，这样的方式降低了开销，也使得速度更快，保证了高效的通信，但是没有太考虑安全问题。它使用目的端口为 53 的 UDP
明文进行通信，这也带来了诸如 DNS 欺骗、DNS Cache 污染、DNS 放大攻击等问题，一些“黑心”运营商就可以利用这一点达到一些别用用心的目的。

针对于此，DNSSec（Domain Name System Security
Extensions，也叫「DNS安全扩展」）机制便诞生了，这个机制会让客户端对域名来源身份进行验证，并且检查来自 DNS
域名服务器应答记录的完整性，以及验证是否在传输过程中被篡改过。总之域名系统的安全性话题已经不可忽视。

#### 跨域

跨域其实是浏览器的行为，狭义上说，它指的是浏览器无法执行其他网站的脚本。为什么无法执行呢？这要由浏览器的同源策略说起，简单来说，跨域是浏览器对
JavaScript 施加的安全限制。

> 同源策略（Same Origin Policy）是一种约定，由 Netscape 公司 1995
年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到 XSS、CSFR 等攻击。

我们都知道，所谓同源，是指“协议、域名、端口”这三要素都相同，在非同源的情况下，以下行为会收到限制：

  * 对 Cookie、LocalStorage 和 IndexDB 的读取
  * 对 DOM 和 JS 对象的读取
  * Ajax 请求的正常执行

关于解决跨越方案的内容市面上的资料讲解较多，我们这里不再赘述。

##### **代理和网关**

在 NodeJS
“攻城略地”的背景下，前端开发者越来越多地接触到了代理和网关的概念。代理简单来说，是一种有转发功能的应用程序，它扮演了位于两端之间“中间人”的角色。比如在我的一个项目中，公司内部中台有基于
StatsD（StatsD 就是一个简单的网络守护进程，基于 Node.js 平台，通过 UDP 或者 TCP
方式侦听各种统计信息）的数据收集和统计系统，因为 StatsD 是基于 TCP/UDP 的，因此为了在 C 端统计用户行为，我设计了在 NodeJS
层的一个代理机制，对 C 端上报数据进行简单的接受和分发。

网关是转发其他服务器通信数据的服务器，当接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理，其工作机制和代理类似，但网关能力可能更加强大，它不是提供一个单一服务，而是能给通信链路提供平台化的服务，比如鉴权等内容。

更多应用我们暂不展开，本讲会把更多精力放在网络基础知识的学习上。这里只需要读者明白，前端 BFF
层，或代理层，越来越需要开发者对于网络基础知识的理解和运用。

##### URI VS URL

很多开发者并不理解 URI 和 URL 的区别，从名称上来看：

  * URL，统一资源定位符
  * URI，统一资源标识符

通俗来说，URL 像是一个邮政编码，URI 就是收件地址。因此可知，URL 的范围大于
URI。我们以淘宝的例子来说，https://www.taobao.com/ 这个域名就是 URL，而每个商品的地址就是一个 URI。

很多 Ajax 请求库的参数都设计成叫做 url，表示请求地址。但实际上，更准确的表达是 URI。

### 网络相关应用

这部分我们来看一些网络知识的应用，同时剖析一些案例。

#### NodeJS 和 TCP

在 NodeJS 中，我们可以很轻松地实现一个基于 TCP 的数据通信过程，主要依赖 net 模块：

    
    
    let net = require('net')
    
    let server = net.createServer(socket => {
        console.log('客户端已经链接')
        console.log(socket.address())
    })
    
    server.listen('8080', () => {
        /* 获取地址信息，得到的是一个json { address: '::', family: 'IPv6', port: 8000 } */
        const address = server.address()
    
        /* TCP 服务器监听的地址 */
        console.log(`the port of server is ${address.port}`)
    
        /* IPv6 还是 IPv4 */
        console.log(`the family of server is ${address.family}`)
    })
    
    server.getConnections((err,count) => {
        console.log(`已经链接 ${count} 个用户`)
    })
    
    server.maxConnections = 2
    

这样就使用 NodeJS 创建了一个简单的 TCP 服务器，并设置了最大连接数，监听客户端链接数量，以及对事件的处理等。

也可以利用 socket.write 进行 TCP 服务器的数据发送：

    
    
    var net = require("net")
    
    /* 创建 TCP 服务器 */
    let server = net.createServer(socket => {
        var address = server.address()
        var message = `the server address is ${JSON.stringify(address)}`
    
        socket.write(message, () => {
            let writeSize = socket.bytesWritten
            console.log(`${message} has send, the size is ${writeSize}`)
        })
    
        socket.on('data', (data) => {
            console.log(data.toString())
            const readSize = socket.bytesRead
            console.log(`the size of data is ${readSize}`)
        })
    })
    
    server.listen(8000, () => {
        console.log("Creat server on http://127.0.0.1:8000/")
    })
    

我们也可以用 NodeJS 来构建一个 TCP 客户端，实现 TCP 客户端和 TCP 服务器的通信，这里就不再展开了。

#### NodeJS 和 UDP

关于 NodeJS 实现 UDP 通信，我们需要依靠 dgram 模块，dgram 模块提供了 UDP 数据包 socket 的实现。先看 UDP
server 的创建，创建 server.js 文件：

    
    
    const dgram = require('dgram')
    
    // 创建 UDP server
    let udpServer = dgram.createSocket('udp4')
    // 绑定端口
    udpServer.bind(5678)
    
    // 监听端口
    udpServer.on('listening', () => {
        console.log('udp server linstening 5678.')
    })
    
    //接收消息
    udpServer.on('message', (message, rinfo) => {
        const messageStr = message.toString()
        udpServer.send(messageStr.toString(), 0, messageStr.length, rinfo.port, rinfo.address)
        console.log(`udp server received data: ${messageStr} from ${rinfo.address}:${rinfo.port}`)
    })
    
    //错误处理
    udpServer.on('error', err => {
        console.log('some error on udp server.')
        udpServer.close()
    })
    

创建 UDP Client，创建 client.js：

    
    
    const dgram = require('dgram')
    let udpClient = dgram.createSocket('udp4')
    
    udpClient.on('close', () => {
        console.log('udp client closed.')
    })
    
    // 错误处理
    udpClient.on('error', () => {
        console.log('some error on udp client.')
    })
    
    // 接收消息
    udpClient.on('message', (message, rinfo) => {
        console.log(`receive message from ${rinfo.address}: ${rinfo.port}: ${message}`)
    })
    
    // 定时向服务器发送消息
    setInterval(() => {
        const sendStr = 'hello.'
        const sendStrLen = sendStr.length
        udpClient.send(sendStr, 0, sendStrLen, 5678, '172.30.20.10')
    }, 3000)
    

在上述代码中，读者可以在 UDP Client 结尾处配置好自己的 IP 地址，并启动：

    
    
    node server.js
    node client.js
    

观察 NodeJS 应用状况。

#### 短网址功能实现

常用微博或者关注运营需求的读者应该知道短网址功能：

![6](https://images.gitbook.cn/e28fecb0-e268-11e9-8cc6-d3303f1d15c4)

简单来说，短网址工具可以将一长串 URL
地址转换成简短的、可访问的短链接形式。自微博盛行以来，在微博字数有限的特色下，短链接盛行于微博网站，以节省微博字数，给博主发布更多文字的空间。

那么一个短网址生成平台该怎么设计呢？其实原理很简单：

  * 用户输入完整网址，服务端接收到完整网址之后，根据算法生成一个短码，维护完整网址和短码的映射关系，并将短码完善成短网址，返回给客户端；
  * 任意客户端访问短网址，服务端根据完整网址和短码的映射关系，重定向到对应的页面。

我们看到了熟悉的三个字：重定向，请读者思考这里的重定向应该对应哪个 HTTP 状态码呢？

我们应该在 302 和 301 中进行选择：从语义上看，短网址对应完整网址的映射关系和跳转关系不会发生变化，应该是 301
永久重定向才对。但是更多的短网址生成平台却采用了 302，这是为什么呢？

引自知乎网友的回答，[原文链接](https://www.zhihu.com/question/20103344/answer/573638467)。

> 如果用了 301，Google、百度等搜索引擎，搜索的时候会直接展示真实地址，那我们就无法统计到短地址被点击的次数了，也无法收集用户的
Cookie、User Agent 等信息，这些信息可以用来做很多有意思的大数据分析，也是短网址服务商的主要盈利来源。

完整的设计我们可以借助 MySQL 和 Redis 实现完整网址和短码之间的映射关系。生成短码的算法主要可以考虑以下几种：

  * 自增 id，然后将 id 值转换为 62 进制的字符串，为了解决短码长度不固定的问题，可以指定数字开始递增。同时为了解决短码有序的安全隐患，可以结合 md5 进行混淆。一种实现为：

    
    
    const string10to62 = number => {
        const chars = '0123456789abcdefghigklmnopqrstuvwxyzABCDEFGHIGKLMNOPQRSTUVWXYZ'
    
        const charsArr = chars.split('')
        const radix = chars.length
        let qutient = +number
        let arr = []
    
        do {
            let mod = qutient % radix
            qutient = (qutient - mod) / radix
            arr.unshift(charsArr[mod])
        }
        while(qutient)
    
        return arr.join('')
    }
    

  * 哈希算法，直接输入任意长度的数据，输出固定长度的数据，这种算法比较典型，不再过多介绍
  * 随机数：从 62 个字符串中随机取出固定长度的短码组合，然后去数据库中查询该短码是否已存在。如果已存在，就继续循环该方法重新获取短码，否则就直接返回。这种方法最为简单，但是得到碰撞的概率相对较大，一种实现为：

    
    
    const generateShortLink = () => {
        let str = ''
        const arr = [
            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
        ]
    
        for (let i = 0; i < 6; i++) {
            const pos = Math.round(Math.random() * (arr.length - 1))
            str += arr[pos]
        }
        return str
    }
    
    async getShortLink() {
        const shortLink = this.generateShortLink()
    
        const searchResult = await this.searchByLinkInMySQL(shortLink)
    
        if (searchResult && searchResult.length > 0) {
            return this.getShortLink();
        }
        return shortLink
    }
    

这一部分应用的分析，参考了社区
[shortLink](https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fliucong1%2FshortLink)
的实现和分析内容。读者可进行进一步研究。

#### 扫码登录实现

另外一个我们要介绍的实现是扫码登录，现在授权第三方的扫码登录越来越流行。比如我们可以通过微信实现在第三方应用的登录、注册账号等，这种共用账号体系的能力究竟是如何实现的呢？

其实原理同样并不复杂：

  * 首先打开 PC 端页面，PC 端页面生成一个二维码，这个二维码带有服务端下发的一个唯一 id：uuid
  * 接着，手机在微信账号中进行扫码，发送请求，请求包含了上面提到的 uuid 和当前用户的账号信息
  * 与此同时，PC 端不断轮询服务器（或者通过 websocket，服务端主动 push 信息），获取扫码登录的状态
  * 服务端返回扫码状态

针对手机扫码后服务端的返回情况，我们进行梳理：

  * PC 端在轮询时，如果扫码超时（手机没有授权登录或者就没扫码），服务端会阻塞一个时限（比如 30s），30s 内无响应，服务端返回状态码 408，得到返回后，前端继续轮询
  * 大约 5 分钟内仍然没有扫码响应，则二维码失效，这时候服务端返回 400
  * 如果手机端扫码成功，服务端返回 201 同时并返回用户信息，并等待用户点击“确认授权登录”
  * 用户“确认授权登录”之后，服务端返回 200 同时返回一个 token；PC 端在拿到下响应后，重定向到目标页面，同时停止轮询

关键理解点：

  * 扫码登录一共涉及到三端：服务端、PC 端和手机扫码端
  * PC 端通过轮询，不断向服务端获取用户扫码登录的状态
  * 服务端阻塞 PC 端请求，这样可以减少 PC 端轮询的次数，优化轮询过程
  * 服务端根据手机扫码状态，返回 408、400、201、200 等状态码

#### 断点续传原理

对于大文件的传输/下载，我们常常采用断点续传原理。想象一下在使用迅雷、网盘上传文件内容时，如果网络条件出现问题，我们仍然可以稍后继续进行上传/下载而不至于丢失之前的上传/下载进度。这种断点续传的能力究竟是如何实现的呢？

实现断点续传，需要依靠 HTTP1.1 协议（RFC2616），该协议版本开始支持获取文件的部分内容，这为并行下载以及断点续传提供了技术支持。

在前端发送请求时，需要在 Header 里加入 Range 参数，同时服务器端响应时返回带有 Content-Range 的 Header，也就是说
Range 和 Content-Range 是一对对应的 Header 头。

比如：

    
    
    Range: bytes=500-999 
    

就表示上传第 500-999 字节范围的内容，而浏览器在发出带 Range 的请求后，服务器会在 Content-Range
头部返回当前接受的范围和文件总大小，比如：

    
    
    Content-Range: bytes 0-499/22400
    

就指当前发送数据的范围是 0-499，22400 则是文件的总 size。

我们来看一个例子：

  * 浏览器下载一个 1024K 的文件，当前已经下载了 512K
  * 这时候不幸网络故障，稍后浏览器请求续传，这时候带有 Range:bytes=512000 的 Header 头，表明本次需要续传的片段
  * 服务端接收到断点续传的请求，从文件的 512K 位置开始传输，并返回 Header 头： Content-Range:bytes 512000-/1024000，注意这时候的 HTTP status code 是 206，而非 200，206 表示：206 Partial Content（使用断点续传方式）

请读者思考一个问题，如果在网络故障期间，服务器端文件发生了变化，导致 512K 部分并不能对上之前的内容，这个怎么办呢？

这时候就需要一个标识文件唯一性的标识符。RFC2616 中规定可以使用 Last-Modified
顾名思义，这样就可以标识文件的最后修改时间，浏览器就可判断出续传文件时是否已经发生过改动。这种方式并不惟一，也可以通过名为 Etag 的
Header，直接表文件的唯一标记（类似文件的 MD5 值）。浏览器端请求时申明 If-None-Match 或者 If-Modified-Since
字段，帮助服务端判别文件变化，同时浏览器也可以采用 If-Range Header，该头部包含 ETag 头或者是 Last-Modfied
信息，同样可以帮助服务端进行内容校验。这时候，服务端在校验一致时返回 206 的续传回应校验不通过时，服务端则返回 200
回应，回应的内容为新的文件的全部数据。

### 总结

本讲我们以面试为切入点，总结了网络基础知识的多个方面。其中一些知识比较基础，但根据我观察，很多面试者都会在这些基础内容上“折腰”。网络知识是一个系统性的知识体系，还需要每一个开发者认真学习。也许你有体会：“在大学里学习网络知识时，很多概念很难真正理解”，而工作后有一定实战经验了，但是“很多网络内容又缺少了理论的支持”。因此关于网络的学习，我认为一定要理论结合实践。这些计算机基础内容，是一个开发者真正进阶的基本功。



## 缓存谁都懂，一问都哑巴（上）

缓存是网络世界中非常重要的一环，也是解决性能问题最常用的手段之一。说起缓存这个概念，貌似谁都可以说上两句，但又不能完全面面俱到；你可能听说过 etag 或者
if-modified-since
这样的头部，可是并不能梳理好所有这些头部的关系；你可能观察过某个网站或者请求的缓存策略，但是并没有亲自设计并应用个缓存机制；你可能在面试中被问起，在实际开发中踩过坑。

我们将用两节课，彻底梳理缓存知识的方方面面，亲自动手配置尝试，打消那些似懂非懂。主要内容如下：

![0](https://images.gitbook.cn/14a4f400-e270-11e9-bb4c-7169754434c1)

### 缓存概念与分类

其实缓存是一个很“大”的概念，尤其 Web 缓存分为很多种。比如：

  * 数据库缓存
  * （代理）服务器缓存
  * CDN 缓存
  * 浏览器缓存

甚至一个函数的执行结果都可以进行缓存。而我们要分析的就是 HTTP 缓存，或者浏览器缓存

HTTP 缓存的官方概念：

> HTTP 缓存（或 Web 缓存）是用于临时存储（缓存）Web文档（如 HTML 页面和图像），以减少服务器延迟的一种信息技术。HTTP
缓存系统会保存下通过这套系统的文档的副本；如果满足某些条件，则可以由缓存满足后续请求。HTTP 缓存系统既可以指设备，也可以指计算机程序。

《HTTP 权威指南》一书中，这样介绍到缓存：

>
在前端开发中，性能一直都是被大家所重视的一点，然而判断一个网站的性能最直观的就是看网页打开的速度。其中提高网页反应速度的一个方式就是使用缓存。一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷。那么下面我们就来看看服务器端缓存的原理。

目前网络应用中很少有不接入缓存的案例。缓存之所以这么重要，是因为它能带来非常多的好处：

  * 使得网页加载和呈现速度更快
  * 减少了不必要的的数据传输，因而节省网络流量和带宽
  * 在上一步的基础上，服务器的负担因此减少

事实上，前两点非常好理解，合理地使用缓存，能够最大限度地读取和利用本地已有的静态资源，减少了数据传输，加快了网页应用的呈现。对于第三点，可能一两个用户的访问对于减小服务器的负担没有明显效果。但请设想高并发的场景，使用缓存对于减小服务器压力非常有帮助。

对于浏览器缓存的分类，分类方式有很多，按缓存位置分类，我们有：

  * memory cache
  * disk cache
  * Service Worker 等

浏览器的资源缓存分为 from disk cache 和 from memory cache
两类。当首次访问网页时，资源文件被缓存在内存中，同时也会在本地磁盘中保留一份副本。当用户刷新页面，如果缓存的资源没有过期，那么直接从内存中读取并加载。当用户关闭页面后，当前页面缓存在内存中的资源被清空。当用户再一次访问页面时，如果资源文件的缓存没有过期，那么将从本地磁盘进行加载并再次缓存到内存之中。

关于 from disk cache 和 from memory cache 的区别：

> When you visit a URL in Chrome, the HTML and the other assets(like images)
on the page are stored locally in a memory and a disk cache. Chrome will use
the memory cache first because it is much faster, but it will also store the
page in a disk cache in case you quit your browser or it crashes, because the
disk cache is persistent.

翻译：

>
当您访问chrome中的URL时，页面上的HTML和其他资产（如图像）将本地存储在内存和磁盘缓存中。Chrome将首先使用内存缓存，因为它的速度快得多，但它也会将页面存储在磁盘缓存中，以防您退出浏览器或它崩溃，因为磁盘缓存是持久的。

如果按失效策略分类，我们有：

  * 强缓存
  * 协商缓存

![1](https://images.gitbook.cn/0f95a6a0-e269-11e9-bb4c-7169754434c1)

缓存策略是理解缓存的最重要一环，我们这节课重点了解一下强缓存和协商缓存。说到底缓存最重要的核心就是解决 **什么时候使用缓存，什么时候更新缓存** 的问题。

#### 强缓存

强缓存是指客户端在第一次请求后，有效时间内不会再去请求服务器，而是直接使用缓存数据。

那么这个过程，就涉及到一个缓存有效时间的判断。在有效时间判断上，HTTP 1.0 和 HTTP 1.1 是有所不同的。

HTTP 1.0 版本规定响应头字段 Expires，它对应一个未来的时间戳。客户端第一次请求之后，服务端下发 Expires
响应头字段，当客户端再次需要请求时，先会对比当前时间和 Expires 头中设置的时间。如果当前时间早于 Expires
时间，那么直接使用缓存数据；反之，需要再次发送请求，更新数据。

响应头如：

    
    
    Expires:Tue, 13 May 2020 09:33:34 GMT
    

上述 Expires 信息告诉浏览器：在 2020.05.13 号之前,可以直接使用该文本的缓存副本。

Expires 为负数，那么就等同于 no-cache，正数或零同 max-age 的表意是相同的。

但是使用 Expires 响应头存在一些小的瑕疵，比如：

  * 可能会因为服务器和客户端的 GMT 时间不同，出现偏差
  * 如果修改了本地时间，那么客户端端日期可能不准确
  * 写法太复杂，字符串多个空格，少个字母，都会导致非法属性从而设置失效

在 HTTP 1.1 版本中，服务端使用 Cache-control 这个响应头，这个头部更加强大，它具有多个不同值：

  * private：表示私有缓存，不能被共有缓存代理服务器缓存，不能在用户间共享，可被用户的浏览器缓存。
  * public：表示共有缓存，可被代理服务器缓存，比如 CDN，允许多用户间共享
  * max-age：值以秒为单位，表示缓存的内容会在该值后过期
  * no-cache：需要使用协商缓存，协商缓存的内容我们后面介绍。注意这个字段并不表示不使用缓存
  * no-store：所有内容都不会被缓存
  * must-revalidate：告诉浏览器，你这必须再次验证检查信息是否过期, 返回的代号就不是 200 而是 304 了

关于 Cache-control 的取值，还有其他情况比如 s-maxage，proxy-revalidate 等，以及 HTTP 1.0 的
Pragma，由于比较少用或已经过气，我们不再过多介绍。

我们看这样的 Cache-control 设置：

    
    
    //Response Headers
    Cache-Control:private, max-age=0, must-revalidate
    

它表示：该资源只能被浏览器缓存，而不能被代理缓存。max-age 标识为 0，说明该缓存资源立即过期，must-revalidate
告诉浏览器，需要验证文件是否过期，接下来可能会使用协商缓存进行判断。

**HTTP 规定，如果 Cache-control 的 max-age 和 Expires 同时出现，那么 max-age 的优先级更高，他会默认覆盖掉
expires。**

关于 Cache-control 取值总结，我们可以参考 Google developer 的一个图示：

![2](https://images.gitbook.cn/71206530-e26a-11e9-bb4c-7169754434c1)

对于上图的翻译图：

![3](https://images.gitbook.cn/f0915d60-e26a-11e9-bb4c-7169754434c1)

#### 协商缓存

我们进一步思考，强缓存判断的实质上是缓存资源是否超出某个时间或者某个时间段。很多情况是超出了这个时间或时间段，但是资源并没有更新。从优化的角度来说，我们真正应该关心的是服务器端文件是否已经发生了变化。此时我们需要用到协商缓存策略。

那如何做到知晓「服务器端文件是否已经发生了变化」了呢？回到强缓存上，强缓存关于是否使用缓存的决断完全是由浏览器作出的，单一的浏览器是不可能知道「服务器端文件是否已经发生了变化」的。那么协商缓存需要将是否使用缓存的决定权交给服务端，因此协商缓存还是需要一次网络请求的。

协商缓存过程：在浏览器端，当对某个资源的请求没有命中强缓存时，浏览器就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的 HTTP
状态为 304。

现在问题就到服务端如何判断资源有没有过期上了。服务端掌握着最新的资源，那么为了做对比，它需要知道客户端的资源信息。根据 HTTP
协议，这个决断是根据【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对 header
来作出的。

我们先来看【Last-Modified，If-Modified-Since】 这一对 header 主导的协商缓存过程：

  * 浏览器第一次请求资源，服务端在返回资源的响应头中加入 Last-Modified 字段，这个字段表示这个资源在服务器上的最近修改时间

    
    
    Last-Modified: Tue, 12 Jan 2019 09:08:53 GMT
    

  * 浏览器收到响应，并记录 Last-Modified 这个响应头的值为 T
  * 当浏览器再次向服务端请求该资源时，请求头加上 If-Modified-Since 的 header，这个 If-Modified-Since 的值正是上一次请求该资源时，后端返回的 Last-Modified 响应头值 T
  * 服务端再次收到请求，根据请求头 If-Modified-Since 的值 T，判断相关资源是否在 T 时间后有变化；如果没有变化则返回 304 Not Modified，且并不返回资源内容，浏览器使用资源缓存值；如果有变化，则正常返回资源内容，且更新 Last-Modified 响应头内容

我们思考这种基于时间的判断方式和 HTTP 1.0 的 Expires 的问题类似，如果客户端的时间不准确，就会导致判断不可靠；同时 Last-
Modified 标注的最后修改只能精确到秒级，如果某些文件在 1
秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间；也要考虑到，一些文件也许会周期性的更改，但是他的内容并不改变，仅仅改变的修改时间，这时候使用
Last-Modified 就不是很合适了。为了弥补这种小缺陷，就有了 【ETag、If-None-Match】这一对 header
头来进行协商缓存的判断。

我们来看 【ETag、If-None-Match】这一对 header 主导的协商缓存过程：

  * 浏览器第一次请求资源，服务端在返回资源的响应头中加入 Etag，Etag 能够弥补 Last-Modified 的问题，因为 Etag 的生成过程类似文件 hash 值，Etag 是一个字符串，不同文件内容对应不同的 Etag 值

    
    
    //response Headers
    ETag:"751F63A30AB5F98F855D1D90D217B356"
    

  * 浏览器收到响应，记录 Etag 这个响应头的值为 E 
  * 浏览器再次跟服务器请求这个资源时，在请求头上加上 If-None-Match，值为 Etag 这个响应头的值 E 
  * 服务端再次收到请求，根据请求头 If-None-Match 的值 E，根据资源生成一个新的 ETag，对比 E 和新的 Etag：如果两值相同，则说明资源没有变化，返回 304 Not Modified，同时携带着新的 ETag 响应头；如果两值不同，就正常返回资源内容，这时也更新 ETag 响应头
  * 浏览器收到 304 的响应后，就会从缓存中加载资源

这里需要重点说明一下的是 Etag 的生成策略，实际上规范并没有强制说明，这就取决于各大厂商或平台的自主实现方式了：Apache 中，ETag
的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行混淆后得到的；MDN 使用 wiki 内容的十六进制数字的哈希值。

另外一个需要注意的细节是：Etag 优先级比 Last-Modified 高，如果他们组合出现在请求头当中，我们会优先采用 Etag 策略。同时 Etag
也有自己的问题：相同的资源，在两台服务器产生的 Etag 是不是相同的，所以对于使用服务器集群来处理请求的网站来说， Etag
的匹配概率会大幅降低。所在在这种情况下，使用 Etag 来处理缓存，反而会有更大的开销。

### 流程图

由上述内容我们开出：为了使缓存策略更加可靠，灵活，HTTP 1.0 版本 和 HTTP 1.1 版本的缓存策略一直是在渐进增强的。这也意味着 HTTP
1.0 版本 和 HTTP 1.1
版本关于缓存的特性可以同时使用，强制缓存和协商缓存也会同时使用。当然他们在混合使用时有优先级的限制，我们通过下面这个流程图来做一个总结：

![4](https://images.gitbook.cn/138a0060-e26b-11e9-b138-7fd562c24e16)

根据这个流程，我们该如何合理应用缓存呢？一般来说：

优先级上：Cache-Control > Expires > ETag > Last-Modified

强制缓存优先级最高，并且资源的改动在缓存有效期内浏览器都不会发送请求，因此强制缓存的使用适用于大型且不易修改的的资源文件，例如第三方 CSS、JS
文件或图片资源。如果更加灵活的话，我们也可以为文件名加上 hash 进行版本的区分。

协商缓存灵活性高，适用于数据的缓存，根据上述知识的介绍，采用 Etag
标识进行对比灵活度最高，也最为可靠。对于数据的缓存，我们可以重点考虑存入内存中，因为内存加载速最快，并且数据体积小。

### 总结

这一讲我们梳理了缓存知识体系，实际上缓存并不难理解，只要搞清楚什么时候使用缓存这个关键问题，并以此问题为核心，结合 HTTP
协议关于缓存的发展变革，就很容易掌握理论知识。

下一讲，我们将集中总结常见的缓存面试考察点，并结合实战来巩固知识。



## 缓存谁都懂，一问都哑巴（下）

上一讲，我们了解了缓存的几种方式和基本概念；这一讲，让我们从应用和面试的角度出发，巩固理论基础，加深操作印象。

![0](https://images.gitbook.cn/14a4f400-e270-11e9-bb4c-7169754434c1)

### 缓存和浏览器操作

缓存的重要一环是浏览器，常见浏览器行为对应的缓存行为有哪些呢？我们来做一个总结（注意，不同浏览器引擎、不同版本可能会有差别，读者可以根据不同情况酌情参考）：

  * 当用户 Ctrl + F5 强制刷新网页时，浏览器直接从服务器加载，跳过强缓存和协商缓存
  * 当用户仅仅敲击 F5 刷新网页时，跳过强缓存，但是仍然会进行协商缓存过程

这里我借用 [Alloy
Team](https://link.juejin.im/?target=http%3A%2F%2Fwww.alloyteam.com%2F2012%2F03%2Fweb-
cache-2-browser-cache%2F) 的图进行一个总结：

![1](https://images.gitbook.cn/cc134b80-e26d-11e9-bb4c-7169754434c1)

### 缓存相关面试题目

知识点我们已经梳理完毕，是时候刷一下经典题目来巩固了。以下题目都可以在上述知识中找到答案，我们也当做一个总结和考察。

  * 题目一：如何禁止浏览器不缓存静态资源

在实际工作中，很多场景都需要禁用浏览器缓存。比如可以使用 Chrome 隐私模式，在代码层面可以设置相关请求头：

    
    
    Cache-Control: no-cache, no-store, must-revalidate
    

此外，也可以给请求的资源增加一个版本号：

    
    
    <link rel="stylesheet" type="text/css" href="./asset.css?version=1.8.9"/>
    

我们也可以使用 Meta 标签来声明缓存规则：

    
    
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate"/>
    

  * 题目二：设置以下 request/response header 会有什么效果？

    
    
    cache-control: max-age=0
    

上述响应头属于强缓存，因为 max-age 设置为 0，所以浏览器必须发请求重新验证资源。这时候会走协商缓存机制，可能返回 200 或者 304。

  * 题目三：设置以下 request/response header 会有什么效果？

    
    
    cache-control: no-cache
    

上述响应头属于强缓存，因为设置 no-cache，所以浏览器必须发请求重新验证资源。这时候会走协商缓存机制。

  * 题目四：除了上述方式，还有哪种方式可以设置浏览器必须发请求重新验证资源，走协商缓存机制？

设置 request/response header：

    
    
    cache-control: must-revalidate
    

  * 题目五：设置以下 request/response header 会有什么效果？

    
    
    Cache-Control: max-age=60, must-revalidate
    

如果资源在 60s 内再次访问，走强缓存，可以直接返回缓存资源内容；如果超过 60s，则必须发送网络请求到服务端，去验证资源的有效性。

  * 题目五：据你的经验，为什么大厂都不怎么用 Etag？

大厂多使用负载分担的方式来调度 HTTP 请求。因此，同一个客户端对同一个页面的多次请求，很可能被分配到不同的服务器来相应，而根据 ETag
的计算原理，不同的服务器，有可能在资源内容没有变化的情况下，计算出不一样的 Etag，而使得缓存失效。

  * 题目六：Yahoo 的 YSlow 页面分析工具为什么推荐关闭 ETag?

因为 Etag 计算较为复杂，所以可能会使得服务端响应变慢。

### 缓存实战

我们来通过几个简单的真实项目案例实操一下缓存。

#### 启动项目

首先创建项目：

    
    
    mkdir cache
    npm init
    

之后，得到 package.json，同时声明我们的相关依赖：

    
    
    {
      "name": "cache",
      "version": "1.0.0",
      "description": "Cache demo",
      "main": "index.js",
      "scripts": {
        "start": "nodemon ./index.js"
      },
      "keywords": [
        "cache",
        "node"
      ],
      "devDependencies": {
        "@babel/core": "latest",
        "@babel/preset-env": "latest",
        "@babel/register": "latest",
        "koa": "latest",
        "koa-conditional-get": "^2.0.0",
        "koa-etag": "^3.0.0",
        "koa-static": "latest"
      },
      "dependencies": {
        "nodemon": "latest"
      },
      "license": "ISC"
    }
    

使用 nodemon 来启动并 watch Node 脚本，同时配置 .babelrc 如下：

    
    
    {
     "presets": [
       [
         "@babel/preset-env",
         {
           "targets": {
             "node": "current"
           }
         }
       ]
     ]
    }
    

在 cache/static 目录下，创建 index.html 和一张测试图片 web.png：

    
    
    <!DOCTYPE html>
    <html lang="en">
      <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta http-equiv="X-UA-Compatible" content="ie=edge" />
        <title>前端开发核心知识进阶</title>
        <style>
          .cache img {
            display: block;
            width: 100%;
          }
        </style>
      </head>
      <body>
        <div class="cache">
          <img src="./web.png" />
        </div>
      </body>
    </html>
    

看一下我们的核心脚本 index.js，其实就是一个简单的 NodeJS 服务：

index.js：

    
    
    require('@babel/register');
    require('./cache.js');
    

cache.js：

    
    
    import Koa from 'koa'
    import path from 'path'
    import resource from 'koa-static'
    
    const app = new Koa()
    const host = 'localhost'
    const port = 6666
    
    app.use(resource(path.join(__dirname, './static')))
    
    app.listen(port, () => {
      console.log(`server is listen in ${host}:${port}`)
    })
    

我们启动：

    
    
    npm run start
    

得到页面：

![2](https://images.gitbook.cn/e5aca3c0-e26d-11e9-bb4c-7169754434c1)

#### 应用缓存

我们来尝试加入一些缓存，首先应用强缓存，只需要在响应头上加入相关字段即可：

    
    
    import Koa from 'koa'
    import path from 'path'
    import resource from 'koa-static'
    
    const app = new Koa()
    const host = 'localhost'
    const port = 5999
    
    app.use(async (ctx, next) => {
      ctx.set({
        'Cache-Control': 'max-age=5000'  
      })
      await next()
    })
    
    app.use(resource(path.join(__dirname, './static')))
    
    app.listen(port, () => {
      console.log(`server is listen in ${host}:${port}`);
    })
    

我们加入了 Cache-Control 头，设置 max-age 值为 5000。页面得到了响应：

![3](https://images.gitbook.cn/f94f7ec0-e26d-11e9-b138-7fd562c24e16)

再次刷新，得到了 200 OK（from memory cache）的标记：

![4](https://images.gitbook.cn/1765ac90-e26e-11e9-9514-611dbba450a7)

当我们关掉浏览器，再次打开页面，得到了 200 OK（from disk cache）的标记。请体会与 from memory cache
的不同，memory cache 已经随着我们关闭浏览器而清除，这里是从 disk cache 取到的缓存。

![5](https://images.gitbook.cn/3d0bbc50-e26e-11e9-bb4c-7169754434c1)

我们尝试将 max-age 改为 5 秒，5 秒后再次刷新页面，发现缓存已经失效。这里读者可以自行试验，不再截图了。

下面来试验一下协商缓存，在初始 package.json 中，已经引入了 koa-etag 和 koa-conditional-get 这两个包依赖。

修改 cache.js 为：

    
    
    import Koa from 'koa'
    import path from 'path'
    import resource from 'koa-static'
    import conditional from 'koa-conditional-get'
    import etag from 'koa-etag'
    
    const app = new Koa()
    const host = 'localhost'
    const port = 5999
    
    app.use(conditional())
    app.use(etag())
    app.use(resource(path.join(__dirname, './static')))
    
    app.listen(port, () => {
     console.log(`server is listen in ${host}:${port}`)
    })
    

一切都很简单：

![6](https://images.gitbook.cn/552d68b0-e26e-11e9-bb4c-7169754434c1)

我们再次刷新浏览器，这次找到请求头，得到了 If-None-Match 字段，且内容与上一次的响应头相同。

![7](https://images.gitbook.cn/6b1e0440-e26e-11e9-b138-7fd562c24e16)

因为我们的图片并没有发生变化，所以得到了 304 响应头。

![8](https://images.gitbook.cn/84e85790-e26e-11e9-8cc6-d3303f1d15c4)

读者可以自行尝试替换图片来验证内容。

这里我们主要使用了 Koa 库，如果对于原生 NodeJS，这里截取一个代码片段，供大家参考，该代码主要实现了 【if-modified-
since/last-modified】头：

    
    
    http.createServer((req, res) => {
        let { pathname } = url.parse(req.url, true)
    
        let absolutePath = path.join(__dirname, pathname)
    
        fs.stat(path.join(__dirname, pathname), (err, stat) => {
            // 路径不存在
            if(err) {
                res.statusCode = 404
                res.end('Not Fount')
                return
            }
    
            if(stat.isFile()) {
                res.setHeader('Last-Modified', stat.ctime.toGMTString())
    
                if(req.headers['if-modified-since'] === stat.ctime.toGMTString()) {
                    res.statusCode = 304
                    res.end()
                    return
                }
    
                fs.createReadStream(absolutePath).pipe(res)
            }
        })
    })
    

该项目源码，读者可以在[这里找到](https://github.com/HOUCe/lucas-gitchat-
courses/tree/master/%E7%BC%93%E5%AD%98%E8%B0%81%E9%83%BD%E6%87%82%EF%BC%8C%E4%B8%80%E9%97%AE%E9%83%BD%E5%93%91%E5%8F%A3/cache)。

#### 源码探究

在上面应用 Etag 试验当中，使用了 koa-etag 这个包，这里我们就来了解一下这个包的实现。

源码如下：

    
    
    var calculate = require('etag');
    var Stream = require('stream');
    var fs = require('mz/fs');
    
    module.exports = etag;
    
    function etag(options) {
      return function etag(ctx, next) {
        return next()
          .then(() => getResponseEntity(ctx))
          .then(entity => setEtag(ctx, entity, options));
      };
    }
    
    function getResponseEntity(ctx, options) {
      // no body
      var body = ctx.body;
      if (!body || ctx.response.get('ETag')) return;
    
      // type
      var status = ctx.status / 100 | 0;
    
      // 2xx
      if (2 != status) return;
    
      if (body instanceof Stream) {
        if (!body.path) return;
        return fs.stat(body.path).catch(noop);
      } else if (('string' == typeof body) || Buffer.isBuffer(body)) {
        return body;
      } else {
        return JSON.stringify(body);
      }
    }
    
    function setEtag(ctx, entity, options) {
      if (!entity) return;
    
      ctx.response.etag = calculate(entity, options);
    }
    
    function noop() {}
    

我们看整个 etag 库就是一个中间件，它首先调用 getResponseEntity 方法获取响应体，根据 body 最终调用了 setEtag
方法，根据响应内容生产 etag。最终生成 etag 的计算过程又利用了 etag 这个包，再来看一下 etag 库：

    
    
    'use strict'
    
    module.exports = etag
    
    var crypto = require('crypto')
    var Stats = require('fs').Stats
    
    var toString = Object.prototype.toString
    
    function entitytag (entity) {
      if (entity.length === 0) {
        // fast-path empty
        return '"0-2jmj7l5rSw0yVb/vlWAYkK/YBwk"'
      }
    
      // compute hash of entity
      var hash = crypto
        .createHash('sha1')
        .update(entity, 'utf8')
        .digest('base64')
        .substring(0, 27)
    
      // compute length of entity
      var len = typeof entity === 'string'
        ? Buffer.byteLength(entity, 'utf8')
        : entity.length
    
      return '"' + len.toString(16) + '-' + hash + '"'
    }
    
    function etag (entity, options) {
      if (entity == null) {
        throw new TypeError('argument entity is required')
      }
    
      // support fs.Stats object
      var isStats = isstats(entity)
      var weak = options && typeof options.weak === 'boolean'
        ? options.weak
        : isStats
    
      // validate argument
      if (!isStats && typeof entity !== 'string' && !Buffer.isBuffer(entity)) {
        throw new TypeError('argument entity must be string, Buffer, or fs.Stats')
      }
    
      // generate entity tag
      var tag = isStats
        ? stattag(entity)
        : entitytag(entity)
    
      return weak
        ? 'W/' + tag
        : tag
    }
    
    function isstats (obj) {
      // genuine fs.Stats
      if (typeof Stats === 'function' && obj instanceof Stats) {
        return true
      }
    
      // quack quack
      return obj && typeof obj === 'object' &&
        'ctime' in obj && toString.call(obj.ctime) === '[object Date]' &&
        'mtime' in obj && toString.call(obj.mtime) === '[object Date]' &&
        'ino' in obj && typeof obj.ino === 'number' &&
        'size' in obj && typeof obj.size === 'number'
    }
    
    function stattag (stat) {
      var mtime = stat.mtime.getTime().toString(16)
      var size = stat.size.toString(16)
    
      return '"' + size + '-' + mtime + '"'
    }
    

etag 方法接受一个 entity 最为入参一，entity 可以是 string、Buffer 或者 Stats 类型。如果是 Stats 类型，那么
etag 的生成方法会有不同：

    
    
    var mtime = stat.mtime.getTime().toString(16)
    var size = stat.size.toString(16)
    
    return '"' + size + '-' + mtime + '"'
    

主要是根据 Stats 类型的 entity 的 mtime 和 size 特征，拼成一个 etag 即可。

如果是正常 String 或者 Buffer 类型，etag 的生成方法依赖了内置 crypto 包，主要是根据 entity 生成 hash，hash
生成主要依赖了 sha1 加密方法：

    
    
    var hash = crypto
        .createHash('sha1')
        .update(entity, 'utf8')
        .digest('base64')
    

了解了这些，如果面试官再问“Etag 的生成方法”，我想读者已经能够有一定底气了。

### 实现一个验证缓存的轮子

分析完关于 etag
的这个库，我们来尝试自救造一个轮子，也当作留给大家的一个作业。这个轮子的需要完成验证缓存是否可用的功能，它接受请求头和响应头，并根据这两个头部，返回一个布尔值，表示缓存是否可用。

应用举例：

    
    
    var reqHeaders = { 'if-none-match': '"foo"' }
    var resHeaders = { 'etag': '"bar"' }
    isFresh(reqHeaders, resHeaders)
    // => false
    
    var reqHeaders = { 'if-none-match': '"foo"' }
    var resHeaders = { 'etag': '"foo"' }
    isFresh(reqHeaders, resHeaders)
    // => true
    

在业务端使用时，可以直接：

    
    
    var isFresh = require('is-fresh')
    var http = require('http')
    
    var server = http.createServer(function (req, res) {
    
      if (isFresh(req.headers, {
        'etag': res.getHeader('ETag'),
        'last-modified': res.getHeader('Last-Modified')
      })) {
        res.statusCode = 304
        res.end()
        return
      }
    
      res.statusCode = 200
      res.end('hello, world!')
    })
    
    server.listen(3000)
    

实现这道题目的前提就是先要了解缓存的基本知识，知晓缓存优先级。我们应该先验证 cache-control，之后验证 If-None-Match，之后是
If-Modified-Since。了解了这些，我们按部就班不难实现：

    
    
    var CACHE_CONTROL_NO_CACHE_REGEXP = /(?:^|,)\s*?no-cache\s*?(?:,|$)/
    
    function fresh (reqHeaders, resHeaders) {
      // fields
      var modifiedSince = reqHeaders['if-modified-since']
      var noneMatch = reqHeaders['if-none-match']
    
      if (!modifiedSince && !noneMatch) {
        return false
      }
    
      var cacheControl = reqHeaders['cache-control']
      if (cacheControl && CACHE_CONTROL_NO_CACHE_REGEXP.test(cacheControl)) {
        return false
      }
    
      // if-none-match
      if (noneMatch && noneMatch !== '*') {
        var etag = resHeaders['etag']
    
        if (!etag) {
          return false
        }
    
        var etagStale = true
        var matches = parseTokenList(noneMatch)
        for (var i = 0; i < matches.length; i++) {
          var match = matches[i]
          if (match === etag || match === 'W/' + etag || 'W/' + match === etag) {
            etagStale = false
            break
          }
        }
    
        if (etagStale) {
          return false
        }
      }
    
      // if-modified-since
      if (modifiedSince) {
        var lastModified = resHeaders['last-modified']
        var modifiedStale = !lastModified || !(parseHttpDate(lastModified) <= parseHttpDate(modifiedSince))
    
        if (modifiedStale) {
          return false
        }
      }
    
      return true
    }
    
    function parseHttpDate (date) {
      var timestamp = date && Date.parse(date)
    
      return typeof timestamp === 'number'
        ? timestamp
        : NaN
    }
    
    function parseTokenList (str) {
      var end = 0
      var list = []
      var start = 0
    
      for (var i = 0, len = str.length; i < len; i++) {
        switch (str.charCodeAt(i)) {
          case 0x20: /*   */
            if (start === end) {
              start = end = i + 1
            }
            break
          case 0x2c: /* , */
            list.push(str.substring(start, end))
            start = end = i + 1
            break
          default:
            end = i + 1
            break
        }
      }
    
      list.push(str.substring(start, end))
    
      return list
    }
    

这个实现比较简单，读者可以尝试解读该源码，如果这两讲的内容你已经融会贯通，上述实现并不困难。

当然，缓存的轮子却也没有“想象的那么简单”，“上述的代码强健性是否足够”？“API
设计是否优雅”？等这些话题值得思考。也希望在整个内容完结后，针对实战代码的优化和调试，应用的踩坑和解决能够大家继续交流。我们也会针对上述代码，展开更多内容。

### 总结

我们通过两讲的学习，介绍了缓存这一热门话题。缓存体现了理论规范和实战结合的美妙，是网络应用经验的结晶。建议读者可以多观察大型门户网站、页面应用，并结合工程化知识来看待并学习缓存。



## HTTP 的深思：我从何而来，去向何处

在前面三讲中，分别了解了网络的基本内容、HTTP 的特性，尤其是缓存特性。这一讲让我们从历史的角度来审视 HTTP，探究 HTTP
的演进是为了更好的应用，更理解网络这个宏大概念中的一环。

主要内容如下：

![主要内容](https://images.gitbook.cn/36e4b700-e9b2-11e9-bf8f-1183a185e45f)

### HTTP 的诞生

HTTP 从何处来？

HTTP 协议诞生自 1989 年（可能比很多开发者年纪要大），第一版本是 HTTP 0.9，但 HTTP 0.9 并不是一个正式标准；直到 1996
年，根据 RFC 1945，HTTP 1.0 成为 IEFT 标准，1999 年，在 RFC 2616 中发布了 HTTP 1.1。

版本路线如下：

  * HTTP/0.9
  * HTTP/1.0
  * HTTP/1.1
  * HTTP/2

但是需要注意的是，HTTP 和 JavaScript
一样，说到底还是需要浏览器的支持和实现。到那时每个浏览器或服务器对于该协议的每个方面并不能完全一致实现，因此还是有着细微用户体验与标准规范不一致的情况。

这些“陈年旧事”我们不再过多回顾，下面来看一下 HTTP 的现状和发展痛点。

### HTTP 的现状和痛点

HTTP 2.0 于 2015 年发布，考虑到发布后的落地情况，以及现在各大厂商的应用情况，我们认可 HTTP 1.1 作为现状分析。

HTTP 1.1 是划时代的，它解决了 HTTP 1.0 时代最重要的两个大问题：

  * **TCP 连接无法复用** ，每次请求都需要重新建立 TCP 通道，也就要重复三次握手和四次挥手的情况；就是说 _每个 TCP 连接只能发送一个请求_ 。
  * **队头阻塞** ，每个请求都要过“独木桥”，桥宽为一个请求的宽度；也就是说，即使多个请求并行发出，也只能一个接一个地进行请求排队。

HTTP 1.1 的改进点“对症下药”，它引入了：

  * 长连接：HTTP 1.1 支持长连接（Persistent Connection），且默认就开启了 Connection：keep-alive，这样在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟。业界的成熟方案，如 Google 的 protobuf。
  * 管线化：在长连接的基础上，管线化（HTTP Pipelining）使得多个请求使用同一个 tcp 连接使请求并按照并行方式成为可能：多个请求同时发起，无需等待上一个请求的回包。但是需要注意，管线化只是让请求并行，但并没有从根本上解决队头阻塞问题，因为响应仍然要遵循先进先出的原则，第一个请求的回包发出之后，才会响应第二个请求。同时，浏览器供应商很难实现管道，而且大多数浏览器默认禁用该特性，有的甚至完全删除了它。

除此以外，HTTP 1.1 还有一些创造性的改进，比如：

  * 缓存处理
  * 带宽优化及网络连接的使用，比如，range 头，支持断点续传功能，这个内容我们已经在前面的内容中进行了介绍
  * 错误通知的增强，响应码的增强
  * Host 头处理，请求消息中如果没有 Host 头域会报告一个错误

基于 HTTP 1.1 的变革，一些成熟的方案也应运而出，比如：

  * http long-polling
  * http streaming
  * websocket

这些内容我们会在本专栏「从实时通信系统看 HTTP 发展」部分进行介绍。

这么看来，HTTP 1.1 简直不要太完美！当然他还是有一些缺陷和痛点的。比如：

  * 队头堵塞问题没有真正解决
  * 明文传输，安全性有隐患
  * header 携带内容过多，增加了传输成本
  * 默认开启 keep-alive 可能会给服务端造成更大的性能压力，比如对于一次性的请求（图片 CDN 服务），在文件被请求之后还保持了不必要的连接很长时间

### HTTP 2.0 未来已来

说起 HTTP 2.0，不得不提一下 SPDY 协议。2009 年，谷歌针对 HTTP 1.1 的一些问题，发布了 SPDY 协议。这个协议在 Chrome
浏览器上进行应用，并证明可行后，就成为了 HTTP 2.0 的基础，主要特性都在 HTTP 2.0 之中得到继承。但作为推动时代发展的产出，SPDY
说到底不会主宰时代而流行，我们暂不介绍更多，而把主要精力放在 HTTP 2.0 上。

HTTP 2.0 目标是显著改善性能，同时做到迁移透明。我们先来理解几个 HTTP 2.0 的相关前置基础概念：

  * 帧：HTTP 2.0 中，客户端与服务器通过交换帧来通信，帧是基于这个新协议通信的最小单位。
  * 消息：是指逻辑上的 HTTP 消息，比如请求、响应等，由一或多个帧组成。
  * 流：流是连接中的一个虚拟信道，可以承载双向的消息；每个流都有一个唯一的标识符

最主要的特性如下。

  * 二进制分帧

HTTP 2.0 的协议解析决定采用二进制格式，而非 HTTP 1.x
的文本格式，二进制协议解析起来更高效，这可以说是性能增强的焦点。新协议称为二进制分帧层（Binary Framing
Layer），每一个请求都有这些公共字段：

  * Type：帧的类型，标识帧的用途
  * Length：整个帧的开始到结束大小
  * Flags：指定帧的状态信息
  * Steam Identifier：用于流控制，可以跟踪逻辑流的帧成员关系
  * Frame payload：r 请求正文

这些内容相对底层和细致，这里只需要大家明白：二进制协议将通信分解为帧的方式，这些帧交织在客户端与服务器之间的双向逻辑流中，这样就使得所有通信都在单个 TCP
连接上执行，而且该连接在整个对话期间一直处于打开状态。

  * 请求/响应复用

上面提到，为每帧分配一个流标识符，这就可以在一个 TCP
连接上独立发送它们。此技术实现了完全双向的请求和响应消息复用，解决了队头阻塞的问题。换句话说：一个请求对应一个 stream 并分配一个
id，这样一个连接上可以有多个 stream，每个 stream 的 frame 可以混杂在一起，接收方可以根据 stream id 将 frame
再归属到各自不同的请求里面。

总结一下：所有的相同域名请求都通过同一个 TCP 连接并发完成。同一 TCP
中可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP
旧版本中的队头阻塞问题，极大的提高传输性能。这是真正意义上的多路复用。

  * 报头压缩

报头压缩的实现方式是，要求客户端和服务器都维护之前看见的标头字段的列表。在第一个请求后，它仅需发送与前一个标头的不同之处，其他相同之处，服务器可以从标头的列表中恢复。

  * 流优先化

消息帧通过流进行发送。我们提到每个流都分配了一个 id，同时也可以分配优先级。这样一来，服务端可以根据优先级确定它的处理顺序。

  * 服务器推送

当一个客户端主动请求资源 K，如果这时候服务器知道它很可能也需要资源 M，那么服务器可以主动将资源 M 推送给客户端。当客户端真的请求 M
时，便可以从缓存中读取。

这里有一个问题是：如何管理让服务器推送资源而不会让客户端过载？

事实上，针对服务度希望发送的每个资源，服务端会发送一个 PUSH_PROMISE 帧，但客户端可通过发送 RST_STREAM 帧作为响应来拒绝推送。

  * 流控制

流控制允许接收者主动示意停止或减少发送的数据量。比如一个视频应用，在观看一个视频流时，服务器会同时向客户端发送数据。如果视频暂停，客户端会通知服务器停止发送视频数据，以避免耗尽它的缓存。

### 从实时通信系统看 HTTP 发展

从上面的知识我们看出，传统的浏览器和 HTTP 协议，早期只能通过客户端主动发送请求，服务端应答回复请求来实现数据交互。但是在一些监控、Web
在线通讯、即时报价系、在线游戏等场景中，都需要将后台发生的变化主动地、实时地传送到浏览器端，而不需要用户手动地刷新页面。为了达到这个目的，一些 hack
方法或“官方”方法便应用而生。

  * Ajax polling

轮询是最简单无脑的方案：客户端通过定期发送 ajax
请求，服务端受理请求立刻返回数据。这种方式保证了数据的相对实时性，具有很好的浏览器兼容性和简单性。但是缺点也明显：数据延迟取决于轮询频率，如果频率过高，就会产生大部分无效请求；反转频率过低，数据的实时性较差。同时，服务端的压力较大，也浪费了带宽流量。

  * Ajax long polling

在短轮询的基础上，长轮询的实现思路是：客户端通过 ajax
发起请求，服务器在接到请求后不马上返回，而是保持住这个连接，等待数据的更新。当有数据要推送给客户端时，才发送目标数据给客户端，请求返回。客户端收到响应之后，马上再发起一个新的请求给服务器，周而复始。

这样的长轮询能够有效减少轮询次数，而且延迟大大降低，但服务端需要保持大量连接，也是一种消耗。

  * Comet streaming

Comet streaming 技术又被称为 Forever iframe，这种技术听上去更加 hack：需要我们动态载入一个隐藏的 iframe
标签，iframe 的 src 指向请求的服务器地址。同时客户端准备好一个处理数据的函数，在服务端通过 iframe 和客户端通信时，服务端返回类似
script 标签的文本，客户端解析为 JavaScript 脚本，并调用用预先准备好的函数，将数据传递给 parent window，类似 Jsonp
的实现原理一样：

    
    
    <script>parent.getData("data from server")</script>
    

这样的实现也不算复杂，但说到底也是一种奇怪的 hack。

  * Ajax multipart streaming

这种方式就用到了 HTTP 1.1 的 multipart 特性：客户端发送请求，服务端保持住这个连接，利用 HTTP 1.1 的 chunked
encoding 机制（分块传输编码），将数据传递给客户端，直到 timeout 或者客户端手动断开。

这种方法至少属于官方规范，但是就像前面知识所介绍的那样，HTTP 1.1 的 multipart 特性并没有被更广泛的浏览器接受并实现，它需要浏览器支持
multipart 特性。

  * Websocket

WebSocket 是 HTML5 开始提供的一种浏览器与服务器间进行全双工通讯的网络技术。依靠这种技术可以实现客户端和服务器端的长连接，双向实时通信。

我们该如何理解 Websocket 和 HTTP 协议呢？

> HTTP 和 WebSocket 都是应用层协议，都是基于 TCP 协议来传输数据的。WebSocket 依赖一种升级的 HTTP
协议进行一次握手，握手成功后，数据就直接从 TCP 通道传输。

这样一来，连接的发起端还是客户端，但是一旦 Websocket 连接建立，客户端和服务端任何一方都可以向对方发送数据。

Webscoket 无疑是强大的，但是它也错过了浏览器为HTTP提供的一些服务，需要开发中在使用时自己实现。因此 WebSocket 并不能取代 HTTP。

由此看出，HTTP 的发展不是封闭的，而是吸取了“民间方案”和各种应用技术所长。尤其是 HTTP 2.0 更是一个极大的补充和优化。在下一部分，我们对
HTTP 和 Tcp. 以及相关内容以面试题的方式在进行巩固。

### 相关深度面试题目

  * 题目一：「HTTP 连接分为长连接和短连接，而我们现在常用的都是 HTTP 1.1，因此我们用的都是长连接。」这种说法正确吗？

其实这句话只对了后半句：我们现在大多应用 HTTP 1.1，因此用的都是长连接，这种说法勉强算对，因为 HTTP 1.1 默认 Connection 为
keep-alive。但是 HTTP 协议并没有长连接、短连接之分，所谓的长短连接都是在说 TCP 连接，TCP
连接是一个双向的通道，它是可以保持一段时间不关闭的，因此 TCP 连接才有真正的长连接和短连接这一说。

这个可以回到网络分层的话题上，HTTP 协议说到底是应用层的协议，而 TCP 才是真正的传输层协议，只有负责传输的这一层才需要建立连接。

  * 题目二：长连接是一种永久连接吗？

事实上，长连接并不是永久连接的，在长连接建立以后，如果一段时间内没有 HTTP 请求发出，这个长连接就会断掉。这个超时的时间可以在 header
中进行设置。

  * 题目三：现代浏览器在与服务器建立了一个 TCP 连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？

在 HTTP 1.0 中，一个服务器在发送完一个 HTTP 响应后，会断开 TCP 链接。但 HTTP 1.1 中，默认开启
Connection：keep-alive，浏览器和服务器之间是会维持一段时间的 TCP 连接，不会一个请求结束就断掉。除非显式声明：Connection:
close。

  * 题目四：一个 TCP 连接可以对应几个 HTTP 请求，这些 HTTP 请求发送是否可以一起发送？

不管是 HTTP 1.0 还是 HTTP 1.1，单个 TCP 连接在同一时刻只能处理一个请求，意思是说：两个请求的生命周期不能重叠，任意两个 HTTP
请求从开始到结束的时间在同一个 TCP 连接里不能重叠。也就是上面说的“队头阻塞”。

虽然 HTTP 1.1 规范中规定了 Pipelining 来试图解决这个问题，但是这个功能在浏览器中默认是关闭的。

因此，在 HTTP 1.1
中，一个支持持久连接的客户端可以在一个连接中发送多个请求（不需要等待任意请求的响应），收到请求的服务器必须按照请求收到的顺序发送响应。HTTP 2.0
中，由于 Multiplexing 特点的存在，多个 HTTP 请求可以在同一个 TCP 连接中并行进行。

### 总结

这一讲中，我们从 HTTP 的发展角度，解析了当前 HTTP 协议的现状和痛点，并详细介绍了 HTTP 2.0 相关内容。

后面部分，从实时通信系统网络协议层面的解析，又一次巩固了相关知识。

到此，我们在理论层面已经有了必要的知识储备。 **在整个课程完结时，感兴趣的同学可以跟我亲自动手，实践一下 HTTP
2.0，让我们从实战角度，探究一下「HTTP 2.0」的众多特性到底能不能优化应用。**



## 不可忽视的前端安全 - 单页应用鉴权设计

安全是计算机科学永远无法忽视的话题。随着互联网的发展，安全问题越来越突出，也越来越重要：它是一个程序可用性、健壮性的基础。这个话题可大可小，大到系统的设计，小到一行代码的写法，都可能影响系统的安全。

毫不例外，安全与前端开发的结合也持续走热。不管是经验丰富的程序员，还是尚在打基础的学生，也许都对 HTTPS、XSS、CSRF
等前端相关的安全问题不陌生。然而，这其中每一个主题都可以非常深入，都能系统地做一节课。但是，我认为面面俱到、走马观花地梳理这些内容，讲解这些概念价值不大。毕竟，这方面知识都已经比较成熟，社区上资料很多。

本讲我想从一个大部分产品都要涉及的登录鉴权入手，结合单页面应用，从这个角度，管中窥豹，尽可能多地涉及一些常见的安全知识，帮助大家了解前端安全。

接下来，让我们从应用场景入手，从前后端交互切入，以单页面应用为基础，呈现“鉴权”这个安全领域重要话题的全貌，并尽力覆盖到 XSS 和 CSRF
等攻击手段以及最佳实践。

关于这个主题的知识点如下：

![](https://images.gitbook.cn/545627c0-4ecf-11e9-97d1-9b2c5e38f63d)

### 单页应用鉴权简介

首先，我们要分清单页应用鉴权与传统鉴权方式有所不同：

单页应用采用前后端分离的设计方式，路由由前端管理，前后端遵循一定规范（如 REST、GraphQL），通过 AJAX
进行通信。在这种情况下，用户对页面请求时，后端经常无法获取用户身份信息，更无法确定返回的数据。

同时一次鉴权完毕后，如何在单页应用的体验当中，保持这个鉴权状态也值得思考。一般来说，单页应用鉴权采用下面的步骤实现。

  * Step 1：前端根据用户交互，发送数据请求之前，需要准备用户信息，同数据请求一起发给后端处理。
  * Step 2-1：后端按照约定好的规则，根据请求中带有的用户身份信息，进行验证。如果验证不通过，返回 403 或者 401 相关状态码或其他状态，以表示鉴权失败。
  * Step 2-2：如果鉴权成功，后端返回相关数据。
  * Step 3：前端根据数据渲染视图。

基本结构非常简单清晰：

![](https://images.gitbook.cn/b99cdee0-4eba-11e9-aba8-d90fcdb25340)

在这个结构背后，隐藏的技术方案和安全细节非常值得我们思考，请继续阅读，我们将剖析几个重要概念和安全实践。

#### HTTPS

鉴权过程中，如果使用 HTTP 协议来传输敏感数据（用户昵称、用户密码、token……），那么很容易被中间人拦截获取。现代通信中，我们都使用 HTTPS
协议来对传输内容进行加密。关于 HTTPS 的应用及其原理，又是一个超级话题。这里由于内容的限制，不过多展开，给大家分享一下我收藏的关于 HTTPS
好的文章：

  * [https 连接的前几毫秒发生了什么](https://mp.weixin.qq.com/s/--KxUNzmBdKtOPBbovWCaA)
  * [完全图解 HTTPS](https://juejin.im/post/5c441073e51d455226654d60)
  * [更安全的 Web 通信 HTTPS](https://juejin.im/post/5b5f1289e51d4519601aeeda)
  * [图解基于 HTTPS 的 DNS](https://www.infoq.cn/article/a-cartoon-intro-to-dns-over-https)
  * [看图学 HTTPS](https://juejin.im/post/5b0274ac6fb9a07aaa118f49?utm_medium=fe&utm_source=weixinqun)
  * [http 与 https 的区别我真的知道吗](https://juejin.im/post/5af3e002f265da0b7c074ada)
  * [深入揭秘 HTTPS 安全问题&连接建立全过程](https://zhuanlan.zhihu.com/p/22142170)
  * [HTTPS系列干货（一）：HTTPS 原理详解](http://support.upyun.com/hc/kb/article/1031843/)
  * [HTTPS 为什么更安全，先看这些](http://support.upyun.com/hc/kb/article/1031843/https://juejin.im/post/58a8f3295c497d005fbd58b1)

#### 不要使用 URL query 传递敏感数据

URL query 会通过服务端日志、浏览器日志、浏览器历史记录查到。不要使用 URL query 传递敏感数据，这当然是最基本的准则之一。如果敏感数据在
URL query 中，这就给了恶意用户轻松获取数据的机会。同时，URL query 的长度也有限制，这也是其传递数据的弊端之一。

#### 防止暴力攻击的手段

攻击者可以通过暴力手段，尝试攻破用户的密码等信息。因此后端服务要时刻注意加入频率限制，限制一个用户短时间尝试密码的次数；也可以限制可疑用户（比如触发了过多服务端错误用户）的访问。另外，需要注意的是不要给任何人暴露服务端的技术细节信息，比如要记得关闭
X-Powered-By（服务器响应头隐藏）；Node 端在使用 express.js 的情况下，强烈建议使用
[Helmetjs](https://expressjs.com/en/advanced/best-practice-security.html#use-
helmet)。

Helmet 帮助 Node.js 开发者通过设置合理的 HTTP header，预防一些常见的 Web 漏洞，比如上面提到的关闭 X-Powered-
By。实际上它就是一组灵活的中间件函数，增强以下 HTTP header 的安全性：

  * Content-Security-Policy 响应头，它可以设置应用是否可以引用某些来源内容，进而防止 XSS
  * 关闭 X-Powered-By 响应头，以避免暴露服务端信息
  * 增加 [Public Key Pinning](https://developer.mozilla.org/en-US/docs/Web/Security/Public_Key_Pinning) 响应头，预防中间人伪造证书
  * 设置 Strict-Transport-Security 响应头，这样浏览器只能通过 HTTPS 访问当前资源 
  * 为 IE8+ 设置 X-Download-Options 响应头，目前只有 IE8+ 支持这个 header，用来预防下载内容的安全隐患
  * 设置 Cache-Control 和 Pragma header 以关闭浏览器端缓存
  * 设置 X-Content-Type-Options 响应头，以禁用浏览器内容嗅探
  * 设置 X-Frame-Options 响应头，以预防 [clickjacking](https://www.owasp.org/index.php/Clickjacking)，这个响应头给浏览器指示是否允许在 `<frame>` 或者 `<iframe>` 标签中渲染某个页面
  * 设置 X-XSS-Protection 响应头，当检测到跨站脚本攻击（XSS）时，浏览器停止加载页面

它的使用非常简单：

    
    
    const express = require('express')
    const helmet = require('helmet')
    
    const app = express()
    
    app.use(helmet())
    

其源码是典型的 express 中间件写法，它依次加载相关中间件集。比如它将引用 X-Powered-By 中间件，这个中间件的源码非常简单：

    
    
    module.exports = function hidePoweredBy (options) {
      var setTo = (options || {}).setTo
    
      if (setTo) {
        return function hidePoweredBy (req, res, next) {
          res.setHeader('X-Powered-By', setTo)
          next()
        }
      } else {
        return function hidePoweredBy (req, res, next) {
          res.removeHeader('X-Powered-By')
          next()
        }
      }
    }
    

通过 setHeader 和 removeHeader 方法，完成对 X-Powered-By 响应头的添加和删除。

#### 升级依赖保证安全

现如今我们的应用，大部分脚本都来自第三方依赖，第三方库出现安全隐患的新闻已经屡见不鲜。除了从源头把控依赖的引入外，适时合理地更新 npm
包，是值得倡导的做法，npm 便在 6.0 后有相关命令如下：

    
    
    # npm 6.0 新增，扫描所有依赖，列出依赖中有安全隐患的包
    npm audit
    # npm 6.0 新增，扫描所有依赖，并把不安全的依赖包升级到可兼容的版本
    npm audit fix
    

### 单页应用鉴权实战

言归正传，我们来看一下实现单页应用鉴权的两种主要手段：

  * JWT
  * Authentication cookie

**这两种方式不尽相同，我们将逐一分析，并尝试合并这两种方案的优点，将它们结合为第三种方式。**

#### 采用 JWT 实现鉴权

在鉴权过程中，为了验证用户的身份，需要浏览器向服务器端提供一个验证信息，我们称为 token。这个 token 通常由 JSON 数据格式组成，通过
hash 散列算法生成一个字符串，称为 JSON Web Token（JSON 表示令牌的原始类型为 JSON 格式，Web
表示在互联网中进行传播，Token 表示令牌，简称 JWT）。任何 token 持有者都可以无差别地用它来访问相关的资源。

我们可以在 HTTP Authorization header 中找到
token，其实就是一个字符串值。这个字符串用来表示用户的身份信息，进行身份认证或者从服务器获取合法资源。当然这个 token 往往是被加密的。那么这个
token 具体是如何生成的呢？

我们先从 JWT 说起，一个 JWT 包含以下 3 个部分：

  * header（消息头）
  * payload（消息体，储存用户 id、用户角色等） + 过期时间（可选）
  * signature（签名）

我们说过，JWT 就是 JSON 格式的数据，JWT 的前两个部分就是 JSON 数据，第三部分 signature 是基于前两部分 header 和
payload 生成的签名。前两部分分别通过 Base64URL 算法生成两组字符串，再和 signature 结合，三部分通过 . 号分割，就是最终的
token。

更多这方面的信息，大家可以参考：

  * [5 Easy Steps to Understanding JSON Web Tokens (JWT)](https://medium.com/vandium-software/5-easy-steps-to-understanding-json-web-tokens-jwt-1164c0adfcec)
  * [Bearer Token](https://www.jianshu.com/p/8f7009456abc)
  * [OAuth 2.0: Bearer Token Usage](https://www.cnblogs.com/XiongMaoMengNan/p/6785155.html)

正常来讲，当客户端在提交用户名/密码（或者其他方式）通过认证后，会获得 JWT 的 token，接着通过 JavaScript 脚本，对于所有数据请求都在其
HTTP header 中加上这个 JWT 的 token。服务端接到请求之后，验证 token 的 signature 是否等同于
payload，进而得知 payload 字段是否被中间人更改。

细心的读者可能会发现，我们提到“通过 JavaScript 脚本，对于所有数据请求，都在 HTTP header 中加上这个 token”。这就涉及
**客户端如何存储和维护 JWT** 的问题了。

存储 JWT，我们可以考虑：

  * 内存存储
  * local/session cookie
  * local/session storage……

这几种方式。我并不建议开发者将 token 存储在 local storage 当中，因为：

  * 当用户关掉浏览器后，JWT 仍然会被存储在 local storage 中，即便 JWT 过期，可能一直被存储（除非手动更新或清理）
  * 任何 JavaScript 都能轻而易举地获得 local storage 的内容
  * 无法被 web worker 使用

但在实际项目中，笔者也在 local storage 中存储过 JWT，这需要我们分清利弊，结合实际场景选择方案。如果吃透概念，就能减少 bug
的出现，具体存储方案可以灵活一些。

更好的选择之一是将 JWT 存储在 session cookie 中，auth0 有一篇很好的文章，感兴趣的读者可以参考：[Where to Store
Tokens](https://auth0.com/docs/security/store-tokens)。

#### JWT 隐患

JWT 实现鉴权也存在的隐患，上面我们也简要提到了，隐患主要来自 [XSS](https://www.owasp.org/index.php/Cross-
site_Scripting_%28XSS%29)。攻击者可以主动注入恶意脚本或者使用用户输入，通过 JavaScript 代码来偷取
token，接下来便能通过 token 冒充受害用户。

比如，一个博客留言系统，用户可以在其留言内容中加入以下脚本：

    
    
    <img src=x onerror="&#0000106&#0000097&#0000118&#0000097&#0000115&#0000099&#0000114&#0000105&#0000112&#0000116&#0000058&#0000097&#0000108&#0000101&#0000114&#0000116&#0000040&#0000039&#0000088&#0000083&#0000083&#0000039&#0000041">
    

一般的防御手段是采用 HTML 转义来控制过滤用户输入（为了防止 XSS 攻击，常常需要将用户输入的特殊字符进行转义）。

### 采用 Authentication cookie 实现鉴权

cookie 是含有有效期和相关 domain，存储在浏览器中的键值对组合，可以由 JavaScript 创建：

    
    
    document.cookie = ‘my_cookie_name=my_cookie_value’
    

也可以由服务端通过 response header 创建：

    
    
    Set-Cookie: my_cookie_name=my_cookie_value
    

浏览器会自动在每个请求当中加入相关 domain 下的 cookie：

    
    
    GET https://www.example.com/api/users
    Cookie: my_cookie_name=my_cookie_value
    

cookie 一般分为两种（[出处](https://developer.mozilla.org/en-
US/docs/Web/HTTP/Cookies)）：

>   * Session cookie，这种 cookie 会随着用户关闭浏览器而被清除，不会被标记任何过期时间 Expires 或者最大时限 Max-
Age。

>   * Permanent cookie，与 session cookie 相反，会在用户关闭浏览器之后被浏览器持久化存储。

>

同时，服务端可以对 cookie 进行一些关键配置，以保障 cookie 的使用安全，诸如：

  * HttpOnly cookie：浏览器端 JavaScript 没有读 cookie 权限。
  * Secure cookie：传输链路只有在特定安全通道（通常指 HTTPS），请求才会自动加入相关 cookie。
  * SameSite cookie：在跨域情况下，相关 cookie 无法被请求携带，这里主要是为了防止 CSRF 攻击。

一个经典场景就是使用 cookie 存储一个 session ID（session ID 由服务端管理，进行创建和计时，以便在必要的时候清除）。通过验证
cookie 和 session ID，服务端便能标记一个用户的访问信息。这种情况就是我们说的 stateful，而本节课的主角 JWT 是
stateless 的，因为它不需要服务端维护 session ID，是无状态的，更加利于横向扩展。

#### Authentication cookie 隐患

采用 Authentication cookie 实现单页应用鉴权的安全隐患主要有两种：

  * [XSS](https://www.owasp.org/index.php/Cross-site_Scripting_%28XSS%29) 如果没有使用 httpOnly 选项，那么攻击者可能会通过注入恶意脚本，任意读取用户 cookie。而 cookie 直接存储了用户的身份认证信息，这当然是非常可怕的。

  * [CSRF](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_\(CSRF\)) 是常见的针对 cookie 展开进攻的手段。我们知道跨域访问技术（CORS，跨域资源共享）的同源策略能保证不同源的客户端脚本在没有明确授权的情况下，无法读写对方资源。同源策略只是针对浏览器侧的编程脚本语言，如果我们对另一个恶意服务器发送 AJAX 请求，同源策略会有所限制，但是如果请求直接通过 HTML form 发送，那么同源策略毫无办法。

    
    
    <form action="http://someotherserver.com">
    

另一个利用 CSRF 实施攻击的场景为：假如受害者在网页中登录了 Facebook，同时又打开了 bad.com，bad.com
属于攻击者的网站，这个网站中有这样的代码：

    
    
    <img src="https://facebook.com/postComment?userId=dupont_123&comment=I_VE_BEEN_HACKED>
    

如此一来，攻击者网站的代码请求了 Facebook
发送个人状态的接口（https://facebook.com/postComment?），该受害者会莫名其妙地发送一个状态，内容为
"I_VE_BEEN_HACKED"。

**总结** 为了防御 XSS 攻击，需要开发者设置 `httpOnly` 选项；为了防御 XSRF，需要开发者设置 `SameSite`
选项。需要注意，并不是所有浏览器都支持 [SameSite](https://caniuse.com/#feat=same-site-cookie-
attribute)。

**此外，一些其他防御手段有：**

  * Short session timeout：设置 session 过期时间，比如银行网站往往需要每 10 分钟或者更短时间就重新登录。
  * 关键操作需要用户重新进行鉴权认证。
  * Double submitted cookie：当用户浏览一个站点时，服务端生成一个伪随机数 pseudorandom value，并将其设置为 cookie，且不设置 httpOnly 标识。这样 JavaScript 就能够访问这个 pseudorandom value，并要求在提交每个表单时，一并将这个 pseudorandom value 作为 form value 提交上来，同时在 cookie 中也要提交 value。服务端便可以对比 form value 中的 pseudorandom value 和 cookie value 是否一致，以此来认证用户的安全身份。

Double submitted cookie 之所以能有效防范攻击，是因为同源策略致使攻击者无法读取来自攻击目标服务端的 cookie
值，更无法修改攻击网站的 cookie value。即便攻击者可以从 form 中提交任何 form value，但是无法通过服务端对 form value
中的 pseudorandom value 和 cookie value 的一致性进行验证。

### 混合 JWT 和 cookie 进行鉴权

设想我们要实现这样一个鉴权系统：

  * 尽可能抵御 XSS 和 CSRF
  * 做到 stateless

考虑到安全性能，JWT 方案的主要问题在于攻击者存在直接读取 JWT 信息的可能。 **如果我们将 JWT 和 cookie 方案结合呢** ？即将 JWT
部分敏感信息放入 cookie 当中，这样一来，便可以结合前文两种方式的优点。

如图，我们再总结一下存在的三种交互可能。第一种是经典 JWT 方式：

![](https://images.gitbook.cn/b54a5600-4eac-11e9-9566-89cb1d9578c6)

这种情况下，前后端使用 JWT 进行鉴权交互，前端通过 JavaScript 操作 JWT 信息完成请求准备。

第二种方式，将 JWT 信息在 session cookie 中维护：

![](https://images.gitbook.cn/ba54c590-4eac-11e9-b1fa-0757868d211c)

在这种情况下，JWT 信息全部存储在 cookie 中， 并设置 cookie 的 httpOnly、SameSite、Secure 属性，前端无法读取
JWT 信息，但每次请求都会由浏览器带上必要的 JWT 数据（作为 cookie）。同时，由于采用 session cookie，也不存在 JWT
信息过期的情况，用户关闭页面之后不会将 JWT 信息持久化存储，下次再打开页面时，会重新进行鉴权流程。

第一种方式有一定的安全隐患；第二种方式我们将 JWT 所有信息存储在 session cookie
当中，优点明显，但是无法做到持久化存储，在某种程度上也会带来不便。那么我们权衡之后进行了变通，结合前面两种方式产生了第三种方式：

![](https://images.gitbook.cn/990f8c00-4eb9-11e9-b0b8-a9c8a3696845)

这样，JWT 的 signature 部分维护在设置了 httpOnly 的 cookie 中，这意味着 JavaScript 无法读取完整的 JWT
信息。同时，cookie 会在每次请求中被携带， 并由服务端返回后在浏览器中进行存储，这样 JWT 信息在每次请求时都可以被更新，JWT
过期时间也会被自动加入。

这篇文章：[Getting Token Authentication Right in a Stateless Single Page
Application](https://medium.com/lightrail/getting-token-authentication-right-
in-a-stateless-single-page-application-57d0c6474e3) 就很好地对上述方式进行了总结。

为了实现最大限度的安全保障，我们也可以考虑结合前文介绍的 Double submitted cookie 以及“关键操作需要用户重新进行鉴权认证”的处理。

例如，我们认为用户更改邮箱地址，是一个关键操作。那么，在发生这个操作时，即便用户已经登录，系统还是要求用户重新填写用户密码，以确认修改。后端在收到修改请求后，产生一个随机
number（经过加密运算），作为 permanent cookie 返回给前端，JavaScript 需要读取这个值，并将这个随机 number 作为表单
form value 的一项，它需要随新的邮箱地址一起提交，服务端对这个随机 form value 进行验证，验证方式是对比表单中的 form value
和 cookie 当中的随机 number 是否一致。

这样便更大限度地防御了 CSRF 攻击，流程如下：

![](https://images.gitbook.cn/c59db7e0-4eac-11e9-b1fa-0757868d211c)

我们总结一下流程。

  * Step 1：单页应用检查 cookie 中是否存在 JWT payload，如果存在，表示用户已经成功进行鉴权；反之，重定向到类似 /login 的登录页面。
  * Step2：用户在未授权的情况下，在登录页面 /login 将用户名和密码提交给服务端，服务端返回信息中设置 authentication cookie，cookie 中含有 JWT 信息。

第二步的具体操作方法可以采用上述第二种和第三种方式，或者增强 CSRF 防御的其他手段。

### 总结

我们再来总结一下单页应用进行鉴权的关键问题：token 最初由服务端下发，前端在请求时需要携带。这样一来：

  * 如果前端将 JWT 存储在 localStorage 或者 sessionStorage 当中，由于 localStorage 或者 sessionStorage 都可以被 JavaScript 访问，如果攻击者能够读取 localStorage 或者 sessionStorage，那么就能轻易获取 token，很容易进行 XSS 攻击。

  * 如果将 JWT 存储在 cookie 当中，我们就可以指定 cookie httpOnly 属性，来防止被 JavaScript 读取，也可以指定 secure 属性，来保证 JWT 信息只在 HTTPS 下被携带。但是这样容易遭到 CSRF 攻击，因此就出现了我们的增强方式。

本节我们通过分析和设计单页应用鉴权方案，熟悉了 JWT 和传统 cookie-
session。我们在介绍一些安全方面最佳实践的同时，覆盖了一些常见的攻击手段：XSS 和 CSRF
等。前端安全是一个庞大且复杂的课题，本节只是通过一个比较重要的话题带大家切入，要想全面熟悉前端安全，完全可以开一门新课了。虽然我的课程志不在此，不过下面我会根据相关安全话题，将我收藏的文章分享给大家。

课程代码仓库：

<https://github.com/HOUCe/lucas-gitchat-courses>

### 彩蛋分享

#### HTTPS 相关

  * [https 连接的前几毫秒发生了什么](https://mp.weixin.qq.com/s/--KxUNzmBdKtOPBbovWCaA)
  * [完全图解 HTTPS](https://juejin.im/post/5c441073e51d455226654d60)
  * [更安全的 Web 通信 HTTPS](https://juejin.im/post/5b5f1289e51d4519601aeeda)
  * [图解基于 HTTPS 的 DNS](https://www.infoq.cn/article/a-cartoon-intro-to-dns-over-https)
  * [看图学 HTTPS](https://juejin.im/post/5b0274ac6fb9a07aaa118f49?utm_medium=fe&utm_source=weixinqun)
  * [http 与 https 的区别我真的知道吗](https://juejin.im/post/5af3e002f265da0b7c074ada)
  * [深入揭秘 HTTPS 安全问题&连接建立全过程](https://zhuanlan.zhihu.com/p/22142170)
  * [HTTPS系列干货（一）：HTTPS 原理详解](http://support.upyun.com/hc/kb/article/1031843/)
  * [HTTPS 为什么更安全，先看这些](http://support.upyun.com/hc/kb/article/1031843/https://juejin.im/post/58a8f3295c497d005fbd58b1)

#### 攻防

  * [Web 前端攻防，一不小心就中招了](https://juejin.im/entry/58481d33128fe100579cb8c5)
  * [聊一聊 WEB 前端安全那些事儿](https://segmentfault.com/a/1190000006672214)
  * [常见 Web 安全攻防总结](https://zoumiaojiang.com/article/common-web-security/)
  * [前端安全防御指南](http://www.guofengxian.com/2018/01/15/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E9%98%B2%E5%BE%A1%E6%8C%87%E5%8D%97/)
  * [对于 XSS 和 CSRF 你究竟了解多少](http://netsecurity.51cto.com/art/201407/446775.htm)
  * [浅析前端安全之 XSS](https://mp.weixin.qq.com/s/c_QTdLu6vsYcIiuPRZyjyA)
  * [懂这些，你将能构建更安全的 Web 应用](https://juejin.im/entry/5b461d866fb9a04fb745c256)
  * [浅说 XSS 和 CSRF](https://juejin.im/entry/5b4b56fd5188251b1a7b2ac1)
  * [快速找出网站中可能存在的 XSS 漏洞实践](https://juejin.im/post/5b7bdfa1f265da437174ae0d)
  * [前端安全系列之一：如何防止 XSS 攻击？](https://mp.weixin.qq.com/s/kWxnYcCTLAQp5CGFrw30mQ)
  * [前端安全系列之二：如何防止 CSRF 攻击？](https://juejin.im/post/5bc009996fb9a05d0a055192)
  * [Web 安全漏洞之 XSS 攻击](https://juejin.im/post/5bf214e151882579cf011c2a)
  * [前端技术演进（三）：前端安全](https://juejin.im/post/5c137f37f265da6133567735)
  * [Preventing CSRF and XSRF Attacks](https://blog.codinghorror.com/preventing-csrf-and-xsrf-attacks/)

#### 同源策略和跨域理论相关

  * [跨域与同源策略探究](http://blog.w2fzu.com/2018/03/10/2018-04-02-same-origin/)
  * [同源策略和跨域请求研究](https://www.cnblogs.com/yincheng/p/cross-domain.html)
  * [为什么提交表单不受同源政策限制](https://segmentfault.com/q/1010000011535675/a-1020000011537760)
  * [跨域资源共享 CORS 一些知识点](https://juejin.im/post/5ab21717518825611a405da3)
  * [Content Security Policy (CSP) 介绍](https://juejin.im/entry/5b82b5e56fb9a01a02311b27)
  * [30 分钟理解 CORB 是什么](https://juejin.im/post/5b7e826ee51d4538b35c04e8)
  * [不要再问我跨域的问题了](https://mp.weixin.qq.com/s/T5gM7M9WsRMSxXzZPDagcA)

#### 鉴权

  * [讲真，别再使用 JWT 了！](https://www.jianshu.com/p/af8360b83a9f)
  * [JWT Token 存储在 Cookie 还是 Web Storage](https://blog.csdn.net/hxg117/article/details/76954606)
  * [Getting Token Authentication Right in a Stateless Single Page Application](https://medium.com/lightrail/getting-token-authentication-right-in-a-stateless-single-page-application-57d0c6474e3)
  * [登录那些事儿](https://juejin.im/entry/58a298f4128fe100582bf5c1)
  * [登录工程：现代 Web 应用的典型身份验证需求](https://juejin.im/entry/58a3d6f561ff4b006c875ee1)
  * [前后端常见的几种鉴权方式](https://blog.csdn.net/wang839305939/article/details/78713124)
  * [前端关于单点登录的知识](https://juejin.im/post/5b73c71fe51d45666016655a)
  * [如何加密传输和存储用户密码](https://juejin.im/post/5af5711e5188254267261e3b)
  * [Web 登录其实没那么简单](https://mp.weixin.qq.com/s/G_Grk8YTlu9-0WDZP85xAg)

#### CDN 劫持和其他安全问题

  * [危险的 target="_blank" 与 “opener”](https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&mid=2651227961&idx=1&sn=d4eb72b910281a18fc35581e0e39096f&chksm=bd495ebd8a3ed7ab2dcc8d6bbfdd6f336f5b80a301cd3e7f92f56bdd3c95c749d9d6fd77282f&mpshare=1&scene=1&srcid=0310vrk1VnUROjJY9XZ51Hoc)
  * [浅谈流量劫持与防治](https://zhuanlan.zhihu.com/p/40682772)
  * [短网址安全浅谈](https://security.tencent.com/index.php/blog/msg/126)
  * [使用 SRI 解决 CDN 劫持](https://juejin.im/post/5c355a816fb9a049a42f3ac8)
  * [了解下 DDoS 攻击方式](https://mp.weixin.qq.com/s/gVLXJO0IXol4q_ademXMWg)
  * [主流浏览器图片反防盗链方法总结](https://mp.weixin.qq.com/s/govRdwkNTEBJ1NJ1ipA40w?add=add)



## 大话社区和一名技术者的自我修养

在西班牙语中，有一个很特别的的词语叫做“Sobremesa”，它专指「吃完饭后，大家在饭桌上意犹未尽交谈的那段短暂而美好时光」。我们的专栏也已经全部更新完毕，历经“枯燥的程序知识”，我希望在最后部分，让我们放松心情，我将会从两方面谈一谈“软素质”，作为全部专栏内容的结束语。

### 融入社区

我们每一个人作为全球开发者的一份子，如果能够参与到社区，这对于个人成长会很有帮助的。这其中一个非常重要的话题就是「Github
使用礼仪」。大家可能比较熟悉了 Github 中使用 star、fork、watch 等基本功能。如果想重深度参与社区并成为开源库的贡献者，一般有两种方式：

  * 提 issue
  * 提 pull request

首先，提 issue 一般有两种情况：报 bug 和提需求。如果是报 bug，最重要的是确认 bug
和表达清楚复现方式。对于一些较为复杂的复现场景，我们可以写一个 demo
帮助维护者发现问题；如果是提需求，我们就要尽量把控需求的合理性，这一点对于天天和产品“撕逼”的我们来说，应该不是太大问题。

提 pull request，就是申请往主库中合并代码。这其中涉及到一些 Git 的基本操作，主要流程是先 fork
目标仓库，进行修改之后进行推送，最后进入目标项目页面，发起 PR。

当然，我们不仅仅可以给开源库贡献代码，也可以作为创始者，向社区贡献内容。这个环节中，“如何写好一个现代库”，这个问题涉及到了方方面面的知识。比如你要思考：

  * 证书如何设置
  * 文档如何设计，让使用者快速上手
  * TODO 和 CHANGELOG 需要遵循哪些规范
  * 如何设计构建流程
  * 如何设计编译范围和流程
  * 如何设计模块化方案和打包流程
  * 如何设计自动规范化链路
  * 如何保证版本规范和 commit 规范
  * 如何进行测试设计
  * 如何引入可持续集成
  * 其他最佳实践

为此，我给大家推荐我作为核心开发者的一个开源项目：[Jslib-base](https://github.com/yanhaijing/jslib-
base)，这是一个“为了写库而写的库”，它可以帮助开发者通过简单的命令就能创建出一个库的脚手架和基础代码。整个项目实现非常简单，但尽可能结合“最佳实践”。如果你想写一个库，那我建议你考虑使用它来开启第一步；如果你想了解如何从零设计一个项目，也许可以通过它收获启发。给大家推荐相关文章：

  * [8102年如何写一个现代的JavaScript库](https://zhuanlan.zhihu.com/p/46332833)

如果有机会，我会专门介绍一下这个库的编写和设计思想，虽然这不复杂，但是我们从中能够延伸出来的问题都很有趣。

### 自我修养

论“程序员”的修养，这个话题非常开放。我们能想到很多关键词，比如：

  * 保持热情
  * 谦虚谨慎
  * 学会阅读
  * 学会提问
  * 善用搜索
  * 学会写作（文档/博客等）
  * “科学上网”
  * 时间管理
  * 知识管理
  * 英语学习

我个人很不喜欢所谓的“成功学”和“方法论”，更讨厌“制造焦虑”，“兜售”鸡汤。免入俗套，我打算从两种动物来说一下“废话”。

不管是学习进阶之路，还是工作中的项目，我们能够遇到的真正问题只有两类：第一种是 **看不见的**
，我把它比作为黑天鹅，总会在你意想不到的时间和地点出现，并彻底颠覆一切；第二种是被我们 **视而不见的**
，我把它比喻成灰犀牛：你知道且习惯于它的存在，但是它会在某个时刻突然爆发，一旦爆发就会席卷一切，无从抵抗。

项目开发和个人成长都有黑天鹅和灰犀牛的危机。

#### 黑天鹅

「新技术的爆发，技术的更新换代」就是职业生涯的黑天鹅。但我们需要辩证地来认识他：对于菜鸟来说，新技术和未知领域让年轻人有机会弯道超车，减少因为欠缺经验和阅历而带来的劣势；对于有一定工作经验和阅历的程序员来说，「颠覆」和「变革」这样的词语似乎不那么友好。

但是新技术说到底也只是工具，而真正资深程序员的核心价值在于：逻辑、分析、数据、算法等抽象能力。技术工具只是这些抽象能力的表述形式。从汇编语言转到 C
语言，其实更能发挥 C 的强大控制能力；从 C 转到 Java，只需要理解面向对象和虚拟机就能很快适应并脱颖而出；从 Java 转到 Python
的程序员，甚至都会感叹写代码“太简单了”！

总之，黑天鹅即是危机，也是机会。新技术作为新工具，总能带来新的价值蓝海。如果能把黑天鹅当做机会，保持敏感、好奇和进取的心态，扩展技能树，就能驯服来势汹汹的新技术。我们所有人一起共勉。

#### 灰犀牛

社会中，很多职业是越老越值钱：老警察、老医生、老艺术家，说起来就让人觉得技术高超，令人信赖。

职业进阶就是一只灰犀牛。在悄悄溜走的时间中，我们可能习惯了日复一日的重复劳动。程序员怕的不是变老，而是变老的同时没有变强。如何击退这只灰犀牛，这需要我们从天天接触的工作代码入手，从熟悉的事物出发，找到突破。

比如，在这个专栏的工程化章节中，我重点突出了：如何增强程序的健硕性、如何让我们的开发效率提升、如何持续不断地完善项目、如何从零开始打磨基础构建体系。仔细思考，里面的内容也许就能接入你的项目当中。

从机械的工作抽象出更完美的工程化流程，这样的话题似乎永远说不完。我也总有新的心得和体会想和大家一起分享、交流。专栏已完结，但是衷心希望我们的技术探险之旅，仅仅是拉开帷幕。

### 最后

站在跑道的起点，你不知道跑到哪里肌肉会开始发痛，呼吸急促，想要停下来休息；在二三十岁的年纪，我们无从得知学习了一份课程，能对自己的水平提高和职业发展起多大作用。但我记得，在开篇词中，提到了村上春树的《当我谈跑步时，我谈些什么》这本书：也许不论是跑步还是写代码，都是在探索生命的种种可能。

—— 不去跑，永远不知道能跑多远；不去做，永远不知道能做多好。
